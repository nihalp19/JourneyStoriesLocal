var HM = Object.defineProperty; var w0 = e => { throw TypeError(e) }; var WM = (e, t, n) => t in e ? HM(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n; var Se = (e, t, n) => WM(e, typeof t != "symbol" ? t + "" : t, n), x0 = (e, t, n) => t.has(e) || w0("Cannot " + n); var Y = (e, t, n) => (x0(e, t, "read from private field"), n ? n.call(e) : t.get(e)), Le = (e, t, n) => t.has(e) ? w0("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n), Re = (e, t, n, r) => (x0(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n); function GM(e, t) { for (var n = 0; n < t.length; n++) { const r = t[n]; if (typeof r != "string" && !Array.isArray(r)) { for (const i in r) if (i !== "default" && !(i in e)) { const o = Object.getOwnPropertyDescriptor(r, i); o && Object.defineProperty(e, i, o.get ? o : { enumerable: !0, get: () => r[i] }) } } } return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" })) } (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i); new MutationObserver(i => { for (const o of i) if (o.type === "childList") for (const s of o.addedNodes) s.tagName === "LINK" && s.rel === "modulepreload" && r(s) }).observe(document, { childList: !0, subtree: !0 }); function n(i) { const o = {}; return i.integrity && (o.integrity = i.integrity), i.referrerPolicy && (o.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? o.credentials = "include" : i.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o } function r(i) { if (i.ep) return; i.ep = !0; const o = n(i); fetch(i.href, o) } })(); var ZH = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function CS(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } var PS = { exports: {} }, pf = {}, $S = { exports: {} }, Ce = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var wu = Symbol.for("react.element"), KM = Symbol.for("react.portal"), qM = Symbol.for("react.fragment"), YM = Symbol.for("react.strict_mode"), QM = Symbol.for("react.profiler"), XM = Symbol.for("react.provider"), JM = Symbol.for("react.context"), ZM = Symbol.for("react.forward_ref"), ek = Symbol.for("react.suspense"), tk = Symbol.for("react.memo"), nk = Symbol.for("react.lazy"), S0 = Symbol.iterator; function rk(e) { return e === null || typeof e != "object" ? null : (e = S0 && e[S0] || e["@@iterator"], typeof e == "function" ? e : null) } var AS = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, MS = Object.assign, kS = {}; function ua(e, t, n) { this.props = e, this.context = t, this.refs = kS, this.updater = n || AS } ua.prototype.isReactComponent = {}; ua.prototype.setState = function (e, t) { if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, e, t, "setState") }; ua.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, "forceUpdate") }; function _S() { } _S.prototype = ua.prototype; function Gg(e, t, n) { this.props = e, this.context = t, this.refs = kS, this.updater = n || AS } var Kg = Gg.prototype = new _S; Kg.constructor = Gg; MS(Kg, ua.prototype); Kg.isPureReactComponent = !0; var E0 = Array.isArray, RS = Object.prototype.hasOwnProperty, qg = { current: null }, LS = { key: !0, ref: !0, __self: !0, __source: !0 }; function NS(e, t, n) { var r, i = {}, o = null, s = null; if (t != null) for (r in t.ref !== void 0 && (s = t.ref), t.key !== void 0 && (o = "" + t.key), t) RS.call(t, r) && !LS.hasOwnProperty(r) && (i[r] = t[r]); var a = arguments.length - 2; if (a === 1) i.children = n; else if (1 < a) { for (var l = Array(a), u = 0; u < a; u++)l[u] = arguments[u + 2]; i.children = l } if (e && e.defaultProps) for (r in a = e.defaultProps, a) i[r] === void 0 && (i[r] = a[r]); return { $$typeof: wu, type: e, key: o, ref: s, props: i, _owner: qg.current } } function ik(e, t) { return { $$typeof: wu, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner } } function Yg(e) { return typeof e == "object" && e !== null && e.$$typeof === wu } function ok(e) { var t = { "=": "=0", ":": "=2" }; return "$" + e.replace(/[=:]/g, function (n) { return t[n] }) } var T0 = /\/+/g; function rp(e, t) { return typeof e == "object" && e !== null && e.key != null ? ok("" + e.key) : t.toString(36) } function Nc(e, t, n, r, i) { var o = typeof e; (o === "undefined" || o === "boolean") && (e = null); var s = !1; if (e === null) s = !0; else switch (o) { case "string": case "number": s = !0; break; case "object": switch (e.$$typeof) { case wu: case KM: s = !0 } }if (s) return s = e, i = i(s), e = r === "" ? "." + rp(s, 0) : r, E0(i) ? (n = "", e != null && (n = e.replace(T0, "$&/") + "/"), Nc(i, t, n, "", function (u) { return u })) : i != null && (Yg(i) && (i = ik(i, n + (!i.key || s && s.key === i.key ? "" : ("" + i.key).replace(T0, "$&/") + "/") + e)), t.push(i)), 1; if (s = 0, r = r === "" ? "." : r + ":", E0(e)) for (var a = 0; a < e.length; a++) { o = e[a]; var l = r + rp(o, a); s += Nc(o, t, n, l, i) } else if (l = rk(e), typeof l == "function") for (e = l.call(e), a = 0; !(o = e.next()).done;)o = o.value, l = r + rp(o, a++), s += Nc(o, t, n, l, i); else if (o === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."); return s } function Bu(e, t, n) { if (e == null) return e; var r = [], i = 0; return Nc(e, r, "", "", function (o) { return t.call(n, o, i++) }), r } function sk(e) { if (e._status === -1) { var t = e._result; t = t(), t.then(function (n) { (e._status === 0 || e._status === -1) && (e._status = 1, e._result = n) }, function (n) { (e._status === 0 || e._status === -1) && (e._status = 2, e._result = n) }), e._status === -1 && (e._status = 0, e._result = t) } if (e._status === 1) return e._result.default; throw e._result } var cn = { current: null }, Oc = { transition: null }, ak = { ReactCurrentDispatcher: cn, ReactCurrentBatchConfig: Oc, ReactCurrentOwner: qg }; function OS() { throw Error("act(...) is not supported in production builds of React.") } Ce.Children = { map: Bu, forEach: function (e, t, n) { Bu(e, function () { t.apply(this, arguments) }, n) }, count: function (e) { var t = 0; return Bu(e, function () { t++ }), t }, toArray: function (e) { return Bu(e, function (t) { return t }) || [] }, only: function (e) { if (!Yg(e)) throw Error("React.Children.only expected to receive a single React element child."); return e } }; Ce.Component = ua; Ce.Fragment = qM; Ce.Profiler = QM; Ce.PureComponent = Gg; Ce.StrictMode = YM; Ce.Suspense = ek; Ce.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ak; Ce.act = OS; Ce.cloneElement = function (e, t, n) { if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + "."); var r = MS({}, e.props), i = e.key, o = e.ref, s = e._owner; if (t != null) { if (t.ref !== void 0 && (o = t.ref, s = qg.current), t.key !== void 0 && (i = "" + t.key), e.type && e.type.defaultProps) var a = e.type.defaultProps; for (l in t) RS.call(t, l) && !LS.hasOwnProperty(l) && (r[l] = t[l] === void 0 && a !== void 0 ? a[l] : t[l]) } var l = arguments.length - 2; if (l === 1) r.children = n; else if (1 < l) { a = Array(l); for (var u = 0; u < l; u++)a[u] = arguments[u + 2]; r.children = a } return { $$typeof: wu, type: e.type, key: i, ref: o, props: r, _owner: s } }; Ce.createContext = function (e) { return e = { $$typeof: JM, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, e.Provider = { $$typeof: XM, _context: e }, e.Consumer = e }; Ce.createElement = NS; Ce.createFactory = function (e) { var t = NS.bind(null, e); return t.type = e, t }; Ce.createRef = function () { return { current: null } }; Ce.forwardRef = function (e) { return { $$typeof: ZM, render: e } }; Ce.isValidElement = Yg; Ce.lazy = function (e) { return { $$typeof: nk, _payload: { _status: -1, _result: e }, _init: sk } }; Ce.memo = function (e, t) { return { $$typeof: tk, type: e, compare: t === void 0 ? null : t } }; Ce.startTransition = function (e) { var t = Oc.transition; Oc.transition = {}; try { e() } finally { Oc.transition = t } }; Ce.unstable_act = OS; Ce.useCallback = function (e, t) { return cn.current.useCallback(e, t) }; Ce.useContext = function (e) { return cn.current.useContext(e) }; Ce.useDebugValue = function () { }; Ce.useDeferredValue = function (e) { return cn.current.useDeferredValue(e) }; Ce.useEffect = function (e, t) { return cn.current.useEffect(e, t) }; Ce.useId = function () { return cn.current.useId() }; Ce.useImperativeHandle = function (e, t, n) { return cn.current.useImperativeHandle(e, t, n) }; Ce.useInsertionEffect = function (e, t) { return cn.current.useInsertionEffect(e, t) }; Ce.useLayoutEffect = function (e, t) { return cn.current.useLayoutEffect(e, t) }; Ce.useMemo = function (e, t) { return cn.current.useMemo(e, t) }; Ce.useReducer = function (e, t, n) { return cn.current.useReducer(e, t, n) }; Ce.useRef = function (e) { return cn.current.useRef(e) }; Ce.useState = function (e) { return cn.current.useState(e) }; Ce.useSyncExternalStore = function (e, t, n) { return cn.current.useSyncExternalStore(e, t, n) }; Ce.useTransition = function () { return cn.current.useTransition() }; Ce.version = "18.3.1"; $S.exports = Ce; var S = $S.exports; const se = CS(S), lk = GM({ __proto__: null, default: se }, [S]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var uk = S, ck = Symbol.for("react.element"), dk = Symbol.for("react.fragment"), fk = Object.prototype.hasOwnProperty, pk = uk.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, hk = { key: !0, ref: !0, __self: !0, __source: !0 }; function jS(e, t, n) { var r, i = {}, o = null, s = null; n !== void 0 && (o = "" + n), t.key !== void 0 && (o = "" + t.key), t.ref !== void 0 && (s = t.ref); for (r in t) fk.call(t, r) && !hk.hasOwnProperty(r) && (i[r] = t[r]); if (e && e.defaultProps) for (r in t = e.defaultProps, t) i[r] === void 0 && (i[r] = t[r]); return { $$typeof: ck, type: e, key: o, ref: s, props: i, _owner: pk.current } } pf.Fragment = dk; pf.jsx = jS; pf.jsxs = jS; PS.exports = pf; var w = PS.exports, Rh = {}, IS = { exports: {} }, On = {}, DS = { exports: {} }, FS = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (e) { function t(D, V) { var H = D.length; D.push(V); e: for (; 0 < H;) { var T = H - 1 >>> 1, N = D[T]; if (0 < i(N, V)) D[T] = V, D[H] = N, H = T; else break e } } function n(D) { return D.length === 0 ? null : D[0] } function r(D) { if (D.length === 0) return null; var V = D[0], H = D.pop(); if (H !== V) { D[0] = H; e: for (var T = 0, N = D.length, W = N >>> 1; T < W;) { var Q = 2 * (T + 1) - 1, q = D[Q], te = Q + 1, ae = D[te]; if (0 > i(q, H)) te < N && 0 > i(ae, q) ? (D[T] = ae, D[te] = H, T = te) : (D[T] = q, D[Q] = H, T = Q); else if (te < N && 0 > i(ae, H)) D[T] = ae, D[te] = H, T = te; else break e } } return V } function i(D, V) { var H = D.sortIndex - V.sortIndex; return H !== 0 ? H : D.id - V.id } if (typeof performance == "object" && typeof performance.now == "function") { var o = performance; e.unstable_now = function () { return o.now() } } else { var s = Date, a = s.now(); e.unstable_now = function () { return s.now() - a } } var l = [], u = [], c = 1, d = null, f = 3, p = !1, m = !1, v = !1, x = typeof setTimeout == "function" ? setTimeout : null, g = typeof clearTimeout == "function" ? clearTimeout : null, h = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function y(D) { for (var V = n(u); V !== null;) { if (V.callback === null) r(u); else if (V.startTime <= D) r(u), V.sortIndex = V.expirationTime, t(l, V); else break; V = n(u) } } function E(D) { if (v = !1, y(D), !m) if (n(l) !== null) m = !0, U(P); else { var V = n(u); V !== null && z(E, V.startTime - D) } } function P(D, V) { m = !1, v && (v = !1, g(b), b = -1), p = !0; var H = f; try { for (y(V), d = n(l); d !== null && (!(d.expirationTime > V) || D && !A());) { var T = d.callback; if (typeof T == "function") { d.callback = null, f = d.priorityLevel; var N = T(d.expirationTime <= V); V = e.unstable_now(), typeof N == "function" ? d.callback = N : d === n(l) && r(l), y(V) } else r(l); d = n(l) } if (d !== null) var W = !0; else { var Q = n(u); Q !== null && z(E, Q.startTime - V), W = !1 } return W } finally { d = null, f = H, p = !1 } } var $ = !1, L = null, b = -1, M = 5, R = -1; function A() { return !(e.unstable_now() - R < M) } function _() { if (L !== null) { var D = e.unstable_now(); R = D; var V = !0; try { V = L(!0, D) } finally { V ? C() : ($ = !1, L = null) } } else $ = !1 } var C; if (typeof h == "function") C = function () { h(_) }; else if (typeof MessageChannel < "u") { var k = new MessageChannel, O = k.port2; k.port1.onmessage = _, C = function () { O.postMessage(null) } } else C = function () { x(_, 0) }; function U(D) { L = D, $ || ($ = !0, C()) } function z(D, V) { b = x(function () { D(e.unstable_now()) }, V) } e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function (D) { D.callback = null }, e.unstable_continueExecution = function () { m || p || (m = !0, U(P)) }, e.unstable_forceFrameRate = function (D) { 0 > D || 125 < D ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : M = 0 < D ? Math.floor(1e3 / D) : 5 }, e.unstable_getCurrentPriorityLevel = function () { return f }, e.unstable_getFirstCallbackNode = function () { return n(l) }, e.unstable_next = function (D) { switch (f) { case 1: case 2: case 3: var V = 3; break; default: V = f }var H = f; f = V; try { return D() } finally { f = H } }, e.unstable_pauseExecution = function () { }, e.unstable_requestPaint = function () { }, e.unstable_runWithPriority = function (D, V) { switch (D) { case 1: case 2: case 3: case 4: case 5: break; default: D = 3 }var H = f; f = D; try { return V() } finally { f = H } }, e.unstable_scheduleCallback = function (D, V, H) { var T = e.unstable_now(); switch (typeof H == "object" && H !== null ? (H = H.delay, H = typeof H == "number" && 0 < H ? T + H : T) : H = T, D) { case 1: var N = -1; break; case 2: N = 250; break; case 5: N = 1073741823; break; case 4: N = 1e4; break; default: N = 5e3 }return N = H + N, D = { id: c++, callback: V, priorityLevel: D, startTime: H, expirationTime: N, sortIndex: -1 }, H > T ? (D.sortIndex = H, t(u, D), n(l) === null && D === n(u) && (v ? (g(b), b = -1) : v = !0, z(E, H - T))) : (D.sortIndex = N, t(l, D), m || p || (m = !0, U(P))), D }, e.unstable_shouldYield = A, e.unstable_wrapCallback = function (D) { var V = f; return function () { var H = f; f = V; try { return D.apply(this, arguments) } finally { f = H } } } })(FS); DS.exports = FS; var mk = DS.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var gk = S, Rn = mk; function ee(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)t += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var zS = new Set, Al = {}; function Ko(e, t) { Js(e, t), Js(e + "Capture", t) } function Js(e, t) { for (Al[e] = t, e = 0; e < t.length; e++)zS.add(t[e]) } var Jr = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Lh = Object.prototype.hasOwnProperty, vk = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, C0 = {}, P0 = {}; function yk(e) { return Lh.call(P0, e) ? !0 : Lh.call(C0, e) ? !1 : vk.test(e) ? P0[e] = !0 : (C0[e] = !0, !1) } function bk(e, t, n, r) { if (n !== null && n.type === 0) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return r ? !1 : n !== null ? !n.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-"); default: return !1 } } function wk(e, t, n, r) { if (t === null || typeof t > "u" || bk(e, t, n, r)) return !0; if (r) return !1; if (n !== null) switch (n.type) { case 3: return !t; case 4: return t === !1; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 } function dn(e, t, n, r, i, o, s) { this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = o, this.removeEmptyString = s } var Ut = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) { Ut[e] = new dn(e, 0, !1, e, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) { var t = e[0]; Ut[t] = new dn(t, 1, !1, e[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) { Ut[e] = new dn(e, 2, !1, e.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) { Ut[e] = new dn(e, 2, !1, e, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) { Ut[e] = new dn(e, 3, !1, e.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (e) { Ut[e] = new dn(e, 3, !0, e, null, !1, !1) });["capture", "download"].forEach(function (e) { Ut[e] = new dn(e, 4, !1, e, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (e) { Ut[e] = new dn(e, 6, !1, e, null, !1, !1) });["rowSpan", "start"].forEach(function (e) { Ut[e] = new dn(e, 5, !1, e.toLowerCase(), null, !1, !1) }); var Qg = /[\-:]([a-z])/g; function Xg(e) { return e[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) { var t = e.replace(Qg, Xg); Ut[t] = new dn(t, 1, !1, e, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) { var t = e.replace(Qg, Xg); Ut[t] = new dn(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (e) { var t = e.replace(Qg, Xg); Ut[t] = new dn(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (e) { Ut[e] = new dn(e, 1, !1, e.toLowerCase(), null, !1, !1) }); Ut.xlinkHref = new dn("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (e) { Ut[e] = new dn(e, 1, !1, e.toLowerCase(), null, !0, !0) }); function Jg(e, t, n, r) { var i = Ut.hasOwnProperty(t) ? Ut[t] : null; (i !== null ? i.type !== 0 : r || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (wk(t, n, i, r) && (n = null), r || i === null ? yk(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = n === null ? i.type === 3 ? !1 : "" : n : (t = i.attributeName, r = i.attributeNamespace, n === null ? e.removeAttribute(t) : (i = i.type, n = i === 3 || i === 4 && n === !0 ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n)))) } var ai = gk.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Uu = Symbol.for("react.element"), vs = Symbol.for("react.portal"), ys = Symbol.for("react.fragment"), Zg = Symbol.for("react.strict_mode"), Nh = Symbol.for("react.profiler"), VS = Symbol.for("react.provider"), BS = Symbol.for("react.context"), ev = Symbol.for("react.forward_ref"), Oh = Symbol.for("react.suspense"), jh = Symbol.for("react.suspense_list"), tv = Symbol.for("react.memo"), bi = Symbol.for("react.lazy"), US = Symbol.for("react.offscreen"), $0 = Symbol.iterator; function Ca(e) { return e === null || typeof e != "object" ? null : (e = $0 && e[$0] || e["@@iterator"], typeof e == "function" ? e : null) } var rt = Object.assign, ip; function Qa(e) {
  if (ip === void 0) try { throw Error() } catch (n) { var t = n.stack.trim().match(/\n( *(at )?)/); ip = t && t[1] || "" } return `
`+ ip + e
} var op = !1; function sp(e, t) {
  if (!e || op) return ""; op = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(t, []) } catch (u) { var r = u } Reflect.construct(e, [], t) } else { try { t.call() } catch (u) { r = u } e.call(t.prototype) } else { try { throw Error() } catch (u) { r = u } e() } } catch (u) {
    if (u && r && typeof u.stack == "string") {
      for (var i = u.stack.split(`
`), o = r.stack.split(`
`), s = i.length - 1, a = o.length - 1; 1 <= s && 0 <= a && i[s] !== o[a];)a--; for (; 1 <= s && 0 <= a; s--, a--)if (i[s] !== o[a]) {
        if (s !== 1 || a !== 1) do if (s--, a--, 0 > a || i[s] !== o[a]) {
          var l = `
`+ i[s].replace(" at new ", " at "); return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l
        } while (1 <= s && 0 <= a); break
      }
    }
  } finally { op = !1, Error.prepareStackTrace = n } return (e = e ? e.displayName || e.name : "") ? Qa(e) : ""
} function xk(e) { switch (e.tag) { case 5: return Qa(e.type); case 16: return Qa("Lazy"); case 13: return Qa("Suspense"); case 19: return Qa("SuspenseList"); case 0: case 2: case 15: return e = sp(e.type, !1), e; case 11: return e = sp(e.type.render, !1), e; case 1: return e = sp(e.type, !0), e; default: return "" } } function Ih(e) { if (e == null) return null; if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case ys: return "Fragment"; case vs: return "Portal"; case Nh: return "Profiler"; case Zg: return "StrictMode"; case Oh: return "Suspense"; case jh: return "SuspenseList" }if (typeof e == "object") switch (e.$$typeof) { case BS: return (e.displayName || "Context") + ".Consumer"; case VS: return (e._context.displayName || "Context") + ".Provider"; case ev: var t = e.render; return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case tv: return t = e.displayName || null, t !== null ? t : Ih(e.type) || "Memo"; case bi: t = e._payload, e = e._init; try { return Ih(e(t)) } catch { } }return null } function Sk(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return Ih(t); case 8: return t === Zg ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t }return null } function Wi(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function HS(e) { var t = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio") } function Ek(e) { var t = HS(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), r = "" + e[t]; if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") { var i = n.get, o = n.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return i.call(this) }, set: function (s) { r = "" + s, o.call(this, s) } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue: function () { return r }, setValue: function (s) { r = "" + s }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } } function Hu(e) { e._valueTracker || (e._valueTracker = Ek(e)) } function WS(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var n = t.getValue(), r = ""; return e && (r = HS(e) ? e.checked ? "true" : "false" : e.value), e = r, e !== n ? (t.setValue(e), !0) : !1 } function id(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } function Dh(e, t) { var n = t.checked; return rt({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n ?? e._wrapperState.initialChecked }) } function A0(e, t) { var n = t.defaultValue == null ? "" : t.defaultValue, r = t.checked != null ? t.checked : t.defaultChecked; n = Wi(t.value != null ? t.value : n), e._wrapperState = { initialChecked: r, initialValue: n, controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null } } function GS(e, t) { t = t.checked, t != null && Jg(e, "checked", t, !1) } function Fh(e, t) { GS(e, t); var n = Wi(t.value), r = t.type; if (n != null) r === "number" ? (n === 0 && e.value === "" || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n); else if (r === "submit" || r === "reset") { e.removeAttribute("value"); return } t.hasOwnProperty("value") ? zh(e, t.type, n) : t.hasOwnProperty("defaultValue") && zh(e, t.type, Wi(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked) } function M0(e, t, n) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var r = t.type; if (!(r !== "submit" && r !== "reset" || t.value !== void 0 && t.value !== null)) return; t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t } n = e.name, n !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, n !== "" && (e.name = n) } function zh(e, t, n) { (t !== "number" || id(e.ownerDocument) !== e) && (n == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n)) } var Xa = Array.isArray; function Is(e, t, n, r) { if (e = e.options, t) { t = {}; for (var i = 0; i < n.length; i++)t["$" + n[i]] = !0; for (n = 0; n < e.length; n++)i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0) } else { for (n = "" + Wi(n), t = null, i = 0; i < e.length; i++) { if (e[i].value === n) { e[i].selected = !0, r && (e[i].defaultSelected = !0); return } t !== null || e[i].disabled || (t = e[i]) } t !== null && (t.selected = !0) } } function Vh(e, t) { if (t.dangerouslySetInnerHTML != null) throw Error(ee(91)); return rt({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function k0(e, t) { var n = t.value; if (n == null) { if (n = t.children, t = t.defaultValue, n != null) { if (t != null) throw Error(ee(92)); if (Xa(n)) { if (1 < n.length) throw Error(ee(93)); n = n[0] } t = n } t == null && (t = ""), n = t } e._wrapperState = { initialValue: Wi(n) } } function KS(e, t) { var n = Wi(t.value), r = Wi(t.defaultValue); n != null && (n = "" + n, n !== e.value && (e.value = n), t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)), r != null && (e.defaultValue = "" + r) } function _0(e) { var t = e.textContent; t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t) } function qS(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function Bh(e, t) { return e == null || e === "http://www.w3.org/1999/xhtml" ? qS(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e } var Wu, YS = function (e) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (t, n, r, i) { MSApp.execUnsafeLocalFunction(function () { return e(t, n, r, i) }) } : e }(function (e, t) { if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t; else { for (Wu = Wu || document.createElement("div"), Wu.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = Wu.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }); function Ml(e, t) { if (t) { var n = e.firstChild; if (n && n === e.lastChild && n.nodeType === 3) { n.nodeValue = t; return } } e.textContent = t } var cl = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, Tk = ["Webkit", "ms", "Moz", "O"]; Object.keys(cl).forEach(function (e) { Tk.forEach(function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), cl[t] = cl[e] }) }); function QS(e, t, n) { return t == null || typeof t == "boolean" || t === "" ? "" : n || typeof t != "number" || t === 0 || cl.hasOwnProperty(e) && cl[e] ? ("" + t).trim() : t + "px" } function XS(e, t) { e = e.style; for (var n in t) if (t.hasOwnProperty(n)) { var r = n.indexOf("--") === 0, i = QS(n, t[n], r); n === "float" && (n = "cssFloat"), r ? e.setProperty(n, i) : e[n] = i } } var Ck = rt({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function Uh(e, t) { if (t) { if (Ck[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(ee(137, e)); if (t.dangerouslySetInnerHTML != null) { if (t.children != null) throw Error(ee(60)); if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(ee(61)) } if (t.style != null && typeof t.style != "object") throw Error(ee(62)) } } function Hh(e, t) { if (e.indexOf("-") === -1) return typeof t.is == "string"; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var Wh = null; function nv(e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var Gh = null, Ds = null, Fs = null; function R0(e) { if (e = Eu(e)) { if (typeof Gh != "function") throw Error(ee(280)); var t = e.stateNode; t && (t = yf(t), Gh(e.stateNode, e.type, t)) } } function JS(e) { Ds ? Fs ? Fs.push(e) : Fs = [e] : Ds = e } function ZS() { if (Ds) { var e = Ds, t = Fs; if (Fs = Ds = null, R0(e), t) for (e = 0; e < t.length; e++)R0(t[e]) } } function eE(e, t) { return e(t) } function tE() { } var ap = !1; function nE(e, t, n) { if (ap) return e(t, n); ap = !0; try { return eE(e, t, n) } finally { ap = !1, (Ds !== null || Fs !== null) && (tE(), ZS()) } } function kl(e, t) { var n = e.stateNode; if (n === null) return null; var r = yf(n); if (r === null) return null; n = r[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (e = e.type, r = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !r; break e; default: e = !1 }if (e) return null; if (n && typeof n != "function") throw Error(ee(231, t, typeof n)); return n } var Kh = !1; if (Jr) try { var Pa = {}; Object.defineProperty(Pa, "passive", { get: function () { Kh = !0 } }), window.addEventListener("test", Pa, Pa), window.removeEventListener("test", Pa, Pa) } catch { Kh = !1 } function Pk(e, t, n, r, i, o, s, a, l) { var u = Array.prototype.slice.call(arguments, 3); try { t.apply(n, u) } catch (c) { this.onError(c) } } var dl = !1, od = null, sd = !1, qh = null, $k = { onError: function (e) { dl = !0, od = e } }; function Ak(e, t, n, r, i, o, s, a, l) { dl = !1, od = null, Pk.apply($k, arguments) } function Mk(e, t, n, r, i, o, s, a, l) { if (Ak.apply(this, arguments), dl) { if (dl) { var u = od; dl = !1, od = null } else throw Error(ee(198)); sd || (sd = !0, qh = u) } } function qo(e) { var t = e, n = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do t = e, t.flags & 4098 && (n = t.return), e = t.return; while (e) } return t.tag === 3 ? n : null } function rE(e) { if (e.tag === 13) { var t = e.memoizedState; if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated } return null } function L0(e) { if (qo(e) !== e) throw Error(ee(188)) } function kk(e) { var t = e.alternate; if (!t) { if (t = qo(e), t === null) throw Error(ee(188)); return t !== e ? null : e } for (var n = e, r = t; ;) { var i = n.return; if (i === null) break; var o = i.alternate; if (o === null) { if (r = i.return, r !== null) { n = r; continue } break } if (i.child === o.child) { for (o = i.child; o;) { if (o === n) return L0(i), e; if (o === r) return L0(i), t; o = o.sibling } throw Error(ee(188)) } if (n.return !== r.return) n = i, r = o; else { for (var s = !1, a = i.child; a;) { if (a === n) { s = !0, n = i, r = o; break } if (a === r) { s = !0, r = i, n = o; break } a = a.sibling } if (!s) { for (a = o.child; a;) { if (a === n) { s = !0, n = o, r = i; break } if (a === r) { s = !0, r = o, n = i; break } a = a.sibling } if (!s) throw Error(ee(189)) } } if (n.alternate !== r) throw Error(ee(190)) } if (n.tag !== 3) throw Error(ee(188)); return n.stateNode.current === n ? e : t } function iE(e) { return e = kk(e), e !== null ? oE(e) : null } function oE(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { var t = oE(e); if (t !== null) return t; e = e.sibling } return null } var sE = Rn.unstable_scheduleCallback, N0 = Rn.unstable_cancelCallback, _k = Rn.unstable_shouldYield, Rk = Rn.unstable_requestPaint, pt = Rn.unstable_now, Lk = Rn.unstable_getCurrentPriorityLevel, rv = Rn.unstable_ImmediatePriority, aE = Rn.unstable_UserBlockingPriority, ad = Rn.unstable_NormalPriority, Nk = Rn.unstable_LowPriority, lE = Rn.unstable_IdlePriority, hf = null, Ar = null; function Ok(e) { if (Ar && typeof Ar.onCommitFiberRoot == "function") try { Ar.onCommitFiberRoot(hf, e, void 0, (e.current.flags & 128) === 128) } catch { } } var pr = Math.clz32 ? Math.clz32 : Dk, jk = Math.log, Ik = Math.LN2; function Dk(e) { return e >>>= 0, e === 0 ? 32 : 31 - (jk(e) / Ik | 0) | 0 } var Gu = 64, Ku = 4194304; function Ja(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return e & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function ld(e, t) { var n = e.pendingLanes; if (n === 0) return 0; var r = 0, i = e.suspendedLanes, o = e.pingedLanes, s = n & 268435455; if (s !== 0) { var a = s & ~i; a !== 0 ? r = Ja(a) : (o &= s, o !== 0 && (r = Ja(o))) } else s = n & ~i, s !== 0 ? r = Ja(s) : o !== 0 && (r = Ja(o)); if (r === 0) return 0; if (t !== 0 && t !== r && !(t & i) && (i = r & -r, o = t & -t, i >= o || i === 16 && (o & 4194240) !== 0)) return t; if (r & 4 && (r |= n & 16), t = e.entangledLanes, t !== 0) for (e = e.entanglements, t &= r; 0 < t;)n = 31 - pr(t), i = 1 << n, r |= e[n], t &= ~i; return r } function Fk(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function zk(e, t) { for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, o = e.pendingLanes; 0 < o;) { var s = 31 - pr(o), a = 1 << s, l = i[s]; l === -1 ? (!(a & n) || a & r) && (i[s] = Fk(a, t)) : l <= t && (e.expiredLanes |= a), o &= ~a } } function Yh(e) { return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0 } function uE() { var e = Gu; return Gu <<= 1, !(Gu & 4194240) && (Gu = 64), e } function lp(e) { for (var t = [], n = 0; 31 > n; n++)t.push(e); return t } function xu(e, t, n) { e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - pr(t), e[t] = n } function Vk(e, t) { var n = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var r = e.eventTimes; for (e = e.expirationTimes; 0 < n;) { var i = 31 - pr(n), o = 1 << i; t[i] = 0, r[i] = -1, e[i] = -1, n &= ~o } } function iv(e, t) { var n = e.entangledLanes |= t; for (e = e.entanglements; n;) { var r = 31 - pr(n), i = 1 << r; i & t | e[r] & t && (e[r] |= t), n &= ~i } } var Ie = 0; function cE(e) { return e &= -e, 1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1 } var dE, ov, fE, pE, hE, Qh = !1, qu = [], Ii = null, Di = null, Fi = null, _l = new Map, Rl = new Map, Ei = [], Bk = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function O0(e, t) { switch (e) { case "focusin": case "focusout": Ii = null; break; case "dragenter": case "dragleave": Di = null; break; case "mouseover": case "mouseout": Fi = null; break; case "pointerover": case "pointerout": _l.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": Rl.delete(t.pointerId) } } function $a(e, t, n, r, i, o) { return e === null || e.nativeEvent !== o ? (e = { blockedOn: t, domEventName: n, eventSystemFlags: r, nativeEvent: o, targetContainers: [i] }, t !== null && (t = Eu(t), t !== null && ov(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, i !== null && t.indexOf(i) === -1 && t.push(i), e) } function Uk(e, t, n, r, i) { switch (t) { case "focusin": return Ii = $a(Ii, e, t, n, r, i), !0; case "dragenter": return Di = $a(Di, e, t, n, r, i), !0; case "mouseover": return Fi = $a(Fi, e, t, n, r, i), !0; case "pointerover": var o = i.pointerId; return _l.set(o, $a(_l.get(o) || null, e, t, n, r, i)), !0; case "gotpointercapture": return o = i.pointerId, Rl.set(o, $a(Rl.get(o) || null, e, t, n, r, i)), !0 }return !1 } function mE(e) { var t = mo(e.target); if (t !== null) { var n = qo(t); if (n !== null) { if (t = n.tag, t === 13) { if (t = rE(n), t !== null) { e.blockedOn = t, hE(e.priority, function () { fE(n) }); return } } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null; return } } } e.blockedOn = null } function jc(e) { if (e.blockedOn !== null) return !1; for (var t = e.targetContainers; 0 < t.length;) { var n = Xh(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (n === null) { n = e.nativeEvent; var r = new n.constructor(n.type, n); Wh = r, n.target.dispatchEvent(r), Wh = null } else return t = Eu(n), t !== null && ov(t), e.blockedOn = n, !1; t.shift() } return !0 } function j0(e, t, n) { jc(e) && n.delete(t) } function Hk() { Qh = !1, Ii !== null && jc(Ii) && (Ii = null), Di !== null && jc(Di) && (Di = null), Fi !== null && jc(Fi) && (Fi = null), _l.forEach(j0), Rl.forEach(j0) } function Aa(e, t) { e.blockedOn === t && (e.blockedOn = null, Qh || (Qh = !0, Rn.unstable_scheduleCallback(Rn.unstable_NormalPriority, Hk))) } function Ll(e) { function t(i) { return Aa(i, e) } if (0 < qu.length) { Aa(qu[0], e); for (var n = 1; n < qu.length; n++) { var r = qu[n]; r.blockedOn === e && (r.blockedOn = null) } } for (Ii !== null && Aa(Ii, e), Di !== null && Aa(Di, e), Fi !== null && Aa(Fi, e), _l.forEach(t), Rl.forEach(t), n = 0; n < Ei.length; n++)r = Ei[n], r.blockedOn === e && (r.blockedOn = null); for (; 0 < Ei.length && (n = Ei[0], n.blockedOn === null);)mE(n), n.blockedOn === null && Ei.shift() } var zs = ai.ReactCurrentBatchConfig, ud = !0; function Wk(e, t, n, r) { var i = Ie, o = zs.transition; zs.transition = null; try { Ie = 1, sv(e, t, n, r) } finally { Ie = i, zs.transition = o } } function Gk(e, t, n, r) { var i = Ie, o = zs.transition; zs.transition = null; try { Ie = 4, sv(e, t, n, r) } finally { Ie = i, zs.transition = o } } function sv(e, t, n, r) { if (ud) { var i = Xh(e, t, n, r); if (i === null) yp(e, t, r, cd, n), O0(e, r); else if (Uk(i, e, t, n, r)) r.stopPropagation(); else if (O0(e, r), t & 4 && -1 < Bk.indexOf(e)) { for (; i !== null;) { var o = Eu(i); if (o !== null && dE(o), o = Xh(e, t, n, r), o === null && yp(e, t, r, cd, n), o === i) break; i = o } i !== null && r.stopPropagation() } else yp(e, t, r, null, n) } } var cd = null; function Xh(e, t, n, r) { if (cd = null, e = nv(r), e = mo(e), e !== null) if (t = qo(e), t === null) e = null; else if (n = t.tag, n === 13) { if (e = rE(t), e !== null) return e; e = null } else if (n === 3) { if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return cd = e, null } function gE(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (Lk()) { case rv: return 1; case aE: return 4; case ad: case Nk: return 16; case lE: return 536870912; default: return 16 }default: return 16 } } var _i = null, av = null, Ic = null; function vE() { if (Ic) return Ic; var e, t = av, n = t.length, r, i = "value" in _i ? _i.value : _i.textContent, o = i.length; for (e = 0; e < n && t[e] === i[e]; e++); var s = n - e; for (r = 1; r <= s && t[n - r] === i[o - r]; r++); return Ic = i.slice(e, 1 < r ? 1 - r : void 0) } function Dc(e) { var t = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function Yu() { return !0 } function I0() { return !1 } function jn(e) { function t(n, r, i, o, s) { this._reactName = n, this._targetInst = i, this.type = r, this.nativeEvent = o, this.target = s, this.currentTarget = null; for (var a in e) e.hasOwnProperty(a) && (n = e[a], this[a] = n ? n(o) : o[a]); return this.isDefaultPrevented = (o.defaultPrevented != null ? o.defaultPrevented : o.returnValue === !1) ? Yu : I0, this.isPropagationStopped = I0, this } return rt(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = Yu) }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = Yu) }, persist: function () { }, isPersistent: Yu }), t } var ca = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, lv = jn(ca), Su = rt({}, ca, { view: 0, detail: 0 }), Kk = jn(Su), up, cp, Ma, mf = rt({}, Su, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: uv, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== Ma && (Ma && e.type === "mousemove" ? (up = e.screenX - Ma.screenX, cp = e.screenY - Ma.screenY) : cp = up = 0, Ma = e), up) }, movementY: function (e) { return "movementY" in e ? e.movementY : cp } }), D0 = jn(mf), qk = rt({}, mf, { dataTransfer: 0 }), Yk = jn(qk), Qk = rt({}, Su, { relatedTarget: 0 }), dp = jn(Qk), Xk = rt({}, ca, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Jk = jn(Xk), Zk = rt({}, ca, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), e_ = jn(Zk), t_ = rt({}, ca, { data: 0 }), F0 = jn(t_), n_ = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, r_ = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, i_ = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function o_(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : (e = i_[e]) ? !!t[e] : !1 } function uv() { return o_ } var s_ = rt({}, Su, { key: function (e) { if (e.key) { var t = n_[e.key] || e.key; if (t !== "Unidentified") return t } return e.type === "keypress" ? (e = Dc(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? r_[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: uv, charCode: function (e) { return e.type === "keypress" ? Dc(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? Dc(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), a_ = jn(s_), l_ = rt({}, mf, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), z0 = jn(l_), u_ = rt({}, Su, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: uv }), c_ = jn(u_), d_ = rt({}, ca, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), f_ = jn(d_), p_ = rt({}, mf, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), h_ = jn(p_), m_ = [9, 13, 27, 32], cv = Jr && "CompositionEvent" in window, fl = null; Jr && "documentMode" in document && (fl = document.documentMode); var g_ = Jr && "TextEvent" in window && !fl, yE = Jr && (!cv || fl && 8 < fl && 11 >= fl), V0 = " ", B0 = !1; function bE(e, t) { switch (e) { case "keyup": return m_.indexOf(t.keyCode) !== -1; case "keydown": return t.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function wE(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var bs = !1; function v_(e, t) { switch (e) { case "compositionend": return wE(t); case "keypress": return t.which !== 32 ? null : (B0 = !0, V0); case "textInput": return e = t.data, e === V0 && B0 ? null : e; default: return null } } function y_(e, t) { if (bs) return e === "compositionend" || !cv && bE(e, t) ? (e = vE(), Ic = av = _i = null, bs = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return yE && t.locale !== "ko" ? null : t.data; default: return null } } var b_ = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function U0(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t === "input" ? !!b_[e.type] : t === "textarea" } function xE(e, t, n, r) { JS(r), t = dd(t, "onChange"), 0 < t.length && (n = new lv("onChange", "change", null, n, r), e.push({ event: n, listeners: t })) } var pl = null, Nl = null; function w_(e) { RE(e, 0) } function gf(e) { var t = Ss(e); if (WS(t)) return e } function x_(e, t) { if (e === "change") return t } var SE = !1; if (Jr) { var fp; if (Jr) { var pp = "oninput" in document; if (!pp) { var H0 = document.createElement("div"); H0.setAttribute("oninput", "return;"), pp = typeof H0.oninput == "function" } fp = pp } else fp = !1; SE = fp && (!document.documentMode || 9 < document.documentMode) } function W0() { pl && (pl.detachEvent("onpropertychange", EE), Nl = pl = null) } function EE(e) { if (e.propertyName === "value" && gf(Nl)) { var t = []; xE(t, Nl, e, nv(e)), nE(w_, t) } } function S_(e, t, n) { e === "focusin" ? (W0(), pl = t, Nl = n, pl.attachEvent("onpropertychange", EE)) : e === "focusout" && W0() } function E_(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return gf(Nl) } function T_(e, t) { if (e === "click") return gf(t) } function C_(e, t) { if (e === "input" || e === "change") return gf(t) } function P_(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t } var mr = typeof Object.is == "function" ? Object.is : P_; function Ol(e, t) { if (mr(e, t)) return !0; if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1; var n = Object.keys(e), r = Object.keys(t); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var i = n[r]; if (!Lh.call(t, i) || !mr(e[i], t[i])) return !1 } return !0 } function G0(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function K0(e, t) { var n = G0(e); e = 0; for (var r; n;) { if (n.nodeType === 3) { if (r = e + n.textContent.length, e <= t && r >= t) return { node: n, offset: t - e }; e = r } e: { for (; n;) { if (n.nextSibling) { n = n.nextSibling; break e } n = n.parentNode } n = void 0 } n = G0(n) } } function TE(e, t) { return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? TE(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1 } function CE() { for (var e = window, t = id(); t instanceof e.HTMLIFrameElement;) { try { var n = typeof t.contentWindow.location.href == "string" } catch { n = !1 } if (n) e = t.contentWindow; else break; t = id(e.document) } return t } function dv(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true") } function $_(e) { var t = CE(), n = e.focusedElem, r = e.selectionRange; if (t !== n && n && n.ownerDocument && TE(n.ownerDocument.documentElement, n)) { if (r !== null && dv(n)) { if (t = r.start, e = r.end, e === void 0 && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length); else if (e = (t = n.ownerDocument || document) && t.defaultView || window, e.getSelection) { e = e.getSelection(); var i = n.textContent.length, o = Math.min(r.start, i); r = r.end === void 0 ? o : Math.min(r.end, i), !e.extend && o > r && (i = r, r = o, o = i), i = K0(n, o); var s = K0(n, r); i && s && (e.rangeCount !== 1 || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== s.node || e.focusOffset !== s.offset) && (t = t.createRange(), t.setStart(i.node, i.offset), e.removeAllRanges(), o > r ? (e.addRange(t), e.extend(s.node, s.offset)) : (t.setEnd(s.node, s.offset), e.addRange(t))) } } for (t = [], e = n; e = e.parentNode;)e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++)e = t[n], e.element.scrollLeft = e.left, e.element.scrollTop = e.top } } var A_ = Jr && "documentMode" in document && 11 >= document.documentMode, ws = null, Jh = null, hl = null, Zh = !1; function q0(e, t, n) { var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; Zh || ws == null || ws !== id(r) || (r = ws, "selectionStart" in r && dv(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = { anchorNode: r.anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }), hl && Ol(hl, r) || (hl = r, r = dd(Jh, "onSelect"), 0 < r.length && (t = new lv("onSelect", "select", null, t, n), e.push({ event: t, listeners: r }), t.target = ws))) } function Qu(e, t) { var n = {}; return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n } var xs = { animationend: Qu("Animation", "AnimationEnd"), animationiteration: Qu("Animation", "AnimationIteration"), animationstart: Qu("Animation", "AnimationStart"), transitionend: Qu("Transition", "TransitionEnd") }, hp = {}, PE = {}; Jr && (PE = document.createElement("div").style, "AnimationEvent" in window || (delete xs.animationend.animation, delete xs.animationiteration.animation, delete xs.animationstart.animation), "TransitionEvent" in window || delete xs.transitionend.transition); function vf(e) { if (hp[e]) return hp[e]; if (!xs[e]) return e; var t = xs[e], n; for (n in t) if (t.hasOwnProperty(n) && n in PE) return hp[e] = t[n]; return e } var $E = vf("animationend"), AE = vf("animationiteration"), ME = vf("animationstart"), kE = vf("transitionend"), _E = new Map, Y0 = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Qi(e, t) { _E.set(e, t), Ko(t, [e]) } for (var mp = 0; mp < Y0.length; mp++) { var gp = Y0[mp], M_ = gp.toLowerCase(), k_ = gp[0].toUpperCase() + gp.slice(1); Qi(M_, "on" + k_) } Qi($E, "onAnimationEnd"); Qi(AE, "onAnimationIteration"); Qi(ME, "onAnimationStart"); Qi("dblclick", "onDoubleClick"); Qi("focusin", "onFocus"); Qi("focusout", "onBlur"); Qi(kE, "onTransitionEnd"); Js("onMouseEnter", ["mouseout", "mouseover"]); Js("onMouseLeave", ["mouseout", "mouseover"]); Js("onPointerEnter", ["pointerout", "pointerover"]); Js("onPointerLeave", ["pointerout", "pointerover"]); Ko("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); Ko("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); Ko("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); Ko("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); Ko("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); Ko("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Za = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), __ = new Set("cancel close invalid load scroll toggle".split(" ").concat(Za)); function Q0(e, t, n) { var r = e.type || "unknown-event"; e.currentTarget = n, Mk(r, t, void 0, e), e.currentTarget = null } function RE(e, t) { t = (t & 4) !== 0; for (var n = 0; n < e.length; n++) { var r = e[n], i = r.event; r = r.listeners; e: { var o = void 0; if (t) for (var s = r.length - 1; 0 <= s; s--) { var a = r[s], l = a.instance, u = a.currentTarget; if (a = a.listener, l !== o && i.isPropagationStopped()) break e; Q0(i, a, u), o = l } else for (s = 0; s < r.length; s++) { if (a = r[s], l = a.instance, u = a.currentTarget, a = a.listener, l !== o && i.isPropagationStopped()) break e; Q0(i, a, u), o = l } } } if (sd) throw e = qh, sd = !1, qh = null, e } function We(e, t) { var n = t[im]; n === void 0 && (n = t[im] = new Set); var r = e + "__bubble"; n.has(r) || (LE(t, e, 2, !1), n.add(r)) } function vp(e, t, n) { var r = 0; t && (r |= 4), LE(n, e, r, t) } var Xu = "_reactListening" + Math.random().toString(36).slice(2); function jl(e) { if (!e[Xu]) { e[Xu] = !0, zS.forEach(function (n) { n !== "selectionchange" && (__.has(n) || vp(n, !1, e), vp(n, !0, e)) }); var t = e.nodeType === 9 ? e : e.ownerDocument; t === null || t[Xu] || (t[Xu] = !0, vp("selectionchange", !1, t)) } } function LE(e, t, n, r) { switch (gE(t)) { case 1: var i = Wk; break; case 4: i = Gk; break; default: i = sv }n = i.bind(null, t, n, e), i = void 0, !Kh || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (i = !0), r ? i !== void 0 ? e.addEventListener(t, n, { capture: !0, passive: i }) : e.addEventListener(t, n, !0) : i !== void 0 ? e.addEventListener(t, n, { passive: i }) : e.addEventListener(t, n, !1) } function yp(e, t, n, r, i) { var o = r; if (!(t & 1) && !(t & 2) && r !== null) e: for (; ;) { if (r === null) return; var s = r.tag; if (s === 3 || s === 4) { var a = r.stateNode.containerInfo; if (a === i || a.nodeType === 8 && a.parentNode === i) break; if (s === 4) for (s = r.return; s !== null;) { var l = s.tag; if ((l === 3 || l === 4) && (l = s.stateNode.containerInfo, l === i || l.nodeType === 8 && l.parentNode === i)) return; s = s.return } for (; a !== null;) { if (s = mo(a), s === null) return; if (l = s.tag, l === 5 || l === 6) { r = o = s; continue e } a = a.parentNode } } r = r.return } nE(function () { var u = o, c = nv(n), d = []; e: { var f = _E.get(e); if (f !== void 0) { var p = lv, m = e; switch (e) { case "keypress": if (Dc(n) === 0) break e; case "keydown": case "keyup": p = a_; break; case "focusin": m = "focus", p = dp; break; case "focusout": m = "blur", p = dp; break; case "beforeblur": case "afterblur": p = dp; break; case "click": if (n.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": p = D0; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": p = Yk; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": p = c_; break; case $E: case AE: case ME: p = Jk; break; case kE: p = f_; break; case "scroll": p = Kk; break; case "wheel": p = h_; break; case "copy": case "cut": case "paste": p = e_; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": p = z0 }var v = (t & 4) !== 0, x = !v && e === "scroll", g = v ? f !== null ? f + "Capture" : null : f; v = []; for (var h = u, y; h !== null;) { y = h; var E = y.stateNode; if (y.tag === 5 && E !== null && (y = E, g !== null && (E = kl(h, g), E != null && v.push(Il(h, E, y)))), x) break; h = h.return } 0 < v.length && (f = new p(f, m, null, n, c), d.push({ event: f, listeners: v })) } } if (!(t & 7)) { e: { if (f = e === "mouseover" || e === "pointerover", p = e === "mouseout" || e === "pointerout", f && n !== Wh && (m = n.relatedTarget || n.fromElement) && (mo(m) || m[Zr])) break e; if ((p || f) && (f = c.window === c ? c : (f = c.ownerDocument) ? f.defaultView || f.parentWindow : window, p ? (m = n.relatedTarget || n.toElement, p = u, m = m ? mo(m) : null, m !== null && (x = qo(m), m !== x || m.tag !== 5 && m.tag !== 6) && (m = null)) : (p = null, m = u), p !== m)) { if (v = D0, E = "onMouseLeave", g = "onMouseEnter", h = "mouse", (e === "pointerout" || e === "pointerover") && (v = z0, E = "onPointerLeave", g = "onPointerEnter", h = "pointer"), x = p == null ? f : Ss(p), y = m == null ? f : Ss(m), f = new v(E, h + "leave", p, n, c), f.target = x, f.relatedTarget = y, E = null, mo(c) === u && (v = new v(g, h + "enter", m, n, c), v.target = y, v.relatedTarget = x, E = v), x = E, p && m) t: { for (v = p, g = m, h = 0, y = v; y; y = ss(y))h++; for (y = 0, E = g; E; E = ss(E))y++; for (; 0 < h - y;)v = ss(v), h--; for (; 0 < y - h;)g = ss(g), y--; for (; h--;) { if (v === g || g !== null && v === g.alternate) break t; v = ss(v), g = ss(g) } v = null } else v = null; p !== null && X0(d, f, p, v, !1), m !== null && x !== null && X0(d, x, m, v, !0) } } e: { if (f = u ? Ss(u) : window, p = f.nodeName && f.nodeName.toLowerCase(), p === "select" || p === "input" && f.type === "file") var P = x_; else if (U0(f)) if (SE) P = C_; else { P = E_; var $ = S_ } else (p = f.nodeName) && p.toLowerCase() === "input" && (f.type === "checkbox" || f.type === "radio") && (P = T_); if (P && (P = P(e, u))) { xE(d, P, n, c); break e } $ && $(e, f, u), e === "focusout" && ($ = f._wrapperState) && $.controlled && f.type === "number" && zh(f, "number", f.value) } switch ($ = u ? Ss(u) : window, e) { case "focusin": (U0($) || $.contentEditable === "true") && (ws = $, Jh = u, hl = null); break; case "focusout": hl = Jh = ws = null; break; case "mousedown": Zh = !0; break; case "contextmenu": case "mouseup": case "dragend": Zh = !1, q0(d, n, c); break; case "selectionchange": if (A_) break; case "keydown": case "keyup": q0(d, n, c) }var L; if (cv) e: { switch (e) { case "compositionstart": var b = "onCompositionStart"; break e; case "compositionend": b = "onCompositionEnd"; break e; case "compositionupdate": b = "onCompositionUpdate"; break e }b = void 0 } else bs ? bE(e, n) && (b = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (b = "onCompositionStart"); b && (yE && n.locale !== "ko" && (bs || b !== "onCompositionStart" ? b === "onCompositionEnd" && bs && (L = vE()) : (_i = c, av = "value" in _i ? _i.value : _i.textContent, bs = !0)), $ = dd(u, b), 0 < $.length && (b = new F0(b, e, null, n, c), d.push({ event: b, listeners: $ }), L ? b.data = L : (L = wE(n), L !== null && (b.data = L)))), (L = g_ ? v_(e, n) : y_(e, n)) && (u = dd(u, "onBeforeInput"), 0 < u.length && (c = new F0("onBeforeInput", "beforeinput", null, n, c), d.push({ event: c, listeners: u }), c.data = L)) } RE(d, t) }) } function Il(e, t, n) { return { instance: e, listener: t, currentTarget: n } } function dd(e, t) { for (var n = t + "Capture", r = []; e !== null;) { var i = e, o = i.stateNode; i.tag === 5 && o !== null && (i = o, o = kl(e, n), o != null && r.unshift(Il(e, o, i)), o = kl(e, t), o != null && r.push(Il(e, o, i))), e = e.return } return r } function ss(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null } function X0(e, t, n, r, i) { for (var o = t._reactName, s = []; n !== null && n !== r;) { var a = n, l = a.alternate, u = a.stateNode; if (l !== null && l === r) break; a.tag === 5 && u !== null && (a = u, i ? (l = kl(n, o), l != null && s.unshift(Il(n, l, a))) : i || (l = kl(n, o), l != null && s.push(Il(n, l, a)))), n = n.return } s.length !== 0 && e.push({ event: t, listeners: s }) } var R_ = /\r\n?/g, L_ = /\u0000|\uFFFD/g; function J0(e) {
  return (typeof e == "string" ? e : "" + e).replace(R_, `
`).replace(L_, "")
} function Ju(e, t, n) { if (t = J0(t), J0(e) !== t && n) throw Error(ee(425)) } function fd() { } var em = null, tm = null; function nm(e, t) { return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null } var rm = typeof setTimeout == "function" ? setTimeout : void 0, N_ = typeof clearTimeout == "function" ? clearTimeout : void 0, Z0 = typeof Promise == "function" ? Promise : void 0, O_ = typeof queueMicrotask == "function" ? queueMicrotask : typeof Z0 < "u" ? function (e) { return Z0.resolve(null).then(e).catch(j_) } : rm; function j_(e) { setTimeout(function () { throw e }) } function bp(e, t) { var n = t, r = 0; do { var i = n.nextSibling; if (e.removeChild(n), i && i.nodeType === 8) if (n = i.data, n === "/$") { if (r === 0) { e.removeChild(i), Ll(t); return } r-- } else n !== "$" && n !== "$?" && n !== "$!" || r++; n = i } while (n); Ll(t) } function zi(e) { for (; e != null; e = e.nextSibling) { var t = e.nodeType; if (t === 1 || t === 3) break; if (t === 8) { if (t = e.data, t === "$" || t === "$!" || t === "$?") break; if (t === "/$") return null } } return e } function eb(e) { e = e.previousSibling; for (var t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "$" || n === "$!" || n === "$?") { if (t === 0) return e; t-- } else n === "/$" && t++ } e = e.previousSibling } return null } var da = Math.random().toString(36).slice(2), Tr = "__reactFiber$" + da, Dl = "__reactProps$" + da, Zr = "__reactContainer$" + da, im = "__reactEvents$" + da, I_ = "__reactListeners$" + da, D_ = "__reactHandles$" + da; function mo(e) { var t = e[Tr]; if (t) return t; for (var n = e.parentNode; n;) { if (t = n[Zr] || n[Tr]) { if (n = t.alternate, t.child !== null || n !== null && n.child !== null) for (e = eb(e); e !== null;) { if (n = e[Tr]) return n; e = eb(e) } return t } e = n, n = e.parentNode } return null } function Eu(e) { return e = e[Tr] || e[Zr], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e } function Ss(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(ee(33)) } function yf(e) { return e[Dl] || null } var om = [], Es = -1; function Xi(e) { return { current: e } } function Ke(e) { 0 > Es || (e.current = om[Es], om[Es] = null, Es--) } function Ve(e, t) { Es++, om[Es] = e.current, e.current = t } var Gi = {}, Xt = Xi(Gi), gn = Xi(!1), No = Gi; function Zs(e, t) { var n = e.type.contextTypes; if (!n) return Gi; var r = e.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext; var i = {}, o; for (o in n) i[o] = t[o]; return r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = i), i } function vn(e) { return e = e.childContextTypes, e != null } function pd() { Ke(gn), Ke(Xt) } function tb(e, t, n) { if (Xt.current !== Gi) throw Error(ee(168)); Ve(Xt, t), Ve(gn, n) } function NE(e, t, n) { var r = e.stateNode; if (t = t.childContextTypes, typeof r.getChildContext != "function") return n; r = r.getChildContext(); for (var i in r) if (!(i in t)) throw Error(ee(108, Sk(e) || "Unknown", i)); return rt({}, n, r) } function hd(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || Gi, No = Xt.current, Ve(Xt, e), Ve(gn, gn.current), !0 } function nb(e, t, n) { var r = e.stateNode; if (!r) throw Error(ee(169)); n ? (e = NE(e, t, No), r.__reactInternalMemoizedMergedChildContext = e, Ke(gn), Ke(Xt), Ve(Xt, e)) : Ke(gn), Ve(gn, n) } var Vr = null, bf = !1, wp = !1; function OE(e) { Vr === null ? Vr = [e] : Vr.push(e) } function F_(e) { bf = !0, OE(e) } function Ji() { if (!wp && Vr !== null) { wp = !0; var e = 0, t = Ie; try { var n = Vr; for (Ie = 1; e < n.length; e++) { var r = n[e]; do r = r(!0); while (r !== null) } Vr = null, bf = !1 } catch (i) { throw Vr !== null && (Vr = Vr.slice(e + 1)), sE(rv, Ji), i } finally { Ie = t, wp = !1 } } return null } var Ts = [], Cs = 0, md = null, gd = 0, Hn = [], Wn = 0, Oo = null, Wr = 1, Gr = ""; function ao(e, t) { Ts[Cs++] = gd, Ts[Cs++] = md, md = e, gd = t } function jE(e, t, n) { Hn[Wn++] = Wr, Hn[Wn++] = Gr, Hn[Wn++] = Oo, Oo = e; var r = Wr; e = Gr; var i = 32 - pr(r) - 1; r &= ~(1 << i), n += 1; var o = 32 - pr(t) + i; if (30 < o) { var s = i - i % 5; o = (r & (1 << s) - 1).toString(32), r >>= s, i -= s, Wr = 1 << 32 - pr(t) + i | n << i | r, Gr = o + e } else Wr = 1 << o | n << i | r, Gr = e } function fv(e) { e.return !== null && (ao(e, 1), jE(e, 1, 0)) } function pv(e) { for (; e === md;)md = Ts[--Cs], Ts[Cs] = null, gd = Ts[--Cs], Ts[Cs] = null; for (; e === Oo;)Oo = Hn[--Wn], Hn[Wn] = null, Gr = Hn[--Wn], Hn[Wn] = null, Wr = Hn[--Wn], Hn[Wn] = null } var An = null, Pn = null, Xe = !1, dr = null; function IE(e, t) { var n = Qn(5, null, null, 0); n.elementType = "DELETED", n.stateNode = t, n.return = e, t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n) } function rb(e, t) { switch (e.tag) { case 5: var n = e.type; return t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null ? (e.stateNode = t, An = e, Pn = zi(t.firstChild), !0) : !1; case 6: return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null ? (e.stateNode = t, An = e, Pn = null, !0) : !1; case 13: return t = t.nodeType !== 8 ? null : t, t !== null ? (n = Oo !== null ? { id: Wr, overflow: Gr } : null, e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }, n = Qn(18, null, null, 0), n.stateNode = t, n.return = e, e.child = n, An = e, Pn = null, !0) : !1; default: return !1 } } function sm(e) { return (e.mode & 1) !== 0 && (e.flags & 128) === 0 } function am(e) { if (Xe) { var t = Pn; if (t) { var n = t; if (!rb(e, t)) { if (sm(e)) throw Error(ee(418)); t = zi(n.nextSibling); var r = An; t && rb(e, t) ? IE(r, n) : (e.flags = e.flags & -4097 | 2, Xe = !1, An = e) } } else { if (sm(e)) throw Error(ee(418)); e.flags = e.flags & -4097 | 2, Xe = !1, An = e } } } function ib(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; An = e } function Zu(e) { if (e !== An) return !1; if (!Xe) return ib(e), Xe = !0, !1; var t; if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !nm(e.type, e.memoizedProps)), t && (t = Pn)) { if (sm(e)) throw DE(), Error(ee(418)); for (; t;)IE(e, t), t = zi(t.nextSibling) } if (ib(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(ee(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "/$") { if (t === 0) { Pn = zi(e.nextSibling); break e } t-- } else n !== "$" && n !== "$!" && n !== "$?" || t++ } e = e.nextSibling } Pn = null } } else Pn = An ? zi(e.stateNode.nextSibling) : null; return !0 } function DE() { for (var e = Pn; e;)e = zi(e.nextSibling) } function ea() { Pn = An = null, Xe = !1 } function hv(e) { dr === null ? dr = [e] : dr.push(e) } var z_ = ai.ReactCurrentBatchConfig; function ka(e, t, n) { if (e = n.ref, e !== null && typeof e != "function" && typeof e != "object") { if (n._owner) { if (n = n._owner, n) { if (n.tag !== 1) throw Error(ee(309)); var r = n.stateNode } if (!r) throw Error(ee(147, e)); var i = r, o = "" + e; return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === o ? t.ref : (t = function (s) { var a = i.refs; s === null ? delete a[o] : a[o] = s }, t._stringRef = o, t) } if (typeof e != "string") throw Error(ee(284)); if (!n._owner) throw Error(ee(290, e)) } return e } function ec(e, t) { throw e = Object.prototype.toString.call(t), Error(ee(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function ob(e) { var t = e._init; return t(e._payload) } function FE(e) { function t(g, h) { if (e) { var y = g.deletions; y === null ? (g.deletions = [h], g.flags |= 16) : y.push(h) } } function n(g, h) { if (!e) return null; for (; h !== null;)t(g, h), h = h.sibling; return null } function r(g, h) { for (g = new Map; h !== null;)h.key !== null ? g.set(h.key, h) : g.set(h.index, h), h = h.sibling; return g } function i(g, h) { return g = Hi(g, h), g.index = 0, g.sibling = null, g } function o(g, h, y) { return g.index = y, e ? (y = g.alternate, y !== null ? (y = y.index, y < h ? (g.flags |= 2, h) : y) : (g.flags |= 2, h)) : (g.flags |= 1048576, h) } function s(g) { return e && g.alternate === null && (g.flags |= 2), g } function a(g, h, y, E) { return h === null || h.tag !== 6 ? (h = $p(y, g.mode, E), h.return = g, h) : (h = i(h, y), h.return = g, h) } function l(g, h, y, E) { var P = y.type; return P === ys ? c(g, h, y.props.children, E, y.key) : h !== null && (h.elementType === P || typeof P == "object" && P !== null && P.$$typeof === bi && ob(P) === h.type) ? (E = i(h, y.props), E.ref = ka(g, h, y), E.return = g, E) : (E = Wc(y.type, y.key, y.props, null, g.mode, E), E.ref = ka(g, h, y), E.return = g, E) } function u(g, h, y, E) { return h === null || h.tag !== 4 || h.stateNode.containerInfo !== y.containerInfo || h.stateNode.implementation !== y.implementation ? (h = Ap(y, g.mode, E), h.return = g, h) : (h = i(h, y.children || []), h.return = g, h) } function c(g, h, y, E, P) { return h === null || h.tag !== 7 ? (h = Mo(y, g.mode, E, P), h.return = g, h) : (h = i(h, y), h.return = g, h) } function d(g, h, y) { if (typeof h == "string" && h !== "" || typeof h == "number") return h = $p("" + h, g.mode, y), h.return = g, h; if (typeof h == "object" && h !== null) { switch (h.$$typeof) { case Uu: return y = Wc(h.type, h.key, h.props, null, g.mode, y), y.ref = ka(g, null, h), y.return = g, y; case vs: return h = Ap(h, g.mode, y), h.return = g, h; case bi: var E = h._init; return d(g, E(h._payload), y) }if (Xa(h) || Ca(h)) return h = Mo(h, g.mode, y, null), h.return = g, h; ec(g, h) } return null } function f(g, h, y, E) { var P = h !== null ? h.key : null; if (typeof y == "string" && y !== "" || typeof y == "number") return P !== null ? null : a(g, h, "" + y, E); if (typeof y == "object" && y !== null) { switch (y.$$typeof) { case Uu: return y.key === P ? l(g, h, y, E) : null; case vs: return y.key === P ? u(g, h, y, E) : null; case bi: return P = y._init, f(g, h, P(y._payload), E) }if (Xa(y) || Ca(y)) return P !== null ? null : c(g, h, y, E, null); ec(g, y) } return null } function p(g, h, y, E, P) { if (typeof E == "string" && E !== "" || typeof E == "number") return g = g.get(y) || null, a(h, g, "" + E, P); if (typeof E == "object" && E !== null) { switch (E.$$typeof) { case Uu: return g = g.get(E.key === null ? y : E.key) || null, l(h, g, E, P); case vs: return g = g.get(E.key === null ? y : E.key) || null, u(h, g, E, P); case bi: var $ = E._init; return p(g, h, y, $(E._payload), P) }if (Xa(E) || Ca(E)) return g = g.get(y) || null, c(h, g, E, P, null); ec(h, E) } return null } function m(g, h, y, E) { for (var P = null, $ = null, L = h, b = h = 0, M = null; L !== null && b < y.length; b++) { L.index > b ? (M = L, L = null) : M = L.sibling; var R = f(g, L, y[b], E); if (R === null) { L === null && (L = M); break } e && L && R.alternate === null && t(g, L), h = o(R, h, b), $ === null ? P = R : $.sibling = R, $ = R, L = M } if (b === y.length) return n(g, L), Xe && ao(g, b), P; if (L === null) { for (; b < y.length; b++)L = d(g, y[b], E), L !== null && (h = o(L, h, b), $ === null ? P = L : $.sibling = L, $ = L); return Xe && ao(g, b), P } for (L = r(g, L); b < y.length; b++)M = p(L, g, b, y[b], E), M !== null && (e && M.alternate !== null && L.delete(M.key === null ? b : M.key), h = o(M, h, b), $ === null ? P = M : $.sibling = M, $ = M); return e && L.forEach(function (A) { return t(g, A) }), Xe && ao(g, b), P } function v(g, h, y, E) { var P = Ca(y); if (typeof P != "function") throw Error(ee(150)); if (y = P.call(y), y == null) throw Error(ee(151)); for (var $ = P = null, L = h, b = h = 0, M = null, R = y.next(); L !== null && !R.done; b++, R = y.next()) { L.index > b ? (M = L, L = null) : M = L.sibling; var A = f(g, L, R.value, E); if (A === null) { L === null && (L = M); break } e && L && A.alternate === null && t(g, L), h = o(A, h, b), $ === null ? P = A : $.sibling = A, $ = A, L = M } if (R.done) return n(g, L), Xe && ao(g, b), P; if (L === null) { for (; !R.done; b++, R = y.next())R = d(g, R.value, E), R !== null && (h = o(R, h, b), $ === null ? P = R : $.sibling = R, $ = R); return Xe && ao(g, b), P } for (L = r(g, L); !R.done; b++, R = y.next())R = p(L, g, b, R.value, E), R !== null && (e && R.alternate !== null && L.delete(R.key === null ? b : R.key), h = o(R, h, b), $ === null ? P = R : $.sibling = R, $ = R); return e && L.forEach(function (_) { return t(g, _) }), Xe && ao(g, b), P } function x(g, h, y, E) { if (typeof y == "object" && y !== null && y.type === ys && y.key === null && (y = y.props.children), typeof y == "object" && y !== null) { switch (y.$$typeof) { case Uu: e: { for (var P = y.key, $ = h; $ !== null;) { if ($.key === P) { if (P = y.type, P === ys) { if ($.tag === 7) { n(g, $.sibling), h = i($, y.props.children), h.return = g, g = h; break e } } else if ($.elementType === P || typeof P == "object" && P !== null && P.$$typeof === bi && ob(P) === $.type) { n(g, $.sibling), h = i($, y.props), h.ref = ka(g, $, y), h.return = g, g = h; break e } n(g, $); break } else t(g, $); $ = $.sibling } y.type === ys ? (h = Mo(y.props.children, g.mode, E, y.key), h.return = g, g = h) : (E = Wc(y.type, y.key, y.props, null, g.mode, E), E.ref = ka(g, h, y), E.return = g, g = E) } return s(g); case vs: e: { for ($ = y.key; h !== null;) { if (h.key === $) if (h.tag === 4 && h.stateNode.containerInfo === y.containerInfo && h.stateNode.implementation === y.implementation) { n(g, h.sibling), h = i(h, y.children || []), h.return = g, g = h; break e } else { n(g, h); break } else t(g, h); h = h.sibling } h = Ap(y, g.mode, E), h.return = g, g = h } return s(g); case bi: return $ = y._init, x(g, h, $(y._payload), E) }if (Xa(y)) return m(g, h, y, E); if (Ca(y)) return v(g, h, y, E); ec(g, y) } return typeof y == "string" && y !== "" || typeof y == "number" ? (y = "" + y, h !== null && h.tag === 6 ? (n(g, h.sibling), h = i(h, y), h.return = g, g = h) : (n(g, h), h = $p(y, g.mode, E), h.return = g, g = h), s(g)) : n(g, h) } return x } var ta = FE(!0), zE = FE(!1), vd = Xi(null), yd = null, Ps = null, mv = null; function gv() { mv = Ps = yd = null } function vv(e) { var t = vd.current; Ke(vd), e._currentValue = t } function lm(e, t, n) { for (; e !== null;) { var r = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, r !== null && (r.childLanes |= t)) : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break; e = e.return } } function Vs(e, t) { yd = e, mv = Ps = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & t && (mn = !0), e.firstContext = null) } function Jn(e) { var t = e._currentValue; if (mv !== e) if (e = { context: e, memoizedValue: t, next: null }, Ps === null) { if (yd === null) throw Error(ee(308)); Ps = e, yd.dependencies = { lanes: 0, firstContext: e } } else Ps = Ps.next = e; return t } var go = null; function yv(e) { go === null ? go = [e] : go.push(e) } function VE(e, t, n, r) { var i = t.interleaved; return i === null ? (n.next = n, yv(t)) : (n.next = i.next, i.next = n), t.interleaved = n, ei(e, r) } function ei(e, t) { e.lanes |= t; var n = e.alternate; for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null;)e.childLanes |= t, n = e.alternate, n !== null && (n.childLanes |= t), n = e, e = e.return; return n.tag === 3 ? n.stateNode : null } var wi = !1; function bv(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function BE(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function qr(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function Vi(e, t, n) { var r = e.updateQueue; if (r === null) return null; if (r = r.shared, Ne & 2) { var i = r.pending; return i === null ? t.next = t : (t.next = i.next, i.next = t), r.pending = t, ei(e, n) } return i = r.interleaved, i === null ? (t.next = t, yv(r)) : (t.next = i.next, i.next = t), r.interleaved = t, ei(e, n) } function Fc(e, t, n) { if (t = t.updateQueue, t !== null && (t = t.shared, (n & 4194240) !== 0)) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, iv(e, n) } } function sb(e, t) { var n = e.updateQueue, r = e.alternate; if (r !== null && (r = r.updateQueue, n === r)) { var i = null, o = null; if (n = n.firstBaseUpdate, n !== null) { do { var s = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; o === null ? i = o = s : o = o.next = s, n = n.next } while (n !== null); o === null ? i = o = t : o = o.next = t } else i = o = t; n = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: o, shared: r.shared, effects: r.effects }, e.updateQueue = n; return } e = n.lastBaseUpdate, e === null ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t } function bd(e, t, n, r) { var i = e.updateQueue; wi = !1; var o = i.firstBaseUpdate, s = i.lastBaseUpdate, a = i.shared.pending; if (a !== null) { i.shared.pending = null; var l = a, u = l.next; l.next = null, s === null ? o = u : s.next = u, s = l; var c = e.alternate; c !== null && (c = c.updateQueue, a = c.lastBaseUpdate, a !== s && (a === null ? c.firstBaseUpdate = u : a.next = u, c.lastBaseUpdate = l)) } if (o !== null) { var d = i.baseState; s = 0, c = u = l = null, a = o; do { var f = a.lane, p = a.eventTime; if ((r & f) === f) { c !== null && (c = c.next = { eventTime: p, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null }); e: { var m = e, v = a; switch (f = t, p = n, v.tag) { case 1: if (m = v.payload, typeof m == "function") { d = m.call(p, d, f); break e } d = m; break e; case 3: m.flags = m.flags & -65537 | 128; case 0: if (m = v.payload, f = typeof m == "function" ? m.call(p, d, f) : m, f == null) break e; d = rt({}, d, f); break e; case 2: wi = !0 } } a.callback !== null && a.lane !== 0 && (e.flags |= 64, f = i.effects, f === null ? i.effects = [a] : f.push(a)) } else p = { eventTime: p, lane: f, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, c === null ? (u = c = p, l = d) : c = c.next = p, s |= f; if (a = a.next, a === null) { if (a = i.shared.pending, a === null) break; f = a, a = f.next, f.next = null, i.lastBaseUpdate = f, i.shared.pending = null } } while (!0); if (c === null && (l = d), i.baseState = l, i.firstBaseUpdate = u, i.lastBaseUpdate = c, t = i.shared.interleaved, t !== null) { i = t; do s |= i.lane, i = i.next; while (i !== t) } else o === null && (i.shared.lanes = 0); Io |= s, e.lanes = s, e.memoizedState = d } } function ab(e, t, n) { if (e = t.effects, t.effects = null, e !== null) for (t = 0; t < e.length; t++) { var r = e[t], i = r.callback; if (i !== null) { if (r.callback = null, r = n, typeof i != "function") throw Error(ee(191, i)); i.call(r) } } } var Tu = {}, Mr = Xi(Tu), Fl = Xi(Tu), zl = Xi(Tu); function vo(e) { if (e === Tu) throw Error(ee(174)); return e } function wv(e, t) { switch (Ve(zl, t), Ve(Fl, e), Ve(Mr, Tu), e = t.nodeType, e) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : Bh(null, ""); break; default: e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = Bh(t, e) }Ke(Mr), Ve(Mr, t) } function na() { Ke(Mr), Ke(Fl), Ke(zl) } function UE(e) { vo(zl.current); var t = vo(Mr.current), n = Bh(t, e.type); t !== n && (Ve(Fl, e), Ve(Mr, n)) } function xv(e) { Fl.current === e && (Ke(Mr), Ke(Fl)) } var Ze = Xi(0); function wd(e) { for (var t = e; t !== null;) { if (t.tag === 13) { var n = t.memoizedState; if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return t } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) { if (t.flags & 128) return t } else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var xp = []; function Sv() { for (var e = 0; e < xp.length; e++)xp[e]._workInProgressVersionPrimary = null; xp.length = 0 } var zc = ai.ReactCurrentDispatcher, Sp = ai.ReactCurrentBatchConfig, jo = 0, nt = null, Mt = null, Nt = null, xd = !1, ml = !1, Vl = 0, V_ = 0; function Gt() { throw Error(ee(321)) } function Ev(e, t) { if (t === null) return !1; for (var n = 0; n < t.length && n < e.length; n++)if (!mr(e[n], t[n])) return !1; return !0 } function Tv(e, t, n, r, i, o) { if (jo = o, nt = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, zc.current = e === null || e.memoizedState === null ? W_ : G_, e = n(r, i), ml) { o = 0; do { if (ml = !1, Vl = 0, 25 <= o) throw Error(ee(301)); o += 1, Nt = Mt = null, t.updateQueue = null, zc.current = K_, e = n(r, i) } while (ml) } if (zc.current = Sd, t = Mt !== null && Mt.next !== null, jo = 0, Nt = Mt = nt = null, xd = !1, t) throw Error(ee(300)); return e } function Cv() { var e = Vl !== 0; return Vl = 0, e } function Er() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Nt === null ? nt.memoizedState = Nt = e : Nt = Nt.next = e, Nt } function Zn() { if (Mt === null) { var e = nt.alternate; e = e !== null ? e.memoizedState : null } else e = Mt.next; var t = Nt === null ? nt.memoizedState : Nt.next; if (t !== null) Nt = t, Mt = e; else { if (e === null) throw Error(ee(310)); Mt = e, e = { memoizedState: Mt.memoizedState, baseState: Mt.baseState, baseQueue: Mt.baseQueue, queue: Mt.queue, next: null }, Nt === null ? nt.memoizedState = Nt = e : Nt = Nt.next = e } return Nt } function Bl(e, t) { return typeof t == "function" ? t(e) : t } function Ep(e) { var t = Zn(), n = t.queue; if (n === null) throw Error(ee(311)); n.lastRenderedReducer = e; var r = Mt, i = r.baseQueue, o = n.pending; if (o !== null) { if (i !== null) { var s = i.next; i.next = o.next, o.next = s } r.baseQueue = i = o, n.pending = null } if (i !== null) { o = i.next, r = r.baseState; var a = s = null, l = null, u = o; do { var c = u.lane; if ((jo & c) === c) l !== null && (l = l.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), r = u.hasEagerState ? u.eagerState : e(r, u.action); else { var d = { lane: c, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }; l === null ? (a = l = d, s = r) : l = l.next = d, nt.lanes |= c, Io |= c } u = u.next } while (u !== null && u !== o); l === null ? s = r : l.next = a, mr(r, t.memoizedState) || (mn = !0), t.memoizedState = r, t.baseState = s, t.baseQueue = l, n.lastRenderedState = r } if (e = n.interleaved, e !== null) { i = e; do o = i.lane, nt.lanes |= o, Io |= o, i = i.next; while (i !== e) } else i === null && (n.lanes = 0); return [t.memoizedState, n.dispatch] } function Tp(e) { var t = Zn(), n = t.queue; if (n === null) throw Error(ee(311)); n.lastRenderedReducer = e; var r = n.dispatch, i = n.pending, o = t.memoizedState; if (i !== null) { n.pending = null; var s = i = i.next; do o = e(o, s.action), s = s.next; while (s !== i); mr(o, t.memoizedState) || (mn = !0), t.memoizedState = o, t.baseQueue === null && (t.baseState = o), n.lastRenderedState = o } return [o, r] } function HE() { } function WE(e, t) { var n = nt, r = Zn(), i = t(), o = !mr(r.memoizedState, i); if (o && (r.memoizedState = i, mn = !0), r = r.queue, Pv(qE.bind(null, n, r, e), [e]), r.getSnapshot !== t || o || Nt !== null && Nt.memoizedState.tag & 1) { if (n.flags |= 2048, Ul(9, KE.bind(null, n, r, i, t), void 0, null), Ot === null) throw Error(ee(349)); jo & 30 || GE(n, t, i) } return i } function GE(e, t, n) { e.flags |= 16384, e = { getSnapshot: t, value: n }, t = nt.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, nt.updateQueue = t, t.stores = [e]) : (n = t.stores, n === null ? t.stores = [e] : n.push(e)) } function KE(e, t, n, r) { t.value = n, t.getSnapshot = r, YE(t) && QE(e) } function qE(e, t, n) { return n(function () { YE(t) && QE(e) }) } function YE(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !mr(e, n) } catch { return !0 } } function QE(e) { var t = ei(e, 1); t !== null && hr(t, e, 1, -1) } function lb(e) { var t = Er(); return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Bl, lastRenderedState: e }, t.queue = e, e = e.dispatch = H_.bind(null, nt, e), [t.memoizedState, e] } function Ul(e, t, n, r) { return e = { tag: e, create: t, destroy: n, deps: r, next: null }, t = nt.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, nt.updateQueue = t, t.lastEffect = e.next = e) : (n = t.lastEffect, n === null ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e)), e } function XE() { return Zn().memoizedState } function Vc(e, t, n, r) { var i = Er(); nt.flags |= e, i.memoizedState = Ul(1 | t, n, void 0, r === void 0 ? null : r) } function wf(e, t, n, r) { var i = Zn(); r = r === void 0 ? null : r; var o = void 0; if (Mt !== null) { var s = Mt.memoizedState; if (o = s.destroy, r !== null && Ev(r, s.deps)) { i.memoizedState = Ul(t, n, o, r); return } } nt.flags |= e, i.memoizedState = Ul(1 | t, n, o, r) } function ub(e, t) { return Vc(8390656, 8, e, t) } function Pv(e, t) { return wf(2048, 8, e, t) } function JE(e, t) { return wf(4, 2, e, t) } function ZE(e, t) { return wf(4, 4, e, t) } function eT(e, t) { if (typeof t == "function") return e = e(), t(e), function () { t(null) }; if (t != null) return e = e(), t.current = e, function () { t.current = null } } function tT(e, t, n) { return n = n != null ? n.concat([e]) : null, wf(4, 4, eT.bind(null, t, e), n) } function $v() { } function nT(e, t) { var n = Zn(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && Ev(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e) } function rT(e, t) { var n = Zn(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && Ev(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e) } function iT(e, t, n) { return jo & 21 ? (mr(n, t) || (n = uE(), nt.lanes |= n, Io |= n, e.baseState = !0), t) : (e.baseState && (e.baseState = !1, mn = !0), e.memoizedState = n) } function B_(e, t) { var n = Ie; Ie = n !== 0 && 4 > n ? n : 4, e(!0); var r = Sp.transition; Sp.transition = {}; try { e(!1), t() } finally { Ie = n, Sp.transition = r } } function oT() { return Zn().memoizedState } function U_(e, t, n) { var r = Ui(e); if (n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, sT(e)) aT(t, n); else if (n = VE(e, t, n, r), n !== null) { var i = ln(); hr(n, e, r, i), lT(n, t, r) } } function H_(e, t, n) { var r = Ui(e), i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (sT(e)) aT(t, i); else { var o = e.alternate; if (e.lanes === 0 && (o === null || o.lanes === 0) && (o = t.lastRenderedReducer, o !== null)) try { var s = t.lastRenderedState, a = o(s, n); if (i.hasEagerState = !0, i.eagerState = a, mr(a, s)) { var l = t.interleaved; l === null ? (i.next = i, yv(t)) : (i.next = l.next, l.next = i), t.interleaved = i; return } } catch { } finally { } n = VE(e, t, i, r), n !== null && (i = ln(), hr(n, e, r, i), lT(n, t, r)) } } function sT(e) { var t = e.alternate; return e === nt || t !== null && t === nt } function aT(e, t) { ml = xd = !0; var n = e.pending; n === null ? t.next = t : (t.next = n.next, n.next = t), e.pending = t } function lT(e, t, n) { if (n & 4194240) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, iv(e, n) } } var Sd = { readContext: Jn, useCallback: Gt, useContext: Gt, useEffect: Gt, useImperativeHandle: Gt, useInsertionEffect: Gt, useLayoutEffect: Gt, useMemo: Gt, useReducer: Gt, useRef: Gt, useState: Gt, useDebugValue: Gt, useDeferredValue: Gt, useTransition: Gt, useMutableSource: Gt, useSyncExternalStore: Gt, useId: Gt, unstable_isNewReconciler: !1 }, W_ = { readContext: Jn, useCallback: function (e, t) { return Er().memoizedState = [e, t === void 0 ? null : t], e }, useContext: Jn, useEffect: ub, useImperativeHandle: function (e, t, n) { return n = n != null ? n.concat([e]) : null, Vc(4194308, 4, eT.bind(null, t, e), n) }, useLayoutEffect: function (e, t) { return Vc(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return Vc(4, 2, e, t) }, useMemo: function (e, t) { var n = Er(); return t = t === void 0 ? null : t, e = e(), n.memoizedState = [e, t], e }, useReducer: function (e, t, n) { var r = Er(); return t = n !== void 0 ? n(t) : t, r.memoizedState = r.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, r.queue = e, e = e.dispatch = U_.bind(null, nt, e), [r.memoizedState, e] }, useRef: function (e) { var t = Er(); return e = { current: e }, t.memoizedState = e }, useState: lb, useDebugValue: $v, useDeferredValue: function (e) { return Er().memoizedState = e }, useTransition: function () { var e = lb(!1), t = e[0]; return e = B_.bind(null, e[1]), Er().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, n) { var r = nt, i = Er(); if (Xe) { if (n === void 0) throw Error(ee(407)); n = n() } else { if (n = t(), Ot === null) throw Error(ee(349)); jo & 30 || GE(r, t, n) } i.memoizedState = n; var o = { value: n, getSnapshot: t }; return i.queue = o, ub(qE.bind(null, r, o, e), [e]), r.flags |= 2048, Ul(9, KE.bind(null, r, o, n, t), void 0, null), n }, useId: function () { var e = Er(), t = Ot.identifierPrefix; if (Xe) { var n = Gr, r = Wr; n = (r & ~(1 << 32 - pr(r) - 1)).toString(32) + n, t = ":" + t + "R" + n, n = Vl++, 0 < n && (t += "H" + n.toString(32)), t += ":" } else n = V_++, t = ":" + t + "r" + n.toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, G_ = { readContext: Jn, useCallback: nT, useContext: Jn, useEffect: Pv, useImperativeHandle: tT, useInsertionEffect: JE, useLayoutEffect: ZE, useMemo: rT, useReducer: Ep, useRef: XE, useState: function () { return Ep(Bl) }, useDebugValue: $v, useDeferredValue: function (e) { var t = Zn(); return iT(t, Mt.memoizedState, e) }, useTransition: function () { var e = Ep(Bl)[0], t = Zn().memoizedState; return [e, t] }, useMutableSource: HE, useSyncExternalStore: WE, useId: oT, unstable_isNewReconciler: !1 }, K_ = { readContext: Jn, useCallback: nT, useContext: Jn, useEffect: Pv, useImperativeHandle: tT, useInsertionEffect: JE, useLayoutEffect: ZE, useMemo: rT, useReducer: Tp, useRef: XE, useState: function () { return Tp(Bl) }, useDebugValue: $v, useDeferredValue: function (e) { var t = Zn(); return Mt === null ? t.memoizedState = e : iT(t, Mt.memoizedState, e) }, useTransition: function () { var e = Tp(Bl)[0], t = Zn().memoizedState; return [e, t] }, useMutableSource: HE, useSyncExternalStore: WE, useId: oT, unstable_isNewReconciler: !1 }; function lr(e, t) { if (e && e.defaultProps) { t = rt({}, t), e = e.defaultProps; for (var n in e) t[n] === void 0 && (t[n] = e[n]); return t } return t } function um(e, t, n, r) { t = e.memoizedState, n = n(r, t), n = n == null ? t : rt({}, t, n), e.memoizedState = n, e.lanes === 0 && (e.updateQueue.baseState = n) } var xf = { isMounted: function (e) { return (e = e._reactInternals) ? qo(e) === e : !1 }, enqueueSetState: function (e, t, n) { e = e._reactInternals; var r = ln(), i = Ui(e), o = qr(r, i); o.payload = t, n != null && (o.callback = n), t = Vi(e, o, i), t !== null && (hr(t, e, i, r), Fc(t, e, i)) }, enqueueReplaceState: function (e, t, n) { e = e._reactInternals; var r = ln(), i = Ui(e), o = qr(r, i); o.tag = 1, o.payload = t, n != null && (o.callback = n), t = Vi(e, o, i), t !== null && (hr(t, e, i, r), Fc(t, e, i)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var n = ln(), r = Ui(e), i = qr(n, r); i.tag = 2, t != null && (i.callback = t), t = Vi(e, i, r), t !== null && (hr(t, e, r, n), Fc(t, e, r)) } }; function cb(e, t, n, r, i, o, s) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(r, o, s) : t.prototype && t.prototype.isPureReactComponent ? !Ol(n, r) || !Ol(i, o) : !0 } function uT(e, t, n) { var r = !1, i = Gi, o = t.contextType; return typeof o == "object" && o !== null ? o = Jn(o) : (i = vn(t) ? No : Xt.current, r = t.contextTypes, o = (r = r != null) ? Zs(e, i) : Gi), t = new t(n, o), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = xf, e.stateNode = t, t._reactInternals = e, r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = o), t } function db(e, t, n, r) { e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, r), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && xf.enqueueReplaceState(t, t.state, null) } function cm(e, t, n, r) { var i = e.stateNode; i.props = n, i.state = e.memoizedState, i.refs = {}, bv(e); var o = t.contextType; typeof o == "object" && o !== null ? i.context = Jn(o) : (o = vn(t) ? No : Xt.current, i.context = Zs(e, o)), i.state = e.memoizedState, o = t.getDerivedStateFromProps, typeof o == "function" && (um(e, t, o, n), i.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (t = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), t !== i.state && xf.enqueueReplaceState(i, i.state, null), bd(e, n, i, r), i.state = e.memoizedState), typeof i.componentDidMount == "function" && (e.flags |= 4194308) } function ra(e, t) {
  try { var n = "", r = t; do n += xk(r), r = r.return; while (r); var i = n } catch (o) {
    i = `
Error generating stack: `+ o.message + `
`+ o.stack
  } return { value: e, source: t, stack: i, digest: null }
} function Cp(e, t, n) { return { value: e, source: null, stack: n ?? null, digest: t ?? null } } function dm(e, t) { try { console.error(t.value) } catch (n) { setTimeout(function () { throw n }) } } var q_ = typeof WeakMap == "function" ? WeakMap : Map; function cT(e, t, n) { n = qr(-1, n), n.tag = 3, n.payload = { element: null }; var r = t.value; return n.callback = function () { Td || (Td = !0, xm = r), dm(e, t) }, n } function dT(e, t, n) { n = qr(-1, n), n.tag = 3; var r = e.type.getDerivedStateFromError; if (typeof r == "function") { var i = t.value; n.payload = function () { return r(i) }, n.callback = function () { dm(e, t) } } var o = e.stateNode; return o !== null && typeof o.componentDidCatch == "function" && (n.callback = function () { dm(e, t), typeof r != "function" && (Bi === null ? Bi = new Set([this]) : Bi.add(this)); var s = t.stack; this.componentDidCatch(t.value, { componentStack: s !== null ? s : "" }) }), n } function fb(e, t, n) { var r = e.pingCache; if (r === null) { r = e.pingCache = new q_; var i = new Set; r.set(t, i) } else i = r.get(t), i === void 0 && (i = new Set, r.set(t, i)); i.has(n) || (i.add(n), e = lR.bind(null, e, t, n), t.then(e, e)) } function pb(e) { do { var t; if ((t = e.tag === 13) && (t = e.memoizedState, t = t !== null ? t.dehydrated !== null : !0), t) return e; e = e.return } while (e !== null); return null } function hb(e, t, n, r, i) { return e.mode & 1 ? (e.flags |= 65536, e.lanes = i, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (t = qr(-1, 1), t.tag = 2, Vi(n, t, 1))), n.lanes |= 1), e) } var Y_ = ai.ReactCurrentOwner, mn = !1; function an(e, t, n, r) { t.child = e === null ? zE(t, null, n, r) : ta(t, e.child, n, r) } function mb(e, t, n, r, i) { n = n.render; var o = t.ref; return Vs(t, i), r = Tv(e, t, n, r, o, i), n = Cv(), e !== null && !mn ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, ti(e, t, i)) : (Xe && n && fv(t), t.flags |= 1, an(e, t, r, i), t.child) } function gb(e, t, n, r, i) { if (e === null) { var o = n.type; return typeof o == "function" && !Ov(o) && o.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (t.tag = 15, t.type = o, fT(e, t, o, r, i)) : (e = Wc(n.type, null, r, t, t.mode, i), e.ref = t.ref, e.return = t, t.child = e) } if (o = e.child, !(e.lanes & i)) { var s = o.memoizedProps; if (n = n.compare, n = n !== null ? n : Ol, n(s, r) && e.ref === t.ref) return ti(e, t, i) } return t.flags |= 1, e = Hi(o, r), e.ref = t.ref, e.return = t, t.child = e } function fT(e, t, n, r, i) { if (e !== null) { var o = e.memoizedProps; if (Ol(o, r) && e.ref === t.ref) if (mn = !1, t.pendingProps = r = o, (e.lanes & i) !== 0) e.flags & 131072 && (mn = !0); else return t.lanes = e.lanes, ti(e, t, i) } return fm(e, t, n, r, i) } function pT(e, t, n) { var r = t.pendingProps, i = r.children, o = e !== null ? e.memoizedState : null; if (r.mode === "hidden") if (!(t.mode & 1)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Ve(As, En), En |= n; else { if (!(n & 1073741824)) return e = o !== null ? o.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, Ve(As, En), En |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = o !== null ? o.baseLanes : n, Ve(As, En), En |= r } else o !== null ? (r = o.baseLanes | n, t.memoizedState = null) : r = n, Ve(As, En), En |= r; return an(e, t, i, n), t.child } function hT(e, t) { var n = t.ref; (e === null && n !== null || e !== null && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152) } function fm(e, t, n, r, i) { var o = vn(n) ? No : Xt.current; return o = Zs(t, o), Vs(t, i), n = Tv(e, t, n, r, o, i), r = Cv(), e !== null && !mn ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, ti(e, t, i)) : (Xe && r && fv(t), t.flags |= 1, an(e, t, n, i), t.child) } function vb(e, t, n, r, i) { if (vn(n)) { var o = !0; hd(t) } else o = !1; if (Vs(t, i), t.stateNode === null) Bc(e, t), uT(t, n, r), cm(t, n, r, i), r = !0; else if (e === null) { var s = t.stateNode, a = t.memoizedProps; s.props = a; var l = s.context, u = n.contextType; typeof u == "object" && u !== null ? u = Jn(u) : (u = vn(n) ? No : Xt.current, u = Zs(t, u)); var c = n.getDerivedStateFromProps, d = typeof c == "function" || typeof s.getSnapshotBeforeUpdate == "function"; d || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== r || l !== u) && db(t, s, r, u), wi = !1; var f = t.memoizedState; s.state = f, bd(t, r, s, i), l = t.memoizedState, a !== r || f !== l || gn.current || wi ? (typeof c == "function" && (um(t, n, c, r), l = t.memoizedState), (a = wi || cb(t, n, a, r, f, l, u)) ? (d || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount()), typeof s.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof s.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = l), s.props = r, s.state = l, s.context = u, r = a) : (typeof s.componentDidMount == "function" && (t.flags |= 4194308), r = !1) } else { s = t.stateNode, BE(e, t), a = t.memoizedProps, u = t.type === t.elementType ? a : lr(t.type, a), s.props = u, d = t.pendingProps, f = s.context, l = n.contextType, typeof l == "object" && l !== null ? l = Jn(l) : (l = vn(n) ? No : Xt.current, l = Zs(t, l)); var p = n.getDerivedStateFromProps; (c = typeof p == "function" || typeof s.getSnapshotBeforeUpdate == "function") || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== d || f !== l) && db(t, s, r, l), wi = !1, f = t.memoizedState, s.state = f, bd(t, r, s, i); var m = t.memoizedState; a !== d || f !== m || gn.current || wi ? (typeof p == "function" && (um(t, n, p, r), m = t.memoizedState), (u = wi || cb(t, n, u, r, f, m, l) || !1) ? (c || typeof s.UNSAFE_componentWillUpdate != "function" && typeof s.componentWillUpdate != "function" || (typeof s.componentWillUpdate == "function" && s.componentWillUpdate(r, m, l), typeof s.UNSAFE_componentWillUpdate == "function" && s.UNSAFE_componentWillUpdate(r, m, l)), typeof s.componentDidUpdate == "function" && (t.flags |= 4), typeof s.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof s.componentDidUpdate != "function" || a === e.memoizedProps && f === e.memoizedState || (t.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && f === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = m), s.props = r, s.state = m, s.context = l, r = u) : (typeof s.componentDidUpdate != "function" || a === e.memoizedProps && f === e.memoizedState || (t.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && f === e.memoizedState || (t.flags |= 1024), r = !1) } return pm(e, t, n, r, o, i) } function pm(e, t, n, r, i, o) { hT(e, t); var s = (t.flags & 128) !== 0; if (!r && !s) return i && nb(t, n, !1), ti(e, t, o); r = t.stateNode, Y_.current = t; var a = s && typeof n.getDerivedStateFromError != "function" ? null : r.render(); return t.flags |= 1, e !== null && s ? (t.child = ta(t, e.child, null, o), t.child = ta(t, null, a, o)) : an(e, t, a, o), t.memoizedState = r.state, i && nb(t, n, !0), t.child } function mT(e) { var t = e.stateNode; t.pendingContext ? tb(e, t.pendingContext, t.pendingContext !== t.context) : t.context && tb(e, t.context, !1), wv(e, t.containerInfo) } function yb(e, t, n, r, i) { return ea(), hv(i), t.flags |= 256, an(e, t, n, r), t.child } var hm = { dehydrated: null, treeContext: null, retryLane: 0 }; function mm(e) { return { baseLanes: e, cachePool: null, transitions: null } } function gT(e, t, n) { var r = t.pendingProps, i = Ze.current, o = !1, s = (t.flags & 128) !== 0, a; if ((a = s) || (a = e !== null && e.memoizedState === null ? !1 : (i & 2) !== 0), a ? (o = !0, t.flags &= -129) : (e === null || e.memoizedState !== null) && (i |= 1), Ve(Ze, i & 1), e === null) return am(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (s = r.children, e = r.fallback, o ? (r = t.mode, o = t.child, s = { mode: "hidden", children: s }, !(r & 1) && o !== null ? (o.childLanes = 0, o.pendingProps = s) : o = Tf(s, r, 0, null), e = Mo(e, r, n, null), o.return = t, e.return = t, o.sibling = e, t.child = o, t.child.memoizedState = mm(n), t.memoizedState = hm, e) : Av(t, s)); if (i = e.memoizedState, i !== null && (a = i.dehydrated, a !== null)) return Q_(e, t, s, r, a, i, n); if (o) { o = r.fallback, s = t.mode, i = e.child, a = i.sibling; var l = { mode: "hidden", children: r.children }; return !(s & 1) && t.child !== i ? (r = t.child, r.childLanes = 0, r.pendingProps = l, t.deletions = null) : (r = Hi(i, l), r.subtreeFlags = i.subtreeFlags & 14680064), a !== null ? o = Hi(a, o) : (o = Mo(o, s, n, null), o.flags |= 2), o.return = t, r.return = t, r.sibling = o, t.child = r, r = o, o = t.child, s = e.child.memoizedState, s = s === null ? mm(n) : { baseLanes: s.baseLanes | n, cachePool: null, transitions: s.transitions }, o.memoizedState = s, o.childLanes = e.childLanes & ~n, t.memoizedState = hm, r } return o = e.child, e = o.sibling, r = Hi(o, { mode: "visible", children: r.children }), !(t.mode & 1) && (r.lanes = n), r.return = t, r.sibling = null, e !== null && (n = t.deletions, n === null ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = r, t.memoizedState = null, r } function Av(e, t) { return t = Tf({ mode: "visible", children: t }, e.mode, 0, null), t.return = e, e.child = t } function tc(e, t, n, r) { return r !== null && hv(r), ta(t, e.child, null, n), e = Av(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e } function Q_(e, t, n, r, i, o, s) { if (n) return t.flags & 256 ? (t.flags &= -257, r = Cp(Error(ee(422))), tc(e, t, s, r)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (o = r.fallback, i = t.mode, r = Tf({ mode: "visible", children: r.children }, i, 0, null), o = Mo(o, i, s, null), o.flags |= 2, r.return = t, o.return = t, r.sibling = o, t.child = r, t.mode & 1 && ta(t, e.child, null, s), t.child.memoizedState = mm(s), t.memoizedState = hm, o); if (!(t.mode & 1)) return tc(e, t, s, null); if (i.data === "$!") { if (r = i.nextSibling && i.nextSibling.dataset, r) var a = r.dgst; return r = a, o = Error(ee(419)), r = Cp(o, r, void 0), tc(e, t, s, r) } if (a = (s & e.childLanes) !== 0, mn || a) { if (r = Ot, r !== null) { switch (s & -s) { case 4: i = 2; break; case 16: i = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: i = 32; break; case 536870912: i = 268435456; break; default: i = 0 }i = i & (r.suspendedLanes | s) ? 0 : i, i !== 0 && i !== o.retryLane && (o.retryLane = i, ei(e, i), hr(r, e, i, -1)) } return Nv(), r = Cp(Error(ee(421))), tc(e, t, s, r) } return i.data === "$?" ? (t.flags |= 128, t.child = e.child, t = uR.bind(null, e), i._reactRetry = t, null) : (e = o.treeContext, Pn = zi(i.nextSibling), An = t, Xe = !0, dr = null, e !== null && (Hn[Wn++] = Wr, Hn[Wn++] = Gr, Hn[Wn++] = Oo, Wr = e.id, Gr = e.overflow, Oo = t), t = Av(t, r.children), t.flags |= 4096, t) } function bb(e, t, n) { e.lanes |= t; var r = e.alternate; r !== null && (r.lanes |= t), lm(e.return, t, n) } function Pp(e, t, n, r, i) { var o = e.memoizedState; o === null ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: i } : (o.isBackwards = t, o.rendering = null, o.renderingStartTime = 0, o.last = r, o.tail = n, o.tailMode = i) } function vT(e, t, n) { var r = t.pendingProps, i = r.revealOrder, o = r.tail; if (an(e, t, r.children, n), r = Ze.current, r & 2) r = r & 1 | 2, t.flags |= 128; else { if (e !== null && e.flags & 128) e: for (e = t.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && bb(e, n, t); else if (e.tag === 19) bb(e, n, t); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; e.sibling === null;) { if (e.return === null || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } r &= 1 } if (Ve(Ze, r), !(t.mode & 1)) t.memoizedState = null; else switch (i) { case "forwards": for (n = t.child, i = null; n !== null;)e = n.alternate, e !== null && wd(e) === null && (i = n), n = n.sibling; n = i, n === null ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), Pp(t, !1, i, n, o); break; case "backwards": for (n = null, i = t.child, t.child = null; i !== null;) { if (e = i.alternate, e !== null && wd(e) === null) { t.child = i; break } e = i.sibling, i.sibling = n, n = i, i = e } Pp(t, !0, n, null, o); break; case "together": Pp(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function Bc(e, t) { !(t.mode & 1) && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2) } function ti(e, t, n) { if (e !== null && (t.dependencies = e.dependencies), Io |= t.lanes, !(n & t.childLanes)) return null; if (e !== null && t.child !== e.child) throw Error(ee(153)); if (t.child !== null) { for (e = t.child, n = Hi(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null;)e = e.sibling, n = n.sibling = Hi(e, e.pendingProps), n.return = t; n.sibling = null } return t.child } function X_(e, t, n) { switch (t.tag) { case 3: mT(t), ea(); break; case 5: UE(t); break; case 1: vn(t.type) && hd(t); break; case 4: wv(t, t.stateNode.containerInfo); break; case 10: var r = t.type._context, i = t.memoizedProps.value; Ve(vd, r._currentValue), r._currentValue = i; break; case 13: if (r = t.memoizedState, r !== null) return r.dehydrated !== null ? (Ve(Ze, Ze.current & 1), t.flags |= 128, null) : n & t.child.childLanes ? gT(e, t, n) : (Ve(Ze, Ze.current & 1), e = ti(e, t, n), e !== null ? e.sibling : null); Ve(Ze, Ze.current & 1); break; case 19: if (r = (n & t.childLanes) !== 0, e.flags & 128) { if (r) return vT(e, t, n); t.flags |= 128 } if (i = t.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), Ve(Ze, Ze.current), r) break; return null; case 22: case 23: return t.lanes = 0, pT(e, t, n) }return ti(e, t, n) } var yT, gm, bT, wT; yT = function (e, t) { for (var n = t.child; n !== null;) { if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode); else if (n.tag !== 4 && n.child !== null) { n.child.return = n, n = n.child; continue } if (n === t) break; for (; n.sibling === null;) { if (n.return === null || n.return === t) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }; gm = function () { }; bT = function (e, t, n, r) { var i = e.memoizedProps; if (i !== r) { e = t.stateNode, vo(Mr.current); var o = null; switch (n) { case "input": i = Dh(e, i), r = Dh(e, r), o = []; break; case "select": i = rt({}, i, { value: void 0 }), r = rt({}, r, { value: void 0 }), o = []; break; case "textarea": i = Vh(e, i), r = Vh(e, r), o = []; break; default: typeof i.onClick != "function" && typeof r.onClick == "function" && (e.onclick = fd) }Uh(n, r); var s; n = null; for (u in i) if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && i[u] != null) if (u === "style") { var a = i[u]; for (s in a) a.hasOwnProperty(s) && (n || (n = {}), n[s] = "") } else u !== "dangerouslySetInnerHTML" && u !== "children" && u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && u !== "autoFocus" && (Al.hasOwnProperty(u) ? o || (o = []) : (o = o || []).push(u, null)); for (u in r) { var l = r[u]; if (a = i != null ? i[u] : void 0, r.hasOwnProperty(u) && l !== a && (l != null || a != null)) if (u === "style") if (a) { for (s in a) !a.hasOwnProperty(s) || l && l.hasOwnProperty(s) || (n || (n = {}), n[s] = ""); for (s in l) l.hasOwnProperty(s) && a[s] !== l[s] && (n || (n = {}), n[s] = l[s]) } else n || (o || (o = []), o.push(u, n)), n = l; else u === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (o = o || []).push(u, l)) : u === "children" ? typeof l != "string" && typeof l != "number" || (o = o || []).push(u, "" + l) : u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && (Al.hasOwnProperty(u) ? (l != null && u === "onScroll" && We("scroll", e), o || a === l || (o = [])) : (o = o || []).push(u, l)) } n && (o = o || []).push("style", n); var u = o; (t.updateQueue = u) && (t.flags |= 4) } }; wT = function (e, t, n, r) { n !== r && (t.flags |= 4) }; function _a(e, t) { if (!Xe) switch (e.tailMode) { case "hidden": t = e.tail; for (var n = null; t !== null;)t.alternate !== null && (n = t), t = t.sibling; n === null ? e.tail = null : n.sibling = null; break; case "collapsed": n = e.tail; for (var r = null; n !== null;)n.alternate !== null && (r = n), n = n.sibling; r === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : r.sibling = null } } function Kt(e) { var t = e.alternate !== null && e.alternate.child === e.child, n = 0, r = 0; if (t) for (var i = e.child; i !== null;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags & 14680064, r |= i.flags & 14680064, i.return = e, i = i.sibling; else for (i = e.child; i !== null;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling; return e.subtreeFlags |= r, e.childLanes = n, t } function J_(e, t, n) { var r = t.pendingProps; switch (pv(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Kt(t), null; case 1: return vn(t.type) && pd(), Kt(t), null; case 3: return r = t.stateNode, na(), Ke(gn), Ke(Xt), Sv(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (e === null || e.child === null) && (Zu(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, dr !== null && (Tm(dr), dr = null))), gm(e, t), Kt(t), null; case 5: xv(t); var i = vo(zl.current); if (n = t.type, e !== null && t.stateNode != null) bT(e, t, n, r, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!r) { if (t.stateNode === null) throw Error(ee(166)); return Kt(t), null } if (e = vo(Mr.current), Zu(t)) { r = t.stateNode, n = t.type; var o = t.memoizedProps; switch (r[Tr] = t, r[Dl] = o, e = (t.mode & 1) !== 0, n) { case "dialog": We("cancel", r), We("close", r); break; case "iframe": case "object": case "embed": We("load", r); break; case "video": case "audio": for (i = 0; i < Za.length; i++)We(Za[i], r); break; case "source": We("error", r); break; case "img": case "image": case "link": We("error", r), We("load", r); break; case "details": We("toggle", r); break; case "input": A0(r, o), We("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!o.multiple }, We("invalid", r); break; case "textarea": k0(r, o), We("invalid", r) }Uh(n, o), i = null; for (var s in o) if (o.hasOwnProperty(s)) { var a = o[s]; s === "children" ? typeof a == "string" ? r.textContent !== a && (o.suppressHydrationWarning !== !0 && Ju(r.textContent, a, e), i = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (o.suppressHydrationWarning !== !0 && Ju(r.textContent, a, e), i = ["children", "" + a]) : Al.hasOwnProperty(s) && a != null && s === "onScroll" && We("scroll", r) } switch (n) { case "input": Hu(r), M0(r, o, !0); break; case "textarea": Hu(r), _0(r); break; case "select": case "option": break; default: typeof o.onClick == "function" && (r.onclick = fd) }r = i, t.updateQueue = r, r !== null && (t.flags |= 4) } else { s = i.nodeType === 9 ? i : i.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = qS(n)), e === "http://www.w3.org/1999/xhtml" ? n === "script" ? (e = s.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof r.is == "string" ? e = s.createElement(n, { is: r.is }) : (e = s.createElement(n), n === "select" && (s = e, r.multiple ? s.multiple = !0 : r.size && (s.size = r.size))) : e = s.createElementNS(e, n), e[Tr] = t, e[Dl] = r, yT(e, t, !1, !1), t.stateNode = e; e: { switch (s = Hh(n, r), n) { case "dialog": We("cancel", e), We("close", e), i = r; break; case "iframe": case "object": case "embed": We("load", e), i = r; break; case "video": case "audio": for (i = 0; i < Za.length; i++)We(Za[i], e); i = r; break; case "source": We("error", e), i = r; break; case "img": case "image": case "link": We("error", e), We("load", e), i = r; break; case "details": We("toggle", e), i = r; break; case "input": A0(e, r), i = Dh(e, r), We("invalid", e); break; case "option": i = r; break; case "select": e._wrapperState = { wasMultiple: !!r.multiple }, i = rt({}, r, { value: void 0 }), We("invalid", e); break; case "textarea": k0(e, r), i = Vh(e, r), We("invalid", e); break; default: i = r }Uh(n, i), a = i; for (o in a) if (a.hasOwnProperty(o)) { var l = a[o]; o === "style" ? XS(e, l) : o === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && YS(e, l)) : o === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && Ml(e, l) : typeof l == "number" && Ml(e, "" + l) : o !== "suppressContentEditableWarning" && o !== "suppressHydrationWarning" && o !== "autoFocus" && (Al.hasOwnProperty(o) ? l != null && o === "onScroll" && We("scroll", e) : l != null && Jg(e, o, l, s)) } switch (n) { case "input": Hu(e), M0(e, r, !1); break; case "textarea": Hu(e), _0(e); break; case "option": r.value != null && e.setAttribute("value", "" + Wi(r.value)); break; case "select": e.multiple = !!r.multiple, o = r.value, o != null ? Is(e, !!r.multiple, o, !1) : r.defaultValue != null && Is(e, !!r.multiple, r.defaultValue, !0); break; default: typeof i.onClick == "function" && (e.onclick = fd) }switch (n) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (t.flags |= 4) } t.ref !== null && (t.flags |= 512, t.flags |= 2097152) } return Kt(t), null; case 6: if (e && t.stateNode != null) wT(e, t, e.memoizedProps, r); else { if (typeof r != "string" && t.stateNode === null) throw Error(ee(166)); if (n = vo(zl.current), vo(Mr.current), Zu(t)) { if (r = t.stateNode, n = t.memoizedProps, r[Tr] = t, (o = r.nodeValue !== n) && (e = An, e !== null)) switch (e.tag) { case 3: Ju(r.nodeValue, n, (e.mode & 1) !== 0); break; case 5: e.memoizedProps.suppressHydrationWarning !== !0 && Ju(r.nodeValue, n, (e.mode & 1) !== 0) }o && (t.flags |= 4) } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[Tr] = t, t.stateNode = r } return Kt(t), null; case 13: if (Ke(Ze), r = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (Xe && Pn !== null && t.mode & 1 && !(t.flags & 128)) DE(), ea(), t.flags |= 98560, o = !1; else if (o = Zu(t), r !== null && r.dehydrated !== null) { if (e === null) { if (!o) throw Error(ee(318)); if (o = t.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(ee(317)); o[Tr] = t } else ea(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4; Kt(t), o = !1 } else dr !== null && (Tm(dr), dr = null), o = !0; if (!o) return t.flags & 65536 ? t : null } return t.flags & 128 ? (t.lanes = n, t) : (r = r !== null, r !== (e !== null && e.memoizedState !== null) && r && (t.child.flags |= 8192, t.mode & 1 && (e === null || Ze.current & 1 ? kt === 0 && (kt = 3) : Nv())), t.updateQueue !== null && (t.flags |= 4), Kt(t), null); case 4: return na(), gm(e, t), e === null && jl(t.stateNode.containerInfo), Kt(t), null; case 10: return vv(t.type._context), Kt(t), null; case 17: return vn(t.type) && pd(), Kt(t), null; case 19: if (Ke(Ze), o = t.memoizedState, o === null) return Kt(t), null; if (r = (t.flags & 128) !== 0, s = o.rendering, s === null) if (r) _a(o, !1); else { if (kt !== 0 || e !== null && e.flags & 128) for (e = t.child; e !== null;) { if (s = wd(e), s !== null) { for (t.flags |= 128, _a(o, !1), r = s.updateQueue, r !== null && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; n !== null;)o = n, e = r, o.flags &= 14680066, s = o.alternate, s === null ? (o.childLanes = 0, o.lanes = e, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = s.childLanes, o.lanes = s.lanes, o.child = s.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = s.memoizedProps, o.memoizedState = s.memoizedState, o.updateQueue = s.updateQueue, o.type = s.type, e = s.dependencies, o.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), n = n.sibling; return Ve(Ze, Ze.current & 1 | 2), t.child } e = e.sibling } o.tail !== null && pt() > ia && (t.flags |= 128, r = !0, _a(o, !1), t.lanes = 4194304) } else { if (!r) if (e = wd(s), e !== null) { if (t.flags |= 128, r = !0, n = e.updateQueue, n !== null && (t.updateQueue = n, t.flags |= 4), _a(o, !0), o.tail === null && o.tailMode === "hidden" && !s.alternate && !Xe) return Kt(t), null } else 2 * pt() - o.renderingStartTime > ia && n !== 1073741824 && (t.flags |= 128, r = !0, _a(o, !1), t.lanes = 4194304); o.isBackwards ? (s.sibling = t.child, t.child = s) : (n = o.last, n !== null ? n.sibling = s : t.child = s, o.last = s) } return o.tail !== null ? (t = o.tail, o.rendering = t, o.tail = t.sibling, o.renderingStartTime = pt(), t.sibling = null, n = Ze.current, Ve(Ze, r ? n & 1 | 2 : n & 1), t) : (Kt(t), null); case 22: case 23: return Lv(), r = t.memoizedState !== null, e !== null && e.memoizedState !== null !== r && (t.flags |= 8192), r && t.mode & 1 ? En & 1073741824 && (Kt(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : Kt(t), null; case 24: return null; case 25: return null }throw Error(ee(156, t.tag)) } function Z_(e, t) { switch (pv(t), t.tag) { case 1: return vn(t.type) && pd(), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 3: return na(), Ke(gn), Ke(Xt), Sv(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null; case 5: return xv(t), null; case 13: if (Ke(Ze), e = t.memoizedState, e !== null && e.dehydrated !== null) { if (t.alternate === null) throw Error(ee(340)); ea() } return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 19: return Ke(Ze), null; case 4: return na(), null; case 10: return vv(t.type._context), null; case 22: case 23: return Lv(), null; case 24: return null; default: return null } } var nc = !1, Yt = !1, eR = typeof WeakSet == "function" ? WeakSet : Set, de = null; function $s(e, t) { var n = e.ref; if (n !== null) if (typeof n == "function") try { n(null) } catch (r) { at(e, t, r) } else n.current = null } function vm(e, t, n) { try { n() } catch (r) { at(e, t, r) } } var wb = !1; function tR(e, t) { if (em = ud, e = CE(), dv(e)) { if ("selectionStart" in e) var n = { start: e.selectionStart, end: e.selectionEnd }; else e: { n = (n = e.ownerDocument) && n.defaultView || window; var r = n.getSelection && n.getSelection(); if (r && r.rangeCount !== 0) { n = r.anchorNode; var i = r.anchorOffset, o = r.focusNode; r = r.focusOffset; try { n.nodeType, o.nodeType } catch { n = null; break e } var s = 0, a = -1, l = -1, u = 0, c = 0, d = e, f = null; t: for (; ;) { for (var p; d !== n || i !== 0 && d.nodeType !== 3 || (a = s + i), d !== o || r !== 0 && d.nodeType !== 3 || (l = s + r), d.nodeType === 3 && (s += d.nodeValue.length), (p = d.firstChild) !== null;)f = d, d = p; for (; ;) { if (d === e) break t; if (f === n && ++u === i && (a = s), f === o && ++c === r && (l = s), (p = d.nextSibling) !== null) break; d = f, f = d.parentNode } d = p } n = a === -1 || l === -1 ? null : { start: a, end: l } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (tm = { focusedElem: e, selectionRange: n }, ud = !1, de = t; de !== null;)if (t = de, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, de = e; else for (; de !== null;) { t = de; try { var m = t.alternate; if (t.flags & 1024) switch (t.tag) { case 0: case 11: case 15: break; case 1: if (m !== null) { var v = m.memoizedProps, x = m.memoizedState, g = t.stateNode, h = g.getSnapshotBeforeUpdate(t.elementType === t.type ? v : lr(t.type, v), x); g.__reactInternalSnapshotBeforeUpdate = h } break; case 3: var y = t.stateNode.containerInfo; y.nodeType === 1 ? y.textContent = "" : y.nodeType === 9 && y.documentElement && y.removeChild(y.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(ee(163)) } } catch (E) { at(t, t.return, E) } if (e = t.sibling, e !== null) { e.return = t.return, de = e; break } de = t.return } return m = wb, wb = !1, m } function gl(e, t, n) { var r = t.updateQueue; if (r = r !== null ? r.lastEffect : null, r !== null) { var i = r = r.next; do { if ((i.tag & e) === e) { var o = i.destroy; i.destroy = void 0, o !== void 0 && vm(t, n, o) } i = i.next } while (i !== r) } } function Sf(e, t) { if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) { var n = t = t.next; do { if ((n.tag & e) === e) { var r = n.create; n.destroy = r() } n = n.next } while (n !== t) } } function ym(e) { var t = e.ref; if (t !== null) { var n = e.stateNode; switch (e.tag) { case 5: e = n; break; default: e = n }typeof t == "function" ? t(e) : t.current = e } } function xT(e) { var t = e.alternate; t !== null && (e.alternate = null, xT(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[Tr], delete t[Dl], delete t[im], delete t[I_], delete t[D_])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function ST(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function xb(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || ST(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (e.flags & 2 || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(e.flags & 2)) return e.stateNode } } function bm(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode, t.insertBefore(e, n)) : (t = n, t.appendChild(e)), n = n._reactRootContainer, n != null || t.onclick !== null || (t.onclick = fd)); else if (r !== 4 && (e = e.child, e !== null)) for (bm(e, t, n), e = e.sibling; e !== null;)bm(e, t, n), e = e.sibling } function wm(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e); else if (r !== 4 && (e = e.child, e !== null)) for (wm(e, t, n), e = e.sibling; e !== null;)wm(e, t, n), e = e.sibling } var Dt = null, ur = !1; function ci(e, t, n) { for (n = n.child; n !== null;)ET(e, t, n), n = n.sibling } function ET(e, t, n) { if (Ar && typeof Ar.onCommitFiberUnmount == "function") try { Ar.onCommitFiberUnmount(hf, n) } catch { } switch (n.tag) { case 5: Yt || $s(n, t); case 6: var r = Dt, i = ur; Dt = null, ci(e, t, n), Dt = r, ur = i, Dt !== null && (ur ? (e = Dt, n = n.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n)) : Dt.removeChild(n.stateNode)); break; case 18: Dt !== null && (ur ? (e = Dt, n = n.stateNode, e.nodeType === 8 ? bp(e.parentNode, n) : e.nodeType === 1 && bp(e, n), Ll(e)) : bp(Dt, n.stateNode)); break; case 4: r = Dt, i = ur, Dt = n.stateNode.containerInfo, ur = !0, ci(e, t, n), Dt = r, ur = i; break; case 0: case 11: case 14: case 15: if (!Yt && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) { i = r = r.next; do { var o = i, s = o.destroy; o = o.tag, s !== void 0 && (o & 2 || o & 4) && vm(n, t, s), i = i.next } while (i !== r) } ci(e, t, n); break; case 1: if (!Yt && ($s(n, t), r = n.stateNode, typeof r.componentWillUnmount == "function")) try { r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount() } catch (a) { at(n, t, a) } ci(e, t, n); break; case 21: ci(e, t, n); break; case 22: n.mode & 1 ? (Yt = (r = Yt) || n.memoizedState !== null, ci(e, t, n), Yt = r) : ci(e, t, n); break; default: ci(e, t, n) } } function Sb(e) { var t = e.updateQueue; if (t !== null) { e.updateQueue = null; var n = e.stateNode; n === null && (n = e.stateNode = new eR), t.forEach(function (r) { var i = cR.bind(null, e, r); n.has(r) || (n.add(r), r.then(i, i)) }) } } function ir(e, t) { var n = t.deletions; if (n !== null) for (var r = 0; r < n.length; r++) { var i = n[r]; try { var o = e, s = t, a = s; e: for (; a !== null;) { switch (a.tag) { case 5: Dt = a.stateNode, ur = !1; break e; case 3: Dt = a.stateNode.containerInfo, ur = !0; break e; case 4: Dt = a.stateNode.containerInfo, ur = !0; break e }a = a.return } if (Dt === null) throw Error(ee(160)); ET(o, s, i), Dt = null, ur = !1; var l = i.alternate; l !== null && (l.return = null), i.return = null } catch (u) { at(i, t, u) } } if (t.subtreeFlags & 12854) for (t = t.child; t !== null;)TT(t, e), t = t.sibling } function TT(e, t) { var n = e.alternate, r = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (ir(t, e), Sr(e), r & 4) { try { gl(3, e, e.return), Sf(3, e) } catch (v) { at(e, e.return, v) } try { gl(5, e, e.return) } catch (v) { at(e, e.return, v) } } break; case 1: ir(t, e), Sr(e), r & 512 && n !== null && $s(n, n.return); break; case 5: if (ir(t, e), Sr(e), r & 512 && n !== null && $s(n, n.return), e.flags & 32) { var i = e.stateNode; try { Ml(i, "") } catch (v) { at(e, e.return, v) } } if (r & 4 && (i = e.stateNode, i != null)) { var o = e.memoizedProps, s = n !== null ? n.memoizedProps : o, a = e.type, l = e.updateQueue; if (e.updateQueue = null, l !== null) try { a === "input" && o.type === "radio" && o.name != null && GS(i, o), Hh(a, s); var u = Hh(a, o); for (s = 0; s < l.length; s += 2) { var c = l[s], d = l[s + 1]; c === "style" ? XS(i, d) : c === "dangerouslySetInnerHTML" ? YS(i, d) : c === "children" ? Ml(i, d) : Jg(i, c, d, u) } switch (a) { case "input": Fh(i, o); break; case "textarea": KS(i, o); break; case "select": var f = i._wrapperState.wasMultiple; i._wrapperState.wasMultiple = !!o.multiple; var p = o.value; p != null ? Is(i, !!o.multiple, p, !1) : f !== !!o.multiple && (o.defaultValue != null ? Is(i, !!o.multiple, o.defaultValue, !0) : Is(i, !!o.multiple, o.multiple ? [] : "", !1)) }i[Dl] = o } catch (v) { at(e, e.return, v) } } break; case 6: if (ir(t, e), Sr(e), r & 4) { if (e.stateNode === null) throw Error(ee(162)); i = e.stateNode, o = e.memoizedProps; try { i.nodeValue = o } catch (v) { at(e, e.return, v) } } break; case 3: if (ir(t, e), Sr(e), r & 4 && n !== null && n.memoizedState.isDehydrated) try { Ll(t.containerInfo) } catch (v) { at(e, e.return, v) } break; case 4: ir(t, e), Sr(e); break; case 13: ir(t, e), Sr(e), i = e.child, i.flags & 8192 && (o = i.memoizedState !== null, i.stateNode.isHidden = o, !o || i.alternate !== null && i.alternate.memoizedState !== null || (_v = pt())), r & 4 && Sb(e); break; case 22: if (c = n !== null && n.memoizedState !== null, e.mode & 1 ? (Yt = (u = Yt) || c, ir(t, e), Yt = u) : ir(t, e), Sr(e), r & 8192) { if (u = e.memoizedState !== null, (e.stateNode.isHidden = u) && !c && e.mode & 1) for (de = e, c = e.child; c !== null;) { for (d = de = c; de !== null;) { switch (f = de, p = f.child, f.tag) { case 0: case 11: case 14: case 15: gl(4, f, f.return); break; case 1: $s(f, f.return); var m = f.stateNode; if (typeof m.componentWillUnmount == "function") { r = f, n = f.return; try { t = r, m.props = t.memoizedProps, m.state = t.memoizedState, m.componentWillUnmount() } catch (v) { at(r, n, v) } } break; case 5: $s(f, f.return); break; case 22: if (f.memoizedState !== null) { Tb(d); continue } }p !== null ? (p.return = f, de = p) : Tb(d) } c = c.sibling } e: for (c = null, d = e; ;) { if (d.tag === 5) { if (c === null) { c = d; try { i = d.stateNode, u ? (o = i.style, typeof o.setProperty == "function" ? o.setProperty("display", "none", "important") : o.display = "none") : (a = d.stateNode, l = d.memoizedProps.style, s = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = QS("display", s)) } catch (v) { at(e, e.return, v) } } } else if (d.tag === 6) { if (c === null) try { d.stateNode.nodeValue = u ? "" : d.memoizedProps } catch (v) { at(e, e.return, v) } } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === e) && d.child !== null) { d.child.return = d, d = d.child; continue } if (d === e) break e; for (; d.sibling === null;) { if (d.return === null || d.return === e) break e; c === d && (c = null), d = d.return } c === d && (c = null), d.sibling.return = d.return, d = d.sibling } } break; case 19: ir(t, e), Sr(e), r & 4 && Sb(e); break; case 21: break; default: ir(t, e), Sr(e) } } function Sr(e) { var t = e.flags; if (t & 2) { try { e: { for (var n = e.return; n !== null;) { if (ST(n)) { var r = n; break e } n = n.return } throw Error(ee(160)) } switch (r.tag) { case 5: var i = r.stateNode; r.flags & 32 && (Ml(i, ""), r.flags &= -33); var o = xb(e); wm(e, o, i); break; case 3: case 4: var s = r.stateNode.containerInfo, a = xb(e); bm(e, a, s); break; default: throw Error(ee(161)) } } catch (l) { at(e, e.return, l) } e.flags &= -3 } t & 4096 && (e.flags &= -4097) } function nR(e, t, n) { de = e, CT(e) } function CT(e, t, n) { for (var r = (e.mode & 1) !== 0; de !== null;) { var i = de, o = i.child; if (i.tag === 22 && r) { var s = i.memoizedState !== null || nc; if (!s) { var a = i.alternate, l = a !== null && a.memoizedState !== null || Yt; a = nc; var u = Yt; if (nc = s, (Yt = l) && !u) for (de = i; de !== null;)s = de, l = s.child, s.tag === 22 && s.memoizedState !== null ? Cb(i) : l !== null ? (l.return = s, de = l) : Cb(i); for (; o !== null;)de = o, CT(o), o = o.sibling; de = i, nc = a, Yt = u } Eb(e) } else i.subtreeFlags & 8772 && o !== null ? (o.return = i, de = o) : Eb(e) } } function Eb(e) { for (; de !== null;) { var t = de; if (t.flags & 8772) { var n = t.alternate; try { if (t.flags & 8772) switch (t.tag) { case 0: case 11: case 15: Yt || Sf(5, t); break; case 1: var r = t.stateNode; if (t.flags & 4 && !Yt) if (n === null) r.componentDidMount(); else { var i = t.elementType === t.type ? n.memoizedProps : lr(t.type, n.memoizedProps); r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var o = t.updateQueue; o !== null && ab(t, o, r); break; case 3: var s = t.updateQueue; if (s !== null) { if (n = null, t.child !== null) switch (t.child.tag) { case 5: n = t.child.stateNode; break; case 1: n = t.child.stateNode }ab(t, s, n) } break; case 5: var a = t.stateNode; if (n === null && t.flags & 4) { n = a; var l = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": l.autoFocus && n.focus(); break; case "img": l.src && (n.src = l.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (t.memoizedState === null) { var u = t.alternate; if (u !== null) { var c = u.memoizedState; if (c !== null) { var d = c.dehydrated; d !== null && Ll(d) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(ee(163)) }Yt || t.flags & 512 && ym(t) } catch (f) { at(t, t.return, f) } } if (t === e) { de = null; break } if (n = t.sibling, n !== null) { n.return = t.return, de = n; break } de = t.return } } function Tb(e) { for (; de !== null;) { var t = de; if (t === e) { de = null; break } var n = t.sibling; if (n !== null) { n.return = t.return, de = n; break } de = t.return } } function Cb(e) { for (; de !== null;) { var t = de; try { switch (t.tag) { case 0: case 11: case 15: var n = t.return; try { Sf(4, t) } catch (l) { at(t, n, l) } break; case 1: var r = t.stateNode; if (typeof r.componentDidMount == "function") { var i = t.return; try { r.componentDidMount() } catch (l) { at(t, i, l) } } var o = t.return; try { ym(t) } catch (l) { at(t, o, l) } break; case 5: var s = t.return; try { ym(t) } catch (l) { at(t, s, l) } } } catch (l) { at(t, t.return, l) } if (t === e) { de = null; break } var a = t.sibling; if (a !== null) { a.return = t.return, de = a; break } de = t.return } } var rR = Math.ceil, Ed = ai.ReactCurrentDispatcher, Mv = ai.ReactCurrentOwner, Xn = ai.ReactCurrentBatchConfig, Ne = 0, Ot = null, Ct = null, Vt = 0, En = 0, As = Xi(0), kt = 0, Hl = null, Io = 0, Ef = 0, kv = 0, vl = null, hn = null, _v = 0, ia = 1 / 0, zr = null, Td = !1, xm = null, Bi = null, rc = !1, Ri = null, Cd = 0, yl = 0, Sm = null, Uc = -1, Hc = 0; function ln() { return Ne & 6 ? pt() : Uc !== -1 ? Uc : Uc = pt() } function Ui(e) { return e.mode & 1 ? Ne & 2 && Vt !== 0 ? Vt & -Vt : z_.transition !== null ? (Hc === 0 && (Hc = uE()), Hc) : (e = Ie, e !== 0 || (e = window.event, e = e === void 0 ? 16 : gE(e.type)), e) : 1 } function hr(e, t, n, r) { if (50 < yl) throw yl = 0, Sm = null, Error(ee(185)); xu(e, n, r), (!(Ne & 2) || e !== Ot) && (e === Ot && (!(Ne & 2) && (Ef |= n), kt === 4 && Ti(e, Vt)), yn(e, r), n === 1 && Ne === 0 && !(t.mode & 1) && (ia = pt() + 500, bf && Ji())) } function yn(e, t) { var n = e.callbackNode; zk(e, t); var r = ld(e, e === Ot ? Vt : 0); if (r === 0) n !== null && N0(n), e.callbackNode = null, e.callbackPriority = 0; else if (t = r & -r, e.callbackPriority !== t) { if (n != null && N0(n), t === 1) e.tag === 0 ? F_(Pb.bind(null, e)) : OE(Pb.bind(null, e)), O_(function () { !(Ne & 6) && Ji() }), n = null; else { switch (cE(r)) { case 1: n = rv; break; case 4: n = aE; break; case 16: n = ad; break; case 536870912: n = lE; break; default: n = ad }n = LT(n, PT.bind(null, e)) } e.callbackPriority = t, e.callbackNode = n } } function PT(e, t) { if (Uc = -1, Hc = 0, Ne & 6) throw Error(ee(327)); var n = e.callbackNode; if (Bs() && e.callbackNode !== n) return null; var r = ld(e, e === Ot ? Vt : 0); if (r === 0) return null; if (r & 30 || r & e.expiredLanes || t) t = Pd(e, r); else { t = r; var i = Ne; Ne |= 2; var o = AT(); (Ot !== e || Vt !== t) && (zr = null, ia = pt() + 500, Ao(e, t)); do try { sR(); break } catch (a) { $T(e, a) } while (!0); gv(), Ed.current = o, Ne = i, Ct !== null ? t = 0 : (Ot = null, Vt = 0, t = kt) } if (t !== 0) { if (t === 2 && (i = Yh(e), i !== 0 && (r = i, t = Em(e, i))), t === 1) throw n = Hl, Ao(e, 0), Ti(e, r), yn(e, pt()), n; if (t === 6) Ti(e, r); else { if (i = e.current.alternate, !(r & 30) && !iR(i) && (t = Pd(e, r), t === 2 && (o = Yh(e), o !== 0 && (r = o, t = Em(e, o))), t === 1)) throw n = Hl, Ao(e, 0), Ti(e, r), yn(e, pt()), n; switch (e.finishedWork = i, e.finishedLanes = r, t) { case 0: case 1: throw Error(ee(345)); case 2: lo(e, hn, zr); break; case 3: if (Ti(e, r), (r & 130023424) === r && (t = _v + 500 - pt(), 10 < t)) { if (ld(e, 0) !== 0) break; if (i = e.suspendedLanes, (i & r) !== r) { ln(), e.pingedLanes |= e.suspendedLanes & i; break } e.timeoutHandle = rm(lo.bind(null, e, hn, zr), t); break } lo(e, hn, zr); break; case 4: if (Ti(e, r), (r & 4194240) === r) break; for (t = e.eventTimes, i = -1; 0 < r;) { var s = 31 - pr(r); o = 1 << s, s = t[s], s > i && (i = s), r &= ~o } if (r = i, r = pt() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * rR(r / 1960)) - r, 10 < r) { e.timeoutHandle = rm(lo.bind(null, e, hn, zr), r); break } lo(e, hn, zr); break; case 5: lo(e, hn, zr); break; default: throw Error(ee(329)) } } } return yn(e, pt()), e.callbackNode === n ? PT.bind(null, e) : null } function Em(e, t) { var n = vl; return e.current.memoizedState.isDehydrated && (Ao(e, t).flags |= 256), e = Pd(e, t), e !== 2 && (t = hn, hn = n, t !== null && Tm(t)), e } function Tm(e) { hn === null ? hn = e : hn.push.apply(hn, e) } function iR(e) { for (var t = e; ;) { if (t.flags & 16384) { var n = t.updateQueue; if (n !== null && (n = n.stores, n !== null)) for (var r = 0; r < n.length; r++) { var i = n[r], o = i.getSnapshot; i = i.value; try { if (!mr(o(), i)) return !1 } catch { return !1 } } } if (n = t.child, t.subtreeFlags & 16384 && n !== null) n.return = t, t = n; else { if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 } function Ti(e, t) { for (t &= ~kv, t &= ~Ef, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var n = 31 - pr(t), r = 1 << n; e[n] = -1, t &= ~r } } function Pb(e) { if (Ne & 6) throw Error(ee(327)); Bs(); var t = ld(e, 0); if (!(t & 1)) return yn(e, pt()), null; var n = Pd(e, t); if (e.tag !== 0 && n === 2) { var r = Yh(e); r !== 0 && (t = r, n = Em(e, r)) } if (n === 1) throw n = Hl, Ao(e, 0), Ti(e, t), yn(e, pt()), n; if (n === 6) throw Error(ee(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, lo(e, hn, zr), yn(e, pt()), null } function Rv(e, t) { var n = Ne; Ne |= 1; try { return e(t) } finally { Ne = n, Ne === 0 && (ia = pt() + 500, bf && Ji()) } } function Do(e) { Ri !== null && Ri.tag === 0 && !(Ne & 6) && Bs(); var t = Ne; Ne |= 1; var n = Xn.transition, r = Ie; try { if (Xn.transition = null, Ie = 1, e) return e() } finally { Ie = r, Xn.transition = n, Ne = t, !(Ne & 6) && Ji() } } function Lv() { En = As.current, Ke(As) } function Ao(e, t) { e.finishedWork = null, e.finishedLanes = 0; var n = e.timeoutHandle; if (n !== -1 && (e.timeoutHandle = -1, N_(n)), Ct !== null) for (n = Ct.return; n !== null;) { var r = n; switch (pv(r), r.tag) { case 1: r = r.type.childContextTypes, r != null && pd(); break; case 3: na(), Ke(gn), Ke(Xt), Sv(); break; case 5: xv(r); break; case 4: na(); break; case 13: Ke(Ze); break; case 19: Ke(Ze); break; case 10: vv(r.type._context); break; case 22: case 23: Lv() }n = n.return } if (Ot = e, Ct = e = Hi(e.current, null), Vt = En = t, kt = 0, Hl = null, kv = Ef = Io = 0, hn = vl = null, go !== null) { for (t = 0; t < go.length; t++)if (n = go[t], r = n.interleaved, r !== null) { n.interleaved = null; var i = r.next, o = n.pending; if (o !== null) { var s = o.next; o.next = i, r.next = s } n.pending = r } go = null } return e } function $T(e, t) { do { var n = Ct; try { if (gv(), zc.current = Sd, xd) { for (var r = nt.memoizedState; r !== null;) { var i = r.queue; i !== null && (i.pending = null), r = r.next } xd = !1 } if (jo = 0, Nt = Mt = nt = null, ml = !1, Vl = 0, Mv.current = null, n === null || n.return === null) { kt = 1, Hl = t, Ct = null; break } e: { var o = e, s = n.return, a = n, l = t; if (t = Vt, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") { var u = l, c = a, d = c.tag; if (!(c.mode & 1) && (d === 0 || d === 11 || d === 15)) { var f = c.alternate; f ? (c.updateQueue = f.updateQueue, c.memoizedState = f.memoizedState, c.lanes = f.lanes) : (c.updateQueue = null, c.memoizedState = null) } var p = pb(s); if (p !== null) { p.flags &= -257, hb(p, s, a, o, t), p.mode & 1 && fb(o, u, t), t = p, l = u; var m = t.updateQueue; if (m === null) { var v = new Set; v.add(l), t.updateQueue = v } else m.add(l); break e } else { if (!(t & 1)) { fb(o, u, t), Nv(); break e } l = Error(ee(426)) } } else if (Xe && a.mode & 1) { var x = pb(s); if (x !== null) { !(x.flags & 65536) && (x.flags |= 256), hb(x, s, a, o, t), hv(ra(l, a)); break e } } o = l = ra(l, a), kt !== 4 && (kt = 2), vl === null ? vl = [o] : vl.push(o), o = s; do { switch (o.tag) { case 3: o.flags |= 65536, t &= -t, o.lanes |= t; var g = cT(o, l, t); sb(o, g); break e; case 1: a = l; var h = o.type, y = o.stateNode; if (!(o.flags & 128) && (typeof h.getDerivedStateFromError == "function" || y !== null && typeof y.componentDidCatch == "function" && (Bi === null || !Bi.has(y)))) { o.flags |= 65536, t &= -t, o.lanes |= t; var E = dT(o, a, t); sb(o, E); break e } }o = o.return } while (o !== null) } kT(n) } catch (P) { t = P, Ct === n && n !== null && (Ct = n = n.return); continue } break } while (!0) } function AT() { var e = Ed.current; return Ed.current = Sd, e === null ? Sd : e } function Nv() { (kt === 0 || kt === 3 || kt === 2) && (kt = 4), Ot === null || !(Io & 268435455) && !(Ef & 268435455) || Ti(Ot, Vt) } function Pd(e, t) { var n = Ne; Ne |= 2; var r = AT(); (Ot !== e || Vt !== t) && (zr = null, Ao(e, t)); do try { oR(); break } catch (i) { $T(e, i) } while (!0); if (gv(), Ne = n, Ed.current = r, Ct !== null) throw Error(ee(261)); return Ot = null, Vt = 0, kt } function oR() { for (; Ct !== null;)MT(Ct) } function sR() { for (; Ct !== null && !_k();)MT(Ct) } function MT(e) { var t = RT(e.alternate, e, En); e.memoizedProps = e.pendingProps, t === null ? kT(e) : Ct = t, Mv.current = null } function kT(e) { var t = e; do { var n = t.alternate; if (e = t.return, t.flags & 32768) { if (n = Z_(n, t), n !== null) { n.flags &= 32767, Ct = n; return } if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null; else { kt = 6, Ct = null; return } } else if (n = J_(n, t, En), n !== null) { Ct = n; return } if (t = t.sibling, t !== null) { Ct = t; return } Ct = t = e } while (t !== null); kt === 0 && (kt = 5) } function lo(e, t, n) { var r = Ie, i = Xn.transition; try { Xn.transition = null, Ie = 1, aR(e, t, n, r) } finally { Xn.transition = i, Ie = r } return null } function aR(e, t, n, r) { do Bs(); while (Ri !== null); if (Ne & 6) throw Error(ee(327)); n = e.finishedWork; var i = e.finishedLanes; if (n === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(ee(177)); e.callbackNode = null, e.callbackPriority = 0; var o = n.lanes | n.childLanes; if (Vk(e, o), e === Ot && (Ct = Ot = null, Vt = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || rc || (rc = !0, LT(ad, function () { return Bs(), null })), o = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || o) { o = Xn.transition, Xn.transition = null; var s = Ie; Ie = 1; var a = Ne; Ne |= 4, Mv.current = null, tR(e, n), TT(n, e), $_(tm), ud = !!em, tm = em = null, e.current = n, nR(n), Rk(), Ne = a, Ie = s, Xn.transition = o } else e.current = n; if (rc && (rc = !1, Ri = e, Cd = i), o = e.pendingLanes, o === 0 && (Bi = null), Ok(n.stateNode), yn(e, pt()), t !== null) for (r = e.onRecoverableError, n = 0; n < t.length; n++)i = t[n], r(i.value, { componentStack: i.stack, digest: i.digest }); if (Td) throw Td = !1, e = xm, xm = null, e; return Cd & 1 && e.tag !== 0 && Bs(), o = e.pendingLanes, o & 1 ? e === Sm ? yl++ : (yl = 0, Sm = e) : yl = 0, Ji(), null } function Bs() { if (Ri !== null) { var e = cE(Cd), t = Xn.transition, n = Ie; try { if (Xn.transition = null, Ie = 16 > e ? 16 : e, Ri === null) var r = !1; else { if (e = Ri, Ri = null, Cd = 0, Ne & 6) throw Error(ee(331)); var i = Ne; for (Ne |= 4, de = e.current; de !== null;) { var o = de, s = o.child; if (de.flags & 16) { var a = o.deletions; if (a !== null) { for (var l = 0; l < a.length; l++) { var u = a[l]; for (de = u; de !== null;) { var c = de; switch (c.tag) { case 0: case 11: case 15: gl(8, c, o) }var d = c.child; if (d !== null) d.return = c, de = d; else for (; de !== null;) { c = de; var f = c.sibling, p = c.return; if (xT(c), c === u) { de = null; break } if (f !== null) { f.return = p, de = f; break } de = p } } } var m = o.alternate; if (m !== null) { var v = m.child; if (v !== null) { m.child = null; do { var x = v.sibling; v.sibling = null, v = x } while (v !== null) } } de = o } } if (o.subtreeFlags & 2064 && s !== null) s.return = o, de = s; else e: for (; de !== null;) { if (o = de, o.flags & 2048) switch (o.tag) { case 0: case 11: case 15: gl(9, o, o.return) }var g = o.sibling; if (g !== null) { g.return = o.return, de = g; break e } de = o.return } } var h = e.current; for (de = h; de !== null;) { s = de; var y = s.child; if (s.subtreeFlags & 2064 && y !== null) y.return = s, de = y; else e: for (s = h; de !== null;) { if (a = de, a.flags & 2048) try { switch (a.tag) { case 0: case 11: case 15: Sf(9, a) } } catch (P) { at(a, a.return, P) } if (a === s) { de = null; break e } var E = a.sibling; if (E !== null) { E.return = a.return, de = E; break e } de = a.return } } if (Ne = i, Ji(), Ar && typeof Ar.onPostCommitFiberRoot == "function") try { Ar.onPostCommitFiberRoot(hf, e) } catch { } r = !0 } return r } finally { Ie = n, Xn.transition = t } } return !1 } function $b(e, t, n) { t = ra(n, t), t = cT(e, t, 1), e = Vi(e, t, 1), t = ln(), e !== null && (xu(e, 1, t), yn(e, t)) } function at(e, t, n) { if (e.tag === 3) $b(e, e, n); else for (; t !== null;) { if (t.tag === 3) { $b(t, e, n); break } else if (t.tag === 1) { var r = t.stateNode; if (typeof t.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (Bi === null || !Bi.has(r))) { e = ra(n, e), e = dT(t, e, 1), t = Vi(t, e, 1), e = ln(), t !== null && (xu(t, 1, e), yn(t, e)); break } } t = t.return } } function lR(e, t, n) { var r = e.pingCache; r !== null && r.delete(t), t = ln(), e.pingedLanes |= e.suspendedLanes & n, Ot === e && (Vt & n) === n && (kt === 4 || kt === 3 && (Vt & 130023424) === Vt && 500 > pt() - _v ? Ao(e, 0) : kv |= n), yn(e, t) } function _T(e, t) { t === 0 && (e.mode & 1 ? (t = Ku, Ku <<= 1, !(Ku & 130023424) && (Ku = 4194304)) : t = 1); var n = ln(); e = ei(e, t), e !== null && (xu(e, t, n), yn(e, n)) } function uR(e) { var t = e.memoizedState, n = 0; t !== null && (n = t.retryLane), _T(e, n) } function cR(e, t) { var n = 0; switch (e.tag) { case 13: var r = e.stateNode, i = e.memoizedState; i !== null && (n = i.retryLane); break; case 19: r = e.stateNode; break; default: throw Error(ee(314)) }r !== null && r.delete(t), _T(e, n) } var RT; RT = function (e, t, n) { if (e !== null) if (e.memoizedProps !== t.pendingProps || gn.current) mn = !0; else { if (!(e.lanes & n) && !(t.flags & 128)) return mn = !1, X_(e, t, n); mn = !!(e.flags & 131072) } else mn = !1, Xe && t.flags & 1048576 && jE(t, gd, t.index); switch (t.lanes = 0, t.tag) { case 2: var r = t.type; Bc(e, t), e = t.pendingProps; var i = Zs(t, Xt.current); Vs(t, n), i = Tv(null, t, r, e, i, n); var o = Cv(); return t.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, vn(r) ? (o = !0, hd(t)) : o = !1, t.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, bv(t), i.updater = xf, t.stateNode = i, i._reactInternals = t, cm(t, r, e, n), t = pm(null, t, r, !0, o, n)) : (t.tag = 0, Xe && o && fv(t), an(null, t, i, n), t = t.child), t; case 16: r = t.elementType; e: { switch (Bc(e, t), e = t.pendingProps, i = r._init, r = i(r._payload), t.type = r, i = t.tag = fR(r), e = lr(r, e), i) { case 0: t = fm(null, t, r, e, n); break e; case 1: t = vb(null, t, r, e, n); break e; case 11: t = mb(null, t, r, e, n); break e; case 14: t = gb(null, t, r, lr(r.type, e), n); break e }throw Error(ee(306, r, "")) } return t; case 0: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : lr(r, i), fm(e, t, r, i, n); case 1: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : lr(r, i), vb(e, t, r, i, n); case 3: e: { if (mT(t), e === null) throw Error(ee(387)); r = t.pendingProps, o = t.memoizedState, i = o.element, BE(e, t), bd(t, r, null, n); var s = t.memoizedState; if (r = s.element, o.isDehydrated) if (o = { element: r, isDehydrated: !1, cache: s.cache, pendingSuspenseBoundaries: s.pendingSuspenseBoundaries, transitions: s.transitions }, t.updateQueue.baseState = o, t.memoizedState = o, t.flags & 256) { i = ra(Error(ee(423)), t), t = yb(e, t, r, n, i); break e } else if (r !== i) { i = ra(Error(ee(424)), t), t = yb(e, t, r, n, i); break e } else for (Pn = zi(t.stateNode.containerInfo.firstChild), An = t, Xe = !0, dr = null, n = zE(t, null, r, n), t.child = n; n;)n.flags = n.flags & -3 | 4096, n = n.sibling; else { if (ea(), r === i) { t = ti(e, t, n); break e } an(e, t, r, n) } t = t.child } return t; case 5: return UE(t), e === null && am(t), r = t.type, i = t.pendingProps, o = e !== null ? e.memoizedProps : null, s = i.children, nm(r, i) ? s = null : o !== null && nm(r, o) && (t.flags |= 32), hT(e, t), an(e, t, s, n), t.child; case 6: return e === null && am(t), null; case 13: return gT(e, t, n); case 4: return wv(t, t.stateNode.containerInfo), r = t.pendingProps, e === null ? t.child = ta(t, null, r, n) : an(e, t, r, n), t.child; case 11: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : lr(r, i), mb(e, t, r, i, n); case 7: return an(e, t, t.pendingProps, n), t.child; case 8: return an(e, t, t.pendingProps.children, n), t.child; case 12: return an(e, t, t.pendingProps.children, n), t.child; case 10: e: { if (r = t.type._context, i = t.pendingProps, o = t.memoizedProps, s = i.value, Ve(vd, r._currentValue), r._currentValue = s, o !== null) if (mr(o.value, s)) { if (o.children === i.children && !gn.current) { t = ti(e, t, n); break e } } else for (o = t.child, o !== null && (o.return = t); o !== null;) { var a = o.dependencies; if (a !== null) { s = o.child; for (var l = a.firstContext; l !== null;) { if (l.context === r) { if (o.tag === 1) { l = qr(-1, n & -n), l.tag = 2; var u = o.updateQueue; if (u !== null) { u = u.shared; var c = u.pending; c === null ? l.next = l : (l.next = c.next, c.next = l), u.pending = l } } o.lanes |= n, l = o.alternate, l !== null && (l.lanes |= n), lm(o.return, n, t), a.lanes |= n; break } l = l.next } } else if (o.tag === 10) s = o.type === t.type ? null : o.child; else if (o.tag === 18) { if (s = o.return, s === null) throw Error(ee(341)); s.lanes |= n, a = s.alternate, a !== null && (a.lanes |= n), lm(s, n, t), s = o.sibling } else s = o.child; if (s !== null) s.return = o; else for (s = o; s !== null;) { if (s === t) { s = null; break } if (o = s.sibling, o !== null) { o.return = s.return, s = o; break } s = s.return } o = s } an(e, t, i.children, n), t = t.child } return t; case 9: return i = t.type, r = t.pendingProps.children, Vs(t, n), i = Jn(i), r = r(i), t.flags |= 1, an(e, t, r, n), t.child; case 14: return r = t.type, i = lr(r, t.pendingProps), i = lr(r.type, i), gb(e, t, r, i, n); case 15: return fT(e, t, t.type, t.pendingProps, n); case 17: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : lr(r, i), Bc(e, t), t.tag = 1, vn(r) ? (e = !0, hd(t)) : e = !1, Vs(t, n), uT(t, r, i), cm(t, r, i, n), pm(null, t, r, !0, e, n); case 19: return vT(e, t, n); case 22: return pT(e, t, n) }throw Error(ee(156, t.tag)) }; function LT(e, t) { return sE(e, t) } function dR(e, t, n, r) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Qn(e, t, n, r) { return new dR(e, t, n, r) } function Ov(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function fR(e) { if (typeof e == "function") return Ov(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === ev) return 11; if (e === tv) return 14 } return 2 } function Hi(e, t) { var n = e.alternate; return n === null ? (n = Qn(e.tag, t, e.key, e.mode), n.elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = e.flags & 14680064, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n } function Wc(e, t, n, r, i, o) { var s = 2; if (r = e, typeof e == "function") Ov(e) && (s = 1); else if (typeof e == "string") s = 5; else e: switch (e) { case ys: return Mo(n.children, i, o, t); case Zg: s = 8, i |= 8; break; case Nh: return e = Qn(12, n, t, i | 2), e.elementType = Nh, e.lanes = o, e; case Oh: return e = Qn(13, n, t, i), e.elementType = Oh, e.lanes = o, e; case jh: return e = Qn(19, n, t, i), e.elementType = jh, e.lanes = o, e; case US: return Tf(n, i, o, t); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case VS: s = 10; break e; case BS: s = 9; break e; case ev: s = 11; break e; case tv: s = 14; break e; case bi: s = 16, r = null; break e }throw Error(ee(130, e == null ? e : typeof e, "")) }return t = Qn(s, n, t, i), t.elementType = e, t.type = r, t.lanes = o, t } function Mo(e, t, n, r) { return e = Qn(7, e, r, t), e.lanes = n, e } function Tf(e, t, n, r) { return e = Qn(22, e, r, t), e.elementType = US, e.lanes = n, e.stateNode = { isHidden: !1 }, e } function $p(e, t, n) { return e = Qn(6, e, null, t), e.lanes = n, e } function Ap(e, t, n) { return t = Qn(4, e.children !== null ? e.children : [], e.key, t), t.lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function pR(e, t, n, r, i) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = lp(0), this.expirationTimes = lp(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = lp(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null } function jv(e, t, n, r, i, o, s, a, l) { return e = new pR(e, t, n, a, l), t === 1 ? (t = 1, o === !0 && (t |= 8)) : t = 0, o = Qn(3, null, null, t), e.current = o, o.stateNode = e, o.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, bv(o), e } function hR(e, t, n) { var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: vs, key: r == null ? null : "" + r, children: e, containerInfo: t, implementation: n } } function NT(e) { if (!e) return Gi; e = e._reactInternals; e: { if (qo(e) !== e || e.tag !== 1) throw Error(ee(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (vn(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (t !== null); throw Error(ee(171)) } if (e.tag === 1) { var n = e.type; if (vn(n)) return NE(e, n, t) } return t } function OT(e, t, n, r, i, o, s, a, l) { return e = jv(n, r, !0, e, i, o, s, a, l), e.context = NT(null), n = e.current, r = ln(), i = Ui(n), o = qr(r, i), o.callback = t ?? null, Vi(n, o, i), e.current.lanes = i, xu(e, i, r), yn(e, r), e } function Cf(e, t, n, r) { var i = t.current, o = ln(), s = Ui(i); return n = NT(n), t.context === null ? t.context = n : t.pendingContext = n, t = qr(o, s), t.payload = { element: e }, r = r === void 0 ? null : r, r !== null && (t.callback = r), e = Vi(i, t, s), e !== null && (hr(e, i, s, o), Fc(e, i, s)), s } function $d(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: return e.child.stateNode; default: return e.child.stateNode } } function Ab(e, t) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var n = e.retryLane; e.retryLane = n !== 0 && n < t ? n : t } } function Iv(e, t) { Ab(e, t), (e = e.alternate) && Ab(e, t) } function mR() { return null } var jT = typeof reportError == "function" ? reportError : function (e) { console.error(e) }; function Dv(e) { this._internalRoot = e } Pf.prototype.render = Dv.prototype.render = function (e) { var t = this._internalRoot; if (t === null) throw Error(ee(409)); Cf(e, t, null, null) }; Pf.prototype.unmount = Dv.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var t = e.containerInfo; Do(function () { Cf(null, e, null, null) }), t[Zr] = null } }; function Pf(e) { this._internalRoot = e } Pf.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = pE(); e = { blockedOn: null, target: e, priority: t }; for (var n = 0; n < Ei.length && t !== 0 && t < Ei[n].priority; n++); Ei.splice(n, 0, e), n === 0 && mE(e) } }; function Fv(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function $f(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable ")) } function Mb() { } function gR(e, t, n, r, i) { if (i) { if (typeof r == "function") { var o = r; r = function () { var u = $d(s); o.call(u) } } var s = OT(t, r, e, 0, null, !1, !1, "", Mb); return e._reactRootContainer = s, e[Zr] = s.current, jl(e.nodeType === 8 ? e.parentNode : e), Do(), s } for (; i = e.lastChild;)e.removeChild(i); if (typeof r == "function") { var a = r; r = function () { var u = $d(l); a.call(u) } } var l = jv(e, 0, !1, null, null, !1, !1, "", Mb); return e._reactRootContainer = l, e[Zr] = l.current, jl(e.nodeType === 8 ? e.parentNode : e), Do(function () { Cf(t, l, n, r) }), l } function Af(e, t, n, r, i) { var o = n._reactRootContainer; if (o) { var s = o; if (typeof i == "function") { var a = i; i = function () { var l = $d(s); a.call(l) } } Cf(t, s, e, i) } else s = gR(n, t, e, i, r); return $d(s) } dE = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var n = Ja(t.pendingLanes); n !== 0 && (iv(t, n | 1), yn(t, pt()), !(Ne & 6) && (ia = pt() + 500, Ji())) } break; case 13: Do(function () { var r = ei(e, 1); if (r !== null) { var i = ln(); hr(r, e, 1, i) } }), Iv(e, 1) } }; ov = function (e) { if (e.tag === 13) { var t = ei(e, 134217728); if (t !== null) { var n = ln(); hr(t, e, 134217728, n) } Iv(e, 134217728) } }; fE = function (e) { if (e.tag === 13) { var t = Ui(e), n = ei(e, t); if (n !== null) { var r = ln(); hr(n, e, t, r) } Iv(e, t) } }; pE = function () { return Ie }; hE = function (e, t) { var n = Ie; try { return Ie = e, t() } finally { Ie = n } }; Gh = function (e, t, n) { switch (t) { case "input": if (Fh(e, n), t = n.name, n.type === "radio" && t != null) { for (n = e; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) { var r = n[t]; if (r !== e && r.form === e.form) { var i = yf(r); if (!i) throw Error(ee(90)); WS(r), Fh(r, i) } } } break; case "textarea": KS(e, n); break; case "select": t = n.value, t != null && Is(e, !!n.multiple, t, !1) } }; eE = Rv; tE = Do; var vR = { usingClientEntryPoint: !1, Events: [Eu, Ss, yf, JS, ZS, Rv] }, Ra = { findFiberByHostInstance: mo, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, yR = { bundleType: Ra.bundleType, version: Ra.version, rendererPackageName: Ra.rendererPackageName, rendererConfig: Ra.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ai.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = iE(e), e === null ? null : e.stateNode }, findFiberByHostInstance: Ra.findFiberByHostInstance || mR, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var ic = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!ic.isDisabled && ic.supportsFiber) try { hf = ic.inject(yR), Ar = ic } catch { } } On.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vR; On.createPortal = function (e, t) { var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!Fv(t)) throw Error(ee(200)); return hR(e, t, null, n) }; On.createRoot = function (e, t) { if (!Fv(e)) throw Error(ee(299)); var n = !1, r = "", i = jT; return t != null && (t.unstable_strictMode === !0 && (n = !0), t.identifierPrefix !== void 0 && (r = t.identifierPrefix), t.onRecoverableError !== void 0 && (i = t.onRecoverableError)), t = jv(e, 1, !1, null, null, n, !1, r, i), e[Zr] = t.current, jl(e.nodeType === 8 ? e.parentNode : e), new Dv(t) }; On.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; var t = e._reactInternals; if (t === void 0) throw typeof e.render == "function" ? Error(ee(188)) : (e = Object.keys(e).join(","), Error(ee(268, e))); return e = iE(t), e = e === null ? null : e.stateNode, e }; On.flushSync = function (e) { return Do(e) }; On.hydrate = function (e, t, n) { if (!$f(t)) throw Error(ee(200)); return Af(null, e, t, !0, n) }; On.hydrateRoot = function (e, t, n) { if (!Fv(e)) throw Error(ee(405)); var r = n != null && n.hydratedSources || null, i = !1, o = "", s = jT; if (n != null && (n.unstable_strictMode === !0 && (i = !0), n.identifierPrefix !== void 0 && (o = n.identifierPrefix), n.onRecoverableError !== void 0 && (s = n.onRecoverableError)), t = OT(t, null, e, 1, n ?? null, i, !1, o, s), e[Zr] = t.current, jl(e), r) for (e = 0; e < r.length; e++)n = r[e], i = n._getVersion, i = i(n._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i); return new Pf(t) }; On.render = function (e, t, n) { if (!$f(t)) throw Error(ee(200)); return Af(null, e, t, !1, n) }; On.unmountComponentAtNode = function (e) { if (!$f(e)) throw Error(ee(40)); return e._reactRootContainer ? (Do(function () { Af(null, null, e, !1, function () { e._reactRootContainer = null, e[Zr] = null }) }), !0) : !1 }; On.unstable_batchedUpdates = Rv; On.unstable_renderSubtreeIntoContainer = function (e, t, n, r) { if (!$f(n)) throw Error(ee(200)); if (e == null || e._reactInternals === void 0) throw Error(ee(38)); return Af(e, t, n, !1, r) }; On.version = "18.3.1-next-f1338f8080-20240426"; function IT() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(IT) } catch (e) { console.error(e) } } IT(), IS.exports = On; var DT = IS.exports; const FT = CS(DT); var kb = DT; Rh.createRoot = kb.createRoot, Rh.hydrateRoot = kb.hydrateRoot; function Cu(e = {}) { const { strict: t = !0, errorMessage: n = "useContext: `context` is undefined. Seems you forgot to wrap component within the Provider", name: r } = e, i = S.createContext(void 0); i.displayName = r; function o() { var s; const a = S.useContext(i); if (!a && t) { const l = new Error(n); throw l.name = "ContextError", (s = Error.captureStackTrace) == null || s.call(Error, l, o), l } return a } return [i.Provider, o, i] } function ht(e) { const t = S.useRef(null); return S.useImperativeHandle(e, () => t.current), t } function zv(e) { return Array.isArray(e) } function bR(e) { return zv(e) && e.length === 0 } function zT(e) { const t = typeof e; return e != null && (t === "object" || t === "function") && !zv(e) } function wR(e) { return zT(e) && Object.keys(e).length === 0 } function xR(e) { return zv(e) ? bR(e) : zT(e) ? wR(e) : e == null || e === "" } var fe = e => e ? "true" : void 0, SR = e => (e == null ? void 0 : e.length) <= 4 ? e : e == null ? void 0 : e.slice(0, 3), ER = (...e) => { let t = " "; for (const n of e) if (typeof n == "string" && n.length > 0) { t = n; break } return t }; function VT(e) { var t, n, r = ""; if (typeof e == "string" || typeof e == "number") r += e; else if (typeof e == "object") if (Array.isArray(e)) for (t = 0; t < e.length; t++)e[t] && (n = VT(e[t])) && (r && (r += " "), r += n); else for (t in e) e[t] && (r && (r += " "), r += t); return r } function ke(...e) { for (var t = 0, n, r, i = ""; t < e.length;)(n = e[t++]) && (r = VT(n)) && (i && (i += " "), i += r); return i } var _b = {}; function TR(e, t, ...n) { const i = `[Next UI]${` [${t}]`}: ${e}`; typeof console > "u" || _b[i] || (_b[i] = !0) } var CR = Object.create, BT = Object.defineProperty, PR = Object.getOwnPropertyDescriptor, UT = Object.getOwnPropertyNames, $R = Object.getPrototypeOf, AR = Object.prototype.hasOwnProperty, HT = (e, t) => function () { return t || (0, e[UT(e)[0]])((t = { exports: {} }).exports, t), t.exports }, MR = (e, t, n, r) => { if (t && typeof t == "object" || typeof t == "function") for (let i of UT(t)) !AR.call(e, i) && i !== n && BT(e, i, { get: () => t[i], enumerable: !(r = PR(t, i)) || r.enumerable }); return e }, kR = (e, t, n) => (n = e != null ? CR($R(e)) : {}, MR(!e || !e.__esModule ? BT(n, "default", { value: e, enumerable: !0 }) : n, e)), _R = HT({ "../../../node_modules/.pnpm/react@18.2.0/node_modules/react/cjs/react.production.min.js"(e) { var t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), f = Symbol.iterator; function p(T) { return T === null || typeof T != "object" ? null : (T = f && T[f] || T["@@iterator"], typeof T == "function" ? T : null) } var m = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, v = Object.assign, x = {}; function g(T, N, W) { this.props = T, this.context = N, this.refs = x, this.updater = W || m } g.prototype.isReactComponent = {}, g.prototype.setState = function (T, N) { if (typeof T != "object" && typeof T != "function" && T != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, T, N, "setState") }, g.prototype.forceUpdate = function (T) { this.updater.enqueueForceUpdate(this, T, "forceUpdate") }; function h() { } h.prototype = g.prototype; function y(T, N, W) { this.props = T, this.context = N, this.refs = x, this.updater = W || m } var E = y.prototype = new h; E.constructor = y, v(E, g.prototype), E.isPureReactComponent = !0; var P = Array.isArray, $ = Object.prototype.hasOwnProperty, L = { current: null }, b = { key: !0, ref: !0, __self: !0, __source: !0 }; function M(T, N, W) { var Q, q = {}, te = null, ae = null; if (N != null) for (Q in N.ref !== void 0 && (ae = N.ref), N.key !== void 0 && (te = "" + N.key), N) $.call(N, Q) && !b.hasOwnProperty(Q) && (q[Q] = N[Q]); var le = arguments.length - 2; if (le === 1) q.children = W; else if (1 < le) { for (var oe = Array(le), ge = 0; ge < le; ge++)oe[ge] = arguments[ge + 2]; q.children = oe } if (T && T.defaultProps) for (Q in le = T.defaultProps, le) q[Q] === void 0 && (q[Q] = le[Q]); return { $$typeof: t, type: T, key: te, ref: ae, props: q, _owner: L.current } } function R(T, N) { return { $$typeof: t, type: T.type, key: N, ref: T.ref, props: T.props, _owner: T._owner } } function A(T) { return typeof T == "object" && T !== null && T.$$typeof === t } function _(T) { var N = { "=": "=0", ":": "=2" }; return "$" + T.replace(/[=:]/g, function (W) { return N[W] }) } var C = /\/+/g; function k(T, N) { return typeof T == "object" && T !== null && T.key != null ? _("" + T.key) : N.toString(36) } function O(T, N, W, Q, q) { var te = typeof T; (te === "undefined" || te === "boolean") && (T = null); var ae = !1; if (T === null) ae = !0; else switch (te) { case "string": case "number": ae = !0; break; case "object": switch (T.$$typeof) { case t: case n: ae = !0 } }if (ae) return ae = T, q = q(ae), T = Q === "" ? "." + k(ae, 0) : Q, P(q) ? (W = "", T != null && (W = T.replace(C, "$&/") + "/"), O(q, N, W, "", function (ge) { return ge })) : q != null && (A(q) && (q = R(q, W + (!q.key || ae && ae.key === q.key ? "" : ("" + q.key).replace(C, "$&/") + "/") + T)), N.push(q)), 1; if (ae = 0, Q = Q === "" ? "." : Q + ":", P(T)) for (var le = 0; le < T.length; le++) { te = T[le]; var oe = Q + k(te, le); ae += O(te, N, W, oe, q) } else if (oe = p(T), typeof oe == "function") for (T = oe.call(T), le = 0; !(te = T.next()).done;)te = te.value, oe = Q + k(te, le++), ae += O(te, N, W, oe, q); else if (te === "object") throw N = String(T), Error("Objects are not valid as a React child (found: " + (N === "[object Object]" ? "object with keys {" + Object.keys(T).join(", ") + "}" : N) + "). If you meant to render a collection of children, use an array instead."); return ae } function U(T, N, W) { if (T == null) return T; var Q = [], q = 0; return O(T, Q, "", "", function (te) { return N.call(W, te, q++) }), Q } function z(T) { if (T._status === -1) { var N = T._result; N = N(), N.then(function (W) { (T._status === 0 || T._status === -1) && (T._status = 1, T._result = W) }, function (W) { (T._status === 0 || T._status === -1) && (T._status = 2, T._result = W) }), T._status === -1 && (T._status = 0, T._result = N) } if (T._status === 1) return T._result.default; throw T._result } var D = { current: null }, V = { transition: null }, H = { ReactCurrentDispatcher: D, ReactCurrentBatchConfig: V, ReactCurrentOwner: L }; e.Children = { map: U, forEach: function (T, N, W) { U(T, function () { N.apply(this, arguments) }, W) }, count: function (T) { var N = 0; return U(T, function () { N++ }), N }, toArray: function (T) { return U(T, function (N) { return N }) || [] }, only: function (T) { if (!A(T)) throw Error("React.Children.only expected to receive a single React element child."); return T } }, e.Component = g, e.Fragment = r, e.Profiler = o, e.PureComponent = y, e.StrictMode = i, e.Suspense = u, e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = H, e.cloneElement = function (T, N, W) { if (T == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + T + "."); var Q = v({}, T.props), q = T.key, te = T.ref, ae = T._owner; if (N != null) { if (N.ref !== void 0 && (te = N.ref, ae = L.current), N.key !== void 0 && (q = "" + N.key), T.type && T.type.defaultProps) var le = T.type.defaultProps; for (oe in N) $.call(N, oe) && !b.hasOwnProperty(oe) && (Q[oe] = N[oe] === void 0 && le !== void 0 ? le[oe] : N[oe]) } var oe = arguments.length - 2; if (oe === 1) Q.children = W; else if (1 < oe) { le = Array(oe); for (var ge = 0; ge < oe; ge++)le[ge] = arguments[ge + 2]; Q.children = le } return { $$typeof: t, type: T.type, key: q, ref: te, props: Q, _owner: ae } }, e.createContext = function (T) { return T = { $$typeof: a, _currentValue: T, _currentValue2: T, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, T.Provider = { $$typeof: s, _context: T }, T.Consumer = T }, e.createElement = M, e.createFactory = function (T) { var N = M.bind(null, T); return N.type = T, N }, e.createRef = function () { return { current: null } }, e.forwardRef = function (T) { return { $$typeof: l, render: T } }, e.isValidElement = A, e.lazy = function (T) { return { $$typeof: d, _payload: { _status: -1, _result: T }, _init: z } }, e.memo = function (T, N) { return { $$typeof: c, type: T, compare: N === void 0 ? null : N } }, e.startTransition = function (T) { var N = V.transition; V.transition = {}; try { T() } finally { V.transition = N } }, e.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }, e.useCallback = function (T, N) { return D.current.useCallback(T, N) }, e.useContext = function (T) { return D.current.useContext(T) }, e.useDebugValue = function () { }, e.useDeferredValue = function (T) { return D.current.useDeferredValue(T) }, e.useEffect = function (T, N) { return D.current.useEffect(T, N) }, e.useId = function () { return D.current.useId() }, e.useImperativeHandle = function (T, N, W) { return D.current.useImperativeHandle(T, N, W) }, e.useInsertionEffect = function (T, N) { return D.current.useInsertionEffect(T, N) }, e.useLayoutEffect = function (T, N) { return D.current.useLayoutEffect(T, N) }, e.useMemo = function (T, N) { return D.current.useMemo(T, N) }, e.useReducer = function (T, N, W) { return D.current.useReducer(T, N, W) }, e.useRef = function (T) { return D.current.useRef(T) }, e.useState = function (T) { return D.current.useState(T) }, e.useSyncExternalStore = function (T, N, W) { return D.current.useSyncExternalStore(T, N, W) }, e.useTransition = function () { return D.current.useTransition() }, e.version = "18.2.0" } }), RR = HT({ "../../../node_modules/.pnpm/react@18.2.0/node_modules/react/index.js"(e, t) { t.exports = _R() } }); kR(RR()); function LR(e) { return `${e}-${Math.floor(Math.random() * 1e6)}` } function fa(e) { if (!e || typeof e != "object") return ""; try { return JSON.stringify(e) } catch { return "" } }/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *//**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */function di(e, t) { const n = t - e + 1; return Array.from({ length: n }, (r, i) => i + e) } function NR(e, t, n) { return Math.min(Math.max(e, t), n) } var OR = (e, t) => { var n; let r = []; const i = (n = S.Children.map(e, s => S.isValidElement(s) && s.type === t ? (r.push(s), null) : s)) == null ? void 0 : n.filter(Boolean), o = r.length >= 0 ? r : void 0; return [i, o] }, jR = new Set(["id", "type", "style", "title", "role", "tabIndex", "htmlFor", "width", "height", "abbr", "accept", "acceptCharset", "accessKey", "action", "allowFullScreen", "allowTransparency", "alt", "async", "autoComplete", "autoFocus", "autoPlay", "cellPadding", "cellSpacing", "challenge", "charset", "checked", "cite", "class", "className", "cols", "colSpan", "command", "content", "contentEditable", "contextMenu", "controls", "coords", "crossOrigin", "data", "dateTime", "default", "defer", "dir", "disabled", "download", "draggable", "dropzone", "encType", "enterKeyHint", "for", "form", "formAction", "formEncType", "formMethod", "formNoValidate", "formTarget", "frameBorder", "headers", "hidden", "high", "href", "hrefLang", "httpEquiv", "icon", "inputMode", "isMap", "itemId", "itemProp", "itemRef", "itemScope", "itemType", "kind", "label", "lang", "list", "loop", "manifest", "max", "maxLength", "media", "mediaGroup", "method", "min", "minLength", "multiple", "muted", "name", "noValidate", "open", "optimum", "pattern", "ping", "placeholder", "poster", "preload", "radioGroup", "referrerPolicy", "readOnly", "rel", "required", "rows", "rowSpan", "sandbox", "scope", "scoped", "scrolling", "seamless", "selected", "shape", "size", "sizes", "slot", "sortable", "span", "spellCheck", "src", "srcDoc", "srcSet", "start", "step", "target", "translate", "typeMustMatch", "useMap", "value", "wmode", "wrap"]), IR = new Set(["onCopy", "onCut", "onPaste", "onLoad", "onError", "onWheel", "onScroll", "onCompositionEnd", "onCompositionStart", "onCompositionUpdate", "onKeyDown", "onKeyPress", "onKeyUp", "onFocus", "onBlur", "onChange", "onInput", "onSubmit", "onClick", "onContextMenu", "onDoubleClick", "onDrag", "onDragEnd", "onDragEnter", "onDragExit", "onDragLeave", "onDragOver", "onDragStart", "onDrop", "onMouseDown", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseOut", "onMouseOver", "onMouseUp", "onPointerDown", "onPointerEnter", "onPointerLeave", "onPointerUp", "onSelect", "onTouchCancel", "onTouchEnd", "onTouchMove", "onTouchStart", "onAnimationStart", "onAnimationEnd", "onAnimationIteration", "onTransitionEnd"]), Rb = /^(data-.*)$/, DR = /^(aria-.*)$/, oc = /^(on[A-Z].*)$/; function Ki(e, t = {}) { let { labelable: n = !0, enabled: r = !0, propNames: i, omitPropNames: o, omitEventNames: s, omitDataProps: a, omitEventProps: l } = t, u = {}; if (!r) return e; for (const c in e) o != null && o.has(c) || s != null && s.has(c) && oc.test(c) || oc.test(c) && !IR.has(c) || a && Rb.test(c) || l && oc.test(c) || (Object.prototype.hasOwnProperty.call(e, c) && (jR.has(c) || n && DR.test(c) || i != null && i.has(c) || Rb.test(c)) || oc.test(c)) && (u[c] = e[c]); return u } var [FR, Yo] = Cu({ name: "ProviderContext", strict: !1 }); const zR = new Set(["Arab", "Syrc", "Samr", "Mand", "Thaa", "Mend", "Nkoo", "Adlm", "Rohg", "Hebr"]), VR = new Set(["ae", "ar", "arc", "bcc", "bqi", "ckb", "dv", "fa", "glk", "he", "ku", "mzn", "nqo", "pnb", "ps", "sd", "ug", "ur", "yi"]); function WT(e) { if (Intl.Locale) { let n = new Intl.Locale(e).maximize(), r = typeof n.getTextInfo == "function" ? n.getTextInfo() : n.textInfo; if (r) return r.direction === "rtl"; if (n.script) return zR.has(n.script) } let t = e.split("-")[0]; return VR.has(t) } const Ad = { prefix: String(Math.round(Math.random() * 1e10)), current: 0 }, GT = se.createContext(Ad), BR = se.createContext(!1); let UR = !!(typeof window < "u" && window.document && window.document.createElement), Mp = new WeakMap; function HR(e = !1) { let t = S.useContext(GT), n = S.useRef(null); if (n.current === null && !e) { var r, i; let o = (i = se.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || i === void 0 || (r = i.ReactCurrentOwner) === null || r === void 0 ? void 0 : r.current; if (o) { let s = Mp.get(o); s == null ? Mp.set(o, { id: t.current, state: o.memoizedState }) : o.memoizedState !== s.state && (t.current = s.id, Mp.delete(o)) } n.current = ++t.current } return n.current } function WR(e) { let t = S.useContext(GT); t === Ad && !UR && console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server."); let n = HR(!!e), r = `react-aria${t.prefix}`; return e || `${r}-${n}` } function GR(e) { let t = se.useId(), [n] = S.useState(Vv()), r = n ? "react-aria" : `react-aria${Ad.prefix}`; return e || `${r}-${t}` } const KR = typeof se.useId == "function" ? GR : WR; function qR() { return !1 } function YR() { return !0 } function QR(e) { return () => { } } function Vv() { return typeof se.useSyncExternalStore == "function" ? se.useSyncExternalStore(QR, qR, YR) : S.useContext(BR) } const XR = Symbol.for("react-aria.i18n.locale"); function KT() { let e = typeof window < "u" && window[XR] || typeof navigator < "u" && (navigator.language || navigator.userLanguage) || "en-US"; try { Intl.DateTimeFormat.supportedLocalesOf([e]) } catch { e = "en-US" } return { locale: e, direction: WT(e) ? "rtl" : "ltr" } } let Cm = KT(), el = new Set; function Lb() { Cm = KT(); for (let e of el) e(Cm) } function qT() { let e = Vv(), [t, n] = S.useState(Cm); return S.useEffect(() => (el.size === 0 && window.addEventListener("languagechange", Lb), el.add(n), () => { el.delete(n), el.size === 0 && window.removeEventListener("languagechange", Lb) }), []), e ? { locale: "en-US", direction: "ltr" } : t } const YT = se.createContext(null); function JR(e) { let { locale: t, children: n } = e, r = qT(), i = se.useMemo(() => t ? { locale: t, direction: WT(t) ? "rtl" : "ltr" } : r, [r, t]); return se.createElement(YT.Provider, { value: i }, n) } function Bv() { let e = qT(); return S.useContext(YT) || e } var Pm = function (e, t) { return Pm = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, r) { n.__proto__ = r } || function (n, r) { for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]) }, Pm(e, t) }; function Uv(e, t) { if (typeof t != "function" && t !== null) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); Pm(e, t); function n() { this.constructor = e } e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n) } function ZR(e, t, n, r) { function i(o) { return o instanceof n ? o : new n(function (s) { s(o) }) } return new (n || (n = Promise))(function (o, s) { function a(c) { try { u(r.next(c)) } catch (d) { s(d) } } function l(c) { try { u(r.throw(c)) } catch (d) { s(d) } } function u(c) { c.done ? o(c.value) : i(c.value).then(a, l) } u((r = r.apply(e, t || [])).next()) }) } function QT(e, t) { var n = { label: 0, sent: function () { if (o[0] & 1) throw o[1]; return o[1] }, trys: [], ops: [] }, r, i, o, s = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype); return s.next = a(0), s.throw = a(1), s.return = a(2), typeof Symbol == "function" && (s[Symbol.iterator] = function () { return this }), s; function a(u) { return function (c) { return l([u, c]) } } function l(u) { if (r) throw new TypeError("Generator is already executing."); for (; s && (s = 0, u[0] && (n = 0)), n;)try { if (r = 1, i && (o = u[0] & 2 ? i.return : u[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) && !(o = o.call(i, u[1])).done) return o; switch (i = 0, o && (u = [u[0] & 2, o.value]), u[0]) { case 0: case 1: o = u; break; case 4: return n.label++, { value: u[1], done: !1 }; case 5: n.label++, i = u[1], u = [0]; continue; case 7: u = n.ops.pop(), n.trys.pop(); continue; default: if (o = n.trys, !(o = o.length > 0 && o[o.length - 1]) && (u[0] === 6 || u[0] === 2)) { n = 0; continue } if (u[0] === 3 && (!o || u[1] > o[0] && u[1] < o[3])) { n.label = u[1]; break } if (u[0] === 6 && n.label < o[1]) { n.label = o[1], o = u; break } if (o && n.label < o[2]) { n.label = o[2], n.ops.push(u); break } o[2] && n.ops.pop(), n.trys.pop(); continue }u = t.call(e, n) } catch (c) { u = [6, c], i = 0 } finally { r = o = 0 } if (u[0] & 5) throw u[1]; return { value: u[0] ? u[1] : void 0, done: !0 } } } function Wl(e) { var t = typeof Symbol == "function" && Symbol.iterator, n = t && e[t], r = 0; if (n) return n.call(e); if (e && typeof e.length == "number") return { next: function () { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") } function Fo(e, t) { var n = typeof Symbol == "function" && e[Symbol.iterator]; if (!n) return e; var r = n.call(e), i, o = [], s; try { for (; (t === void 0 || t-- > 0) && !(i = r.next()).done;)o.push(i.value) } catch (a) { s = { error: a } } finally { try { i && !i.done && (n = r.return) && n.call(r) } finally { if (s) throw s.error } } return o } function zo(e, t, n) { if (n || arguments.length === 2) for (var r = 0, i = t.length, o; r < i; r++)(o || !(r in t)) && (o || (o = Array.prototype.slice.call(t, 0, r)), o[r] = t[r]); return e.concat(o || Array.prototype.slice.call(t)) } function Us(e) { return this instanceof Us ? (this.v = e, this) : new Us(e) } function eL(e, t, n) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var r = n.apply(e, t || []), i, o = []; return i = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), a("next"), a("throw"), a("return", s), i[Symbol.asyncIterator] = function () { return this }, i; function s(p) { return function (m) { return Promise.resolve(m).then(p, d) } } function a(p, m) { r[p] && (i[p] = function (v) { return new Promise(function (x, g) { o.push([p, v, x, g]) > 1 || l(p, v) }) }, m && (i[p] = m(i[p]))) } function l(p, m) { try { u(r[p](m)) } catch (v) { f(o[0][3], v) } } function u(p) { p.value instanceof Us ? Promise.resolve(p.value.v).then(c, d) : f(o[0][2], p) } function c(p) { l("next", p) } function d(p) { l("throw", p) } function f(p, m) { p(m), o.shift(), o.length && l(o[0][0], o[0][1]) } } function tL(e) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var t = e[Symbol.asyncIterator], n; return t ? t.call(e) : (e = typeof Wl == "function" ? Wl(e) : e[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function () { return this }, n); function r(o) { n[o] = e[o] && function (s) { return new Promise(function (a, l) { s = e[o](s), i(a, l, s.done, s.value) }) } } function i(o, s, a, l) { Promise.resolve(l).then(function (u) { o({ value: u, done: a }) }, s) } } function nL(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object") } function XT(e, t, n) { nL(e, t), t.set(e, n) } const JT = typeof document < "u" ? se.useLayoutEffect : () => { }; function rL(e) { const t = S.useRef(null); return JT(() => { t.current = e }, [e]), S.useCallback((...n) => { const r = t.current; return r == null ? void 0 : r(...n) }, []) } let Nb = new Map; function iL(e, t) { if (e === t) return e; let n = Nb.get(e); if (n) return n.forEach(i => i(t)), t; let r = Nb.get(t); return r ? (r.forEach(i => i(e)), e) : t } function ni(...e) { return (...t) => { for (let n of e) typeof n == "function" && n(...t) } } const oL = e => { var t; return (t = e == null ? void 0 : e.ownerDocument) !== null && t !== void 0 ? t : document }, sL = e => e && "window" in e && e.window === e ? e : oL(e).defaultView || window; function ZT(e) { var t, n, r = ""; if (typeof e == "string" || typeof e == "number") r += e; else if (typeof e == "object") if (Array.isArray(e)) { var i = e.length; for (t = 0; t < i; t++)e[t] && (n = ZT(e[t])) && (r && (r += " "), r += n) } else for (n in e) e[n] && (r && (r += " "), r += n); return r } function aL() { for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++)(e = arguments[n]) && (t = ZT(e)) && (r && (r += " "), r += t); return r } function tt(...e) { let t = { ...e[0] }; for (let n = 1; n < e.length; n++) { let r = e[n]; for (let i in r) { let o = t[i], s = r[i]; typeof o == "function" && typeof s == "function" && i[0] === "o" && i[1] === "n" && i.charCodeAt(2) >= 65 && i.charCodeAt(2) <= 90 ? t[i] = ni(o, s) : (i === "className" || i === "UNSAFE_className") && typeof o == "string" && typeof s == "string" ? t[i] = aL(o, s) : i === "id" && o && s ? t.id = iL(o, s) : t[i] = s !== void 0 ? s : o } } return t } const lL = new Set(["id"]), uL = new Set(["aria-label", "aria-labelledby", "aria-describedby", "aria-details"]), cL = new Set(["href", "hrefLang", "target", "rel", "download", "ping", "referrerPolicy"]), dL = /^(data-.*)$/; function Hv(e, t = {}) { let { labelable: n, isLink: r, propNames: i } = t, o = {}; for (const s in e) Object.prototype.hasOwnProperty.call(e, s) && (lL.has(s) || n && uL.has(s) || r && cL.has(s) || i != null && i.has(s) || dL.test(s)) && (o[s] = e[s]); return o } function fL(e) { if (pL()) e.focus({ preventScroll: !0 }); else { let t = hL(e); e.focus(), mL(t) } } let sc = null; function pL() { if (sc == null) { sc = !1; try { document.createElement("div").focus({ get preventScroll() { return sc = !0, !0 } }) } catch { } } return sc } function hL(e) { let t = e.parentNode, n = [], r = document.scrollingElement || document.documentElement; for (; t instanceof HTMLElement && t !== r;)(t.offsetHeight < t.scrollHeight || t.offsetWidth < t.scrollWidth) && n.push({ element: t, scrollTop: t.scrollTop, scrollLeft: t.scrollLeft }), t = t.parentNode; return r instanceof HTMLElement && n.push({ element: r, scrollTop: r.scrollTop, scrollLeft: r.scrollLeft }), n } function mL(e) { for (let { element: t, scrollTop: n, scrollLeft: r } of e) t.scrollTop = n, t.scrollLeft = r } function Mf(e) { var t; return typeof window > "u" || window.navigator == null ? !1 : ((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.brands.some(n => e.test(n.brand))) || e.test(window.navigator.userAgent) } function Wv(e) { var t; return typeof window < "u" && window.navigator != null ? e.test(((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.platform) || window.navigator.platform) : !1 } function Zi(e) { let t = null; return () => (t == null && (t = e()), t) } const $m = Zi(function () { return Wv(/^Mac/i) }), gL = Zi(function () { return Wv(/^iPhone/i) }), eC = Zi(function () { return Wv(/^iPad/i) || $m() && navigator.maxTouchPoints > 1 }), tC = Zi(function () { return gL() || eC() }), vL = Zi(function () { return Mf(/AppleWebKit/i) && !yL() }), yL = Zi(function () { return Mf(/Chrome/i) }), bL = Zi(function () { return Mf(/Android/i) }), wL = Zi(function () { return Mf(/Firefox/i) }), nC = S.createContext({ isNative: !0, open: EL, useHref: e => e }); function xL(e) { let { children: t, navigate: n, useHref: r } = e, i = S.useMemo(() => ({ isNative: !1, open: (o, s, a, l) => { iC(o, u => { rC(u, s) ? n(a, l) : Gl(u, s) }) }, useHref: r || (o => o) }), [n, r]); return se.createElement(nC.Provider, { value: i }, t) } function SL() { return S.useContext(nC) } function rC(e, t) { let n = e.getAttribute("target"); return (!n || n === "_self") && e.origin === location.origin && !e.hasAttribute("download") && !t.metaKey && !t.ctrlKey && !t.altKey && !t.shiftKey } function Gl(e, t, n = !0) { var r, i; let { metaKey: o, ctrlKey: s, altKey: a, shiftKey: l } = t; wL() && (!((i = window.event) === null || i === void 0 || (r = i.type) === null || r === void 0) && r.startsWith("key")) && e.target === "_blank" && ($m() ? o = !0 : s = !0); let u = vL() && $m() && !eC() ? new KeyboardEvent("keydown", { keyIdentifier: "Enter", metaKey: o, ctrlKey: s, altKey: a, shiftKey: l }) : new MouseEvent("click", { metaKey: o, ctrlKey: s, altKey: a, shiftKey: l, bubbles: !0, cancelable: !0 }); Gl.isOpening = n, fL(e), e.dispatchEvent(u), Gl.isOpening = !1 } Gl.isOpening = !1; function iC(e, t) { if (e instanceof HTMLAnchorElement) t(e); else if (e.hasAttribute("data-href")) { let n = document.createElement("a"); n.href = e.getAttribute("data-href"), e.hasAttribute("data-target") && (n.target = e.getAttribute("data-target")), e.hasAttribute("data-rel") && (n.rel = e.getAttribute("data-rel")), e.hasAttribute("data-download") && (n.download = e.getAttribute("data-download")), e.hasAttribute("data-ping") && (n.ping = e.getAttribute("data-ping")), e.hasAttribute("data-referrer-policy") && (n.referrerPolicy = e.getAttribute("data-referrer-policy")), e.appendChild(n), t(n), e.removeChild(n) } } function EL(e, t) { iC(e, n => Gl(n, t)) } function TL() { return typeof window.ResizeObserver < "u" } function CL(e) { const { ref: t, box: n, onResize: r } = e; S.useEffect(() => { let i = t == null ? void 0 : t.current; if (i) if (TL()) { const o = new window.ResizeObserver(s => { s.length && r() }); return o.observe(i, { box: n }), () => { i && o.unobserve(i) } } else return window.addEventListener("resize", r, !1), () => { window.removeEventListener("resize", r, !1) } }, [r, t, n]) } function Ob(e, t) { if (!e) return !1; let n = window.getComputedStyle(e), r = /(auto|scroll)/.test(n.overflow + n.overflowX + n.overflowY); return r && t && (r = e.scrollHeight !== e.clientHeight || e.scrollWidth !== e.clientWidth), r } function oC(e, t) { let n = e; for (Ob(n, t) && (n = n.parentElement); n && !Ob(n, t);)n = n.parentElement; return n || document.scrollingElement || document.documentElement } function PL(e, t, n) { let r = S.useRef(t), i = rL(() => { n && n(r.current) }); S.useEffect(() => { var o; let s = e == null || (o = e.current) === null || o === void 0 ? void 0 : o.form; return s == null || s.addEventListener("reset", i), () => { s == null || s.removeEventListener("reset", i) } }, [e, i]) } function kf(e, t, n) { let [r, i] = S.useState(e || t), o = S.useRef(e !== void 0), s = e !== void 0; S.useEffect(() => { let u = o.current; u !== s && console.warn(`WARN: A component changed from ${u ? "controlled" : "uncontrolled"} to ${s ? "controlled" : "uncontrolled"}.`), o.current = s }, [s]); let a = s ? e : r, l = S.useCallback((u, ...c) => { let d = (f, ...p) => { n && (Object.is(a, f) || n(f, ...p)), s || (a = f) }; typeof u == "function" ? (console.warn("We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320"), i((p, ...m) => { let v = u(s ? a : p, ...m); return d(v, ...c), s ? p : v })) : (s || i(u), d(u, ...c)) }, [s, a, n]); return [a, l] } const fr = typeof document < "u" ? se.useLayoutEffect : () => { }; let jb = new Map; function $L(e, t) { if (e === t) return e; let n = jb.get(e); if (n) return n.forEach(i => i(t)), t; let r = jb.get(t); return r ? (r.forEach(i => i(e)), e) : t } function AL(...e) { return (...t) => { for (let n of e) typeof n == "function" && n(...t) } } const $n = e => { var t; return (t = e == null ? void 0 : e.ownerDocument) !== null && t !== void 0 ? t : document }, ML = e => e && "window" in e && e.window === e ? e : $n(e).defaultView || window; function sC(e) { var t, n, r = ""; if (typeof e == "string" || typeof e == "number") r += e; else if (typeof e == "object") if (Array.isArray(e)) { var i = e.length; for (t = 0; t < i; t++)e[t] && (n = sC(e[t])) && (r && (r += " "), r += n) } else for (n in e) e[n] && (r && (r += " "), r += n); return r } function kL() { for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++)(e = arguments[n]) && (t = sC(e)) && (r && (r += " "), r += t); return r } function Ib(...e) { let t = { ...e[0] }; for (let n = 1; n < e.length; n++) { let r = e[n]; for (let i in r) { let o = t[i], s = r[i]; typeof o == "function" && typeof s == "function" && i[0] === "o" && i[1] === "n" && i.charCodeAt(2) >= 65 && i.charCodeAt(2) <= 90 ? t[i] = AL(o, s) : (i === "className" || i === "UNSAFE_className") && typeof o == "string" && typeof s == "string" ? t[i] = kL(o, s) : i === "id" && o && s ? t.id = $L(o, s) : t[i] = s !== void 0 ? s : o } } return t } function Db(e) { if (_L()) e.focus({ preventScroll: !0 }); else { let t = RL(e); e.focus(), LL(t) } } let ac = null; function _L() { if (ac == null) { ac = !1; try { document.createElement("div").focus({ get preventScroll() { return ac = !0, !0 } }) } catch { } } return ac } function RL(e) { let t = e.parentNode, n = [], r = document.scrollingElement || document.documentElement; for (; t instanceof HTMLElement && t !== r;)(t.offsetHeight < t.scrollHeight || t.offsetWidth < t.scrollWidth) && n.push({ element: t, scrollTop: t.scrollTop, scrollLeft: t.scrollLeft }), t = t.parentNode; return r instanceof HTMLElement && n.push({ element: r, scrollTop: r.scrollTop, scrollLeft: r.scrollLeft }), n } function LL(e) { for (let { element: t, scrollTop: n, scrollLeft: r } of e) t.scrollTop = n, t.scrollLeft = r } let fs = new Map, Am = new Set; function Fb() { if (typeof window > "u") return; function e(r) { return "propertyName" in r } let t = r => { if (!e(r) || !r.target) return; let i = fs.get(r.target); i || (i = new Set, fs.set(r.target, i), r.target.addEventListener("transitioncancel", n, { once: !0 })), i.add(r.propertyName) }, n = r => { if (!e(r) || !r.target) return; let i = fs.get(r.target); if (i && (i.delete(r.propertyName), i.size === 0 && (r.target.removeEventListener("transitioncancel", n), fs.delete(r.target)), fs.size === 0)) { for (let o of Am) o(); Am.clear() } }; document.body.addEventListener("transitionrun", t), document.body.addEventListener("transitionend", n) } typeof document < "u" && (document.readyState !== "loading" ? Fb() : document.addEventListener("DOMContentLoaded", Fb)); function NL(e) { requestAnimationFrame(() => { fs.size === 0 ? e() : Am.add(e) }) } function OL(e, t) { fr(() => { if (e && e.ref && t) return e.ref.current = t.current, () => { e.ref && (e.ref.current = null) } }) } const Gv = typeof document < "u" ? se.useLayoutEffect : () => { }; function ps(e) { const t = S.useRef(null); return Gv(() => { t.current = e }, [e]), S.useCallback((...n) => { const r = t.current; return r == null ? void 0 : r(...n) }, []) } let zb = new Map; function jL(e, t) { if (e === t) return e; let n = zb.get(e); if (n) return n.forEach(i => i(t)), t; let r = zb.get(t); return r ? (r.forEach(i => i(e)), e) : t } function aC(...e) { return (...t) => { for (let n of e) typeof n == "function" && n(...t) } } const qn = e => { var t; return (t = e == null ? void 0 : e.ownerDocument) !== null && t !== void 0 ? t : document }, Cr = e => e && "window" in e && e.window === e ? e : qn(e).defaultView || window; function lC(e) { var t, n, r = ""; if (typeof e == "string" || typeof e == "number") r += e; else if (typeof e == "object") if (Array.isArray(e)) { var i = e.length; for (t = 0; t < i; t++)e[t] && (n = lC(e[t])) && (r && (r += " "), r += n) } else for (n in e) e[n] && (r && (r += " "), r += n); return r } function IL() { for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++)(e = arguments[n]) && (t = lC(e)) && (r && (r += " "), r += t); return r } function uC(...e) { let t = { ...e[0] }; for (let n = 1; n < e.length; n++) { let r = e[n]; for (let i in r) { let o = t[i], s = r[i]; typeof o == "function" && typeof s == "function" && i[0] === "o" && i[1] === "n" && i.charCodeAt(2) >= 65 && i.charCodeAt(2) <= 90 ? t[i] = aC(o, s) : (i === "className" || i === "UNSAFE_className") && typeof o == "string" && typeof s == "string" ? t[i] = IL(o, s) : i === "id" && o && s ? t.id = jL(o, s) : t[i] = s !== void 0 ? s : o } } return t } function tl(e) { if (DL()) e.focus({ preventScroll: !0 }); else { let t = FL(e); e.focus(), zL(t) } } let lc = null; function DL() { if (lc == null) { lc = !1; try { document.createElement("div").focus({ get preventScroll() { return lc = !0, !0 } }) } catch { } } return lc } function FL(e) { let t = e.parentNode, n = [], r = document.scrollingElement || document.documentElement; for (; t instanceof HTMLElement && t !== r;)(t.offsetHeight < t.scrollHeight || t.offsetWidth < t.scrollWidth) && n.push({ element: t, scrollTop: t.scrollTop, scrollLeft: t.scrollLeft }), t = t.parentNode; return r instanceof HTMLElement && n.push({ element: r, scrollTop: r.scrollTop, scrollLeft: r.scrollLeft }), n } function zL(e) { for (let { element: t, scrollTop: n, scrollLeft: r } of e) t.scrollTop = n, t.scrollLeft = r } function _f(e) { var t; return typeof window > "u" || window.navigator == null ? !1 : ((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.brands.some(n => e.test(n.brand))) || e.test(window.navigator.userAgent) } function Kv(e) { var t; return typeof window < "u" && window.navigator != null ? e.test(((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.platform) || window.navigator.platform) : !1 } function eo(e) { let t = null; return () => (t == null && (t = e()), t) } const Kl = eo(function () { return Kv(/^Mac/i) }), VL = eo(function () { return Kv(/^iPhone/i) }), cC = eo(function () { return Kv(/^iPad/i) || Kl() && navigator.maxTouchPoints > 1 }), dC = eo(function () { return VL() || cC() }), BL = eo(function () { return _f(/AppleWebKit/i) && !UL() }), UL = eo(function () { return _f(/Chrome/i) }), fC = eo(function () { return _f(/Android/i) }), HL = eo(function () { return _f(/Firefox/i) }); function ql(e, t, n = !0) { var r, i; let { metaKey: o, ctrlKey: s, altKey: a, shiftKey: l } = t; HL() && (!((i = window.event) === null || i === void 0 || (r = i.type) === null || r === void 0) && r.startsWith("key")) && e.target === "_blank" && (Kl() ? o = !0 : s = !0); let u = BL() && Kl() && !cC() ? new KeyboardEvent("keydown", { keyIdentifier: "Enter", metaKey: o, ctrlKey: s, altKey: a, shiftKey: l }) : new MouseEvent("click", { metaKey: o, ctrlKey: s, altKey: a, shiftKey: l, bubbles: !0, cancelable: !0 }); ql.isOpening = n, tl(e), e.dispatchEvent(u), ql.isOpening = !1 } ql.isOpening = !1; let hs = new Map, Mm = new Set; function Vb() { if (typeof window > "u") return; function e(r) { return "propertyName" in r } let t = r => { if (!e(r) || !r.target) return; let i = hs.get(r.target); i || (i = new Set, hs.set(r.target, i), r.target.addEventListener("transitioncancel", n, { once: !0 })), i.add(r.propertyName) }, n = r => { if (!e(r) || !r.target) return; let i = hs.get(r.target); if (i && (i.delete(r.propertyName), i.size === 0 && (r.target.removeEventListener("transitioncancel", n), hs.delete(r.target)), hs.size === 0)) { for (let o of Mm) o(); Mm.clear() } }; document.body.addEventListener("transitionrun", t), document.body.addEventListener("transitionend", n) } typeof document < "u" && (document.readyState !== "loading" ? Vb() : document.addEventListener("DOMContentLoaded", Vb)); function WL(e) { requestAnimationFrame(() => { hs.size === 0 ? e() : Mm.add(e) }) } function GL() { let e = S.useRef(new Map), t = S.useCallback((i, o, s, a) => { let l = a != null && a.once ? (...u) => { e.current.delete(s), s(...u) } : s; e.current.set(s, { type: o, eventTarget: i, fn: l, options: a }), i.addEventListener(o, s, a) }, []), n = S.useCallback((i, o, s, a) => { var l; let u = ((l = e.current.get(s)) === null || l === void 0 ? void 0 : l.fn) || s; i.removeEventListener(o, u, a), e.current.delete(s) }, []), r = S.useCallback(() => { e.current.forEach((i, o) => { n(i.eventTarget, i.type, o, i.options) }) }, [n]); return S.useEffect(() => r, [r]), { addGlobalListener: t, removeGlobalListener: n, removeAllGlobalListeners: r } } function KL(e, t) { Gv(() => { if (e && e.ref && t) return e.ref.current = t.current, () => { e.ref && (e.ref.current = null) } }) } function km(e) { return e.mozInputSource === 0 && e.isTrusted ? !0 : fC() && e.pointerType ? e.type === "click" && e.buttons === 1 : e.detail === 0 && !e.pointerType } function qL(e) { return !fC() && e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === "mouse" } let Ms = "default", _m = "", Gc = new WeakMap; function Bb(e) { if (dC()) { if (Ms === "default") { const t = qn(e); _m = t.documentElement.style.webkitUserSelect, t.documentElement.style.webkitUserSelect = "none" } Ms = "disabled" } else (e instanceof HTMLElement || e instanceof SVGElement) && (Gc.set(e, e.style.userSelect), e.style.userSelect = "none") } function uc(e) { if (dC()) { if (Ms !== "disabled") return; Ms = "restoring", setTimeout(() => { WL(() => { if (Ms === "restoring") { const t = qn(e); t.documentElement.style.webkitUserSelect === "none" && (t.documentElement.style.webkitUserSelect = _m || ""), _m = "", Ms = "default" } }) }, 300) } else if ((e instanceof HTMLElement || e instanceof SVGElement) && e && Gc.has(e)) { let t = Gc.get(e); e.style.userSelect === "none" && (e.style.userSelect = t), e.getAttribute("style") === "" && e.removeAttribute("style"), Gc.delete(e) } } const qv = se.createContext({ register: () => { } }); qv.displayName = "PressResponderContext"; function YL(e, t) { return t.get ? t.get.call(e) : t.value } function pC(e, t, n) { if (!t.has(e)) throw new TypeError("attempted to " + n + " private field on non-instance"); return t.get(e) } function hC(e, t) { var n = pC(e, t, "get"); return YL(e, n) } function QL(e, t, n) { if (t.set) t.set.call(e, n); else { if (!t.writable) throw new TypeError("attempted to set read only private field"); t.value = n } } function Md(e, t, n) { var r = pC(e, t, "set"); return QL(e, r, n), n } function XL(e) { let t = S.useContext(qv); if (t) { let { register: n, ...r } = t; e = uC(r, e), n() } return KL(t, e.ref), e } var cc = new WeakMap; let dc = class { continuePropagation() { Md(this, cc, !1) } get shouldStopPropagation() { return hC(this, cc) } constructor(t, n, r, i) { XT(this, cc, { writable: !0, value: void 0 }), Md(this, cc, !0); var o; let s = (o = i == null ? void 0 : i.target) !== null && o !== void 0 ? o : r.currentTarget; const a = s == null ? void 0 : s.getBoundingClientRect(); let l, u = 0, c, d = null; r.clientX != null && r.clientY != null && (c = r.clientX, d = r.clientY), a && (c != null && d != null ? (l = c - a.left, u = d - a.top) : (l = a.width / 2, u = a.height / 2)), this.type = t, this.pointerType = n, this.target = r.currentTarget, this.shiftKey = r.shiftKey, this.metaKey = r.metaKey, this.ctrlKey = r.ctrlKey, this.altKey = r.altKey, this.x = l, this.y = u } }; const Ub = Symbol("linkClicked"); function Pu(e) { let { onPress: t, onPressChange: n, onPressStart: r, onPressEnd: i, onPressUp: o, isDisabled: s, isPressed: a, preventFocusOnPress: l, shouldCancelOnPointerExit: u, allowTextSelectionOnPress: c, ref: d, ...f } = XL(e), [p, m] = S.useState(!1), v = S.useRef({ isPressed: !1, ignoreEmulatedMouseEvents: !1, ignoreClickAfterPress: !1, didFirePressStart: !1, isTriggeringEvent: !1, activePointerId: null, target: null, isOverTarget: !1, pointerType: null }), { addGlobalListener: x, removeAllGlobalListeners: g } = GL(), h = ps((b, M) => { let R = v.current; if (s || R.didFirePressStart) return !1; let A = !0; if (R.isTriggeringEvent = !0, r) { let _ = new dc("pressstart", M, b); r(_), A = _.shouldStopPropagation } return n && n(!0), R.isTriggeringEvent = !1, R.didFirePressStart = !0, m(!0), A }), y = ps((b, M, R = !0) => { let A = v.current; if (!A.didFirePressStart) return !1; A.ignoreClickAfterPress = !0, A.didFirePressStart = !1, A.isTriggeringEvent = !0; let _ = !0; if (i) { let C = new dc("pressend", M, b); i(C), _ = C.shouldStopPropagation } if (n && n(!1), m(!1), t && R && !s) { let C = new dc("press", M, b); t(C), _ && (_ = C.shouldStopPropagation) } return A.isTriggeringEvent = !1, _ }), E = ps((b, M) => { let R = v.current; if (s) return !1; if (o) { R.isTriggeringEvent = !0; let A = new dc("pressup", M, b); return o(A), R.isTriggeringEvent = !1, A.shouldStopPropagation } return !0 }), P = ps(b => { let M = v.current; M.isPressed && M.target && (M.isOverTarget && M.pointerType != null && y(jr(M.target, b), M.pointerType, !1), M.isPressed = !1, M.isOverTarget = !1, M.activePointerId = null, M.pointerType = null, g(), c || uc(M.target)) }), $ = ps(b => { u && P(b) }), L = S.useMemo(() => { let b = v.current, M = { onKeyDown(A) { if (kp(A.nativeEvent, A.currentTarget) && A.currentTarget.contains(A.target)) { var _; Wb(A.target, A.key) && A.preventDefault(); let C = !0; if (!b.isPressed && !A.repeat) { b.target = A.currentTarget, b.isPressed = !0, C = h(A, "keyboard"); let k = A.currentTarget, O = U => { kp(U, k) && !U.repeat && k.contains(U.target) && b.target && E(jr(b.target, U), "keyboard") }; x(qn(A.currentTarget), "keyup", aC(O, R), !0) } C && A.stopPropagation(), A.metaKey && Kl() && ((_ = b.metaKeyEvents) === null || _ === void 0 || _.set(A.key, A.nativeEvent)) } else A.key === "Meta" && (b.metaKeyEvents = new Map) }, onClick(A) { if (!(A && !A.currentTarget.contains(A.target)) && A && A.button === 0 && !b.isTriggeringEvent && !ql.isOpening) { let _ = !0; if (s && A.preventDefault(), !b.ignoreClickAfterPress && !b.ignoreEmulatedMouseEvents && !b.isPressed && (b.pointerType === "virtual" || km(A.nativeEvent))) { !s && !l && tl(A.currentTarget); let C = h(A, "virtual"), k = E(A, "virtual"), O = y(A, "virtual"); _ = C && k && O } b.ignoreEmulatedMouseEvents = !1, b.ignoreClickAfterPress = !1, _ && A.stopPropagation() } } }, R = A => { var _; if (b.isPressed && b.target && kp(A, b.target)) { var C; Wb(A.target, A.key) && A.preventDefault(); let O = A.target; y(jr(b.target, A), "keyboard", b.target.contains(O)), g(), A.key !== "Enter" && Yv(b.target) && b.target.contains(O) && !A[Ub] && (A[Ub] = !0, ql(b.target, A, !1)), b.isPressed = !1, (C = b.metaKeyEvents) === null || C === void 0 || C.delete(A.key) } else if (A.key === "Meta" && (!((_ = b.metaKeyEvents) === null || _ === void 0) && _.size)) { var k; let O = b.metaKeyEvents; b.metaKeyEvents = void 0; for (let U of O.values()) (k = b.target) === null || k === void 0 || k.dispatchEvent(new KeyboardEvent("keyup", U)) } }; if (typeof PointerEvent < "u") { M.onPointerDown = O => { if (O.button !== 0 || !O.currentTarget.contains(O.target)) return; if (qL(O.nativeEvent)) { b.pointerType = "virtual"; return } _p(O.currentTarget) && O.preventDefault(), b.pointerType = O.pointerType; let U = !0; b.isPressed || (b.isPressed = !0, b.isOverTarget = !0, b.activePointerId = O.pointerId, b.target = O.currentTarget, !s && !l && tl(O.currentTarget), c || Bb(b.target), U = h(O, b.pointerType), x(qn(O.currentTarget), "pointermove", A, !1), x(qn(O.currentTarget), "pointerup", _, !1), x(qn(O.currentTarget), "pointercancel", k, !1)), U && O.stopPropagation() }, M.onMouseDown = O => { O.currentTarget.contains(O.target) && O.button === 0 && (_p(O.currentTarget) && O.preventDefault(), O.stopPropagation()) }, M.onPointerUp = O => { !O.currentTarget.contains(O.target) || b.pointerType === "virtual" || O.button === 0 && as(O, O.currentTarget) && E(O, b.pointerType || O.pointerType) }; let A = O => { O.pointerId === b.activePointerId && (b.target && as(O, b.target) ? !b.isOverTarget && b.pointerType != null && (b.isOverTarget = !0, h(jr(b.target, O), b.pointerType)) : b.target && b.isOverTarget && b.pointerType != null && (b.isOverTarget = !1, y(jr(b.target, O), b.pointerType, !1), $(O))) }, _ = O => { O.pointerId === b.activePointerId && b.isPressed && O.button === 0 && b.target && (as(O, b.target) && b.pointerType != null ? y(jr(b.target, O), b.pointerType) : b.isOverTarget && b.pointerType != null && y(jr(b.target, O), b.pointerType, !1), b.isPressed = !1, b.isOverTarget = !1, b.activePointerId = null, b.pointerType = null, g(), c || uc(b.target), "ontouchend" in b.target && O.pointerType !== "mouse" && x(b.target, "touchend", C, { once: !0 })) }, C = O => { mC(O.currentTarget) && O.preventDefault() }, k = O => { P(O) }; M.onDragStart = O => { O.currentTarget.contains(O.target) && P(O) } } else { M.onMouseDown = C => { if (C.button !== 0 || !C.currentTarget.contains(C.target)) return; if (_p(C.currentTarget) && C.preventDefault(), b.ignoreEmulatedMouseEvents) { C.stopPropagation(); return } b.isPressed = !0, b.isOverTarget = !0, b.target = C.currentTarget, b.pointerType = km(C.nativeEvent) ? "virtual" : "mouse", !s && !l && tl(C.currentTarget), h(C, b.pointerType) && C.stopPropagation(), x(qn(C.currentTarget), "mouseup", A, !1) }, M.onMouseEnter = C => { if (!C.currentTarget.contains(C.target)) return; let k = !0; b.isPressed && !b.ignoreEmulatedMouseEvents && b.pointerType != null && (b.isOverTarget = !0, k = h(C, b.pointerType)), k && C.stopPropagation() }, M.onMouseLeave = C => { if (!C.currentTarget.contains(C.target)) return; let k = !0; b.isPressed && !b.ignoreEmulatedMouseEvents && b.pointerType != null && (b.isOverTarget = !1, k = y(C, b.pointerType, !1), $(C)), k && C.stopPropagation() }, M.onMouseUp = C => { C.currentTarget.contains(C.target) && !b.ignoreEmulatedMouseEvents && C.button === 0 && E(C, b.pointerType || "mouse") }; let A = C => { if (C.button === 0) { if (b.isPressed = !1, g(), b.ignoreEmulatedMouseEvents) { b.ignoreEmulatedMouseEvents = !1; return } b.target && as(C, b.target) && b.pointerType != null ? y(jr(b.target, C), b.pointerType) : b.target && b.isOverTarget && b.pointerType != null && y(jr(b.target, C), b.pointerType, !1), b.isOverTarget = !1 } }; M.onTouchStart = C => { if (!C.currentTarget.contains(C.target)) return; let k = JL(C.nativeEvent); if (!k) return; b.activePointerId = k.identifier, b.ignoreEmulatedMouseEvents = !0, b.isOverTarget = !0, b.isPressed = !0, b.target = C.currentTarget, b.pointerType = "touch", !s && !l && tl(C.currentTarget), c || Bb(b.target), h(fi(b.target, C), b.pointerType) && C.stopPropagation(), x(Cr(C.currentTarget), "scroll", _, !0) }, M.onTouchMove = C => { if (!C.currentTarget.contains(C.target)) return; if (!b.isPressed) { C.stopPropagation(); return } let k = Hb(C.nativeEvent, b.activePointerId), O = !0; k && as(k, C.currentTarget) ? !b.isOverTarget && b.pointerType != null && (b.isOverTarget = !0, O = h(fi(b.target, C), b.pointerType)) : b.isOverTarget && b.pointerType != null && (b.isOverTarget = !1, O = y(fi(b.target, C), b.pointerType, !1), $(fi(b.target, C))), O && C.stopPropagation() }, M.onTouchEnd = C => { if (!C.currentTarget.contains(C.target)) return; if (!b.isPressed) { C.stopPropagation(); return } let k = Hb(C.nativeEvent, b.activePointerId), O = !0; k && as(k, C.currentTarget) && b.pointerType != null ? (E(fi(b.target, C), b.pointerType), O = y(fi(b.target, C), b.pointerType)) : b.isOverTarget && b.pointerType != null && (O = y(fi(b.target, C), b.pointerType, !1)), O && C.stopPropagation(), b.isPressed = !1, b.activePointerId = null, b.isOverTarget = !1, b.ignoreEmulatedMouseEvents = !0, b.target && !c && uc(b.target), g() }, M.onTouchCancel = C => { C.currentTarget.contains(C.target) && (C.stopPropagation(), b.isPressed && P(fi(b.target, C))) }; let _ = C => { b.isPressed && C.target.contains(b.target) && P({ currentTarget: b.target, shiftKey: !1, ctrlKey: !1, metaKey: !1, altKey: !1 }) }; M.onDragStart = C => { C.currentTarget.contains(C.target) && P(C) } } return M }, [x, s, l, g, c, P, $, y, h, E]); return S.useEffect(() => () => { var b; c || uc((b = v.current.target) !== null && b !== void 0 ? b : void 0) }, [c]), { isPressed: a || p, pressProps: uC(f, L) } } function Yv(e) { return e.tagName === "A" && e.hasAttribute("href") } function kp(e, t) { const { key: n, code: r } = e, i = t, o = i.getAttribute("role"); return (n === "Enter" || n === " " || n === "Spacebar" || r === "Space") && !(i instanceof Cr(i).HTMLInputElement && !gC(i, n) || i instanceof Cr(i).HTMLTextAreaElement || i.isContentEditable) && !((o === "link" || !o && Yv(i)) && n !== "Enter") } function JL(e) { const { targetTouches: t } = e; return t.length > 0 ? t[0] : null } function Hb(e, t) { const n = e.changedTouches; for (let r = 0; r < n.length; r++) { const i = n[r]; if (i.identifier === t) return i } return null } function fi(e, t) { let n = 0, r = 0; return t.targetTouches && t.targetTouches.length === 1 && (n = t.targetTouches[0].clientX, r = t.targetTouches[0].clientY), { currentTarget: e, shiftKey: t.shiftKey, ctrlKey: t.ctrlKey, metaKey: t.metaKey, altKey: t.altKey, clientX: n, clientY: r } } function jr(e, t) { let n = t.clientX, r = t.clientY; return { currentTarget: e, shiftKey: t.shiftKey, ctrlKey: t.ctrlKey, metaKey: t.metaKey, altKey: t.altKey, clientX: n, clientY: r } } function ZL(e) { let t = 0, n = 0; return e.width !== void 0 ? t = e.width / 2 : e.radiusX !== void 0 && (t = e.radiusX), e.height !== void 0 ? n = e.height / 2 : e.radiusY !== void 0 && (n = e.radiusY), { top: e.clientY - n, right: e.clientX + t, bottom: e.clientY + n, left: e.clientX - t } } function eN(e, t) { return !(e.left > t.right || t.left > e.right || e.top > t.bottom || t.top > e.bottom) } function as(e, t) { let n = t.getBoundingClientRect(), r = ZL(e); return eN(n, r) } function _p(e) { return !(e instanceof HTMLElement) || !e.hasAttribute("draggable") } function mC(e) { return e instanceof HTMLInputElement ? !1 : e instanceof HTMLButtonElement ? e.type !== "submit" && e.type !== "reset" : !Yv(e) } function Wb(e, t) { return e instanceof HTMLInputElement ? !gC(e, t) : mC(e) } const tN = new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]); function gC(e, t) { return e.type === "checkbox" || e.type === "radio" ? t === " " : tN.has(e.type) } function nN({ children: e }) { let t = S.useMemo(() => ({ register: () => { } }), []); return se.createElement(qv.Provider, { value: t }, e) } let rN = class { isDefaultPrevented() { return this.nativeEvent.defaultPrevented } preventDefault() { this.defaultPrevented = !0, this.nativeEvent.preventDefault() } stopPropagation() { this.nativeEvent.stopPropagation(), this.isPropagationStopped = () => !0 } isPropagationStopped() { return !1 } persist() { } constructor(t, n) { this.nativeEvent = n, this.target = n.target, this.currentTarget = n.currentTarget, this.relatedTarget = n.relatedTarget, this.bubbles = n.bubbles, this.cancelable = n.cancelable, this.defaultPrevented = n.defaultPrevented, this.eventPhase = n.eventPhase, this.isTrusted = n.isTrusted, this.timeStamp = n.timeStamp, this.type = t } }; function vC(e) { let t = S.useRef({ isFocused: !1, observer: null }); Gv(() => { const r = t.current; return () => { r.observer && (r.observer.disconnect(), r.observer = null) } }, []); let n = ps(r => { e == null || e(r) }); return S.useCallback(r => { if (r.target instanceof HTMLButtonElement || r.target instanceof HTMLInputElement || r.target instanceof HTMLTextAreaElement || r.target instanceof HTMLSelectElement) { t.current.isFocused = !0; let i = r.target, o = s => { t.current.isFocused = !1, i.disabled && n(new rN("blur", s)), t.current.observer && (t.current.observer.disconnect(), t.current.observer = null) }; i.addEventListener("focusout", o, { once: !0 }), t.current.observer = new MutationObserver(() => { if (t.current.isFocused && i.disabled) { var s; (s = t.current.observer) === null || s === void 0 || s.disconnect(); let a = i === document.activeElement ? null : document.activeElement; i.dispatchEvent(new FocusEvent("blur", { relatedTarget: a })), i.dispatchEvent(new FocusEvent("focusout", { bubbles: !0, relatedTarget: a })) } }), t.current.observer.observe(i, { attributes: !0, attributeFilter: ["disabled"] }) } }, [n]) } function yC(e) { let { isDisabled: t, onFocus: n, onBlur: r, onFocusChange: i } = e; const o = S.useCallback(l => { if (l.target === l.currentTarget) return r && r(l), i && i(!1), !0 }, [r, i]), s = vC(o), a = S.useCallback(l => { const u = qn(l.target); l.target === l.currentTarget && u.activeElement === l.target && (n && n(l), i && i(!0), s(l)) }, [i, n, s]); return { focusProps: { onFocus: !t && (n || i || r) ? a : void 0, onBlur: !t && (r || i) ? o : void 0 } } } let Qo = null, Rm = new Set, bl = new Map, Vo = !1, Lm = !1; const iN = { Tab: !0, Escape: !0 }; function Rf(e, t) { for (let n of Rm) n(e, t) } function oN(e) { return !(e.metaKey || !Kl() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta") } function kd(e) { Vo = !0, oN(e) && (Qo = "keyboard", Rf("keyboard", e)) } function Gn(e) { Qo = "pointer", (e.type === "mousedown" || e.type === "pointerdown") && (Vo = !0, Rf("pointer", e)) } function bC(e) { km(e) && (Vo = !0, Qo = "virtual") } function wC(e) { e.target === window || e.target === document || (!Vo && !Lm && (Qo = "virtual", Rf("virtual", e)), Vo = !1, Lm = !1) } function xC() { Vo = !1, Lm = !0 } function Nm(e) { if (typeof window > "u" || bl.get(Cr(e))) return; const t = Cr(e), n = qn(e); let r = t.HTMLElement.prototype.focus; t.HTMLElement.prototype.focus = function () { Vo = !0, r.apply(this, arguments) }, n.addEventListener("keydown", kd, !0), n.addEventListener("keyup", kd, !0), n.addEventListener("click", bC, !0), t.addEventListener("focus", wC, !0), t.addEventListener("blur", xC, !1), typeof PointerEvent < "u" ? (n.addEventListener("pointerdown", Gn, !0), n.addEventListener("pointermove", Gn, !0), n.addEventListener("pointerup", Gn, !0)) : (n.addEventListener("mousedown", Gn, !0), n.addEventListener("mousemove", Gn, !0), n.addEventListener("mouseup", Gn, !0)), t.addEventListener("beforeunload", () => { SC(e) }, { once: !0 }), bl.set(t, { focus: r }) } const SC = (e, t) => { const n = Cr(e), r = qn(e); t && r.removeEventListener("DOMContentLoaded", t), bl.has(n) && (n.HTMLElement.prototype.focus = bl.get(n).focus, r.removeEventListener("keydown", kd, !0), r.removeEventListener("keyup", kd, !0), r.removeEventListener("click", bC, !0), n.removeEventListener("focus", wC, !0), n.removeEventListener("blur", xC, !1), typeof PointerEvent < "u" ? (r.removeEventListener("pointerdown", Gn, !0), r.removeEventListener("pointermove", Gn, !0), r.removeEventListener("pointerup", Gn, !0)) : (r.removeEventListener("mousedown", Gn, !0), r.removeEventListener("mousemove", Gn, !0), r.removeEventListener("mouseup", Gn, !0)), bl.delete(n)) }; function sN(e) { const t = qn(e); let n; return t.readyState !== "loading" ? Nm(e) : (n = () => { Nm(e) }, t.addEventListener("DOMContentLoaded", n)), () => SC(e, n) } typeof document < "u" && sN(); function EC() { return Qo !== "pointer" } function aN() { return Qo } function lN(e) { Qo = e, Rf(e, null) } const uN = new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]); function cN(e, t, n) { var r; const i = typeof window < "u" ? Cr(n == null ? void 0 : n.target).HTMLInputElement : HTMLInputElement, o = typeof window < "u" ? Cr(n == null ? void 0 : n.target).HTMLTextAreaElement : HTMLTextAreaElement, s = typeof window < "u" ? Cr(n == null ? void 0 : n.target).HTMLElement : HTMLElement, a = typeof window < "u" ? Cr(n == null ? void 0 : n.target).KeyboardEvent : KeyboardEvent; return e = e || (n == null ? void 0 : n.target) instanceof i && !uN.has(n == null || (r = n.target) === null || r === void 0 ? void 0 : r.type) || (n == null ? void 0 : n.target) instanceof o || (n == null ? void 0 : n.target) instanceof s && (n == null ? void 0 : n.target.isContentEditable), !(e && t === "keyboard" && n instanceof a && !iN[n.key]) } function dN(e, t, n) { Nm(), S.useEffect(() => { let r = (i, o) => { cN(!!(n != null && n.isTextInput), i, o) && e(EC()) }; return Rm.add(r), () => { Rm.delete(r) } }, t) } function TC(e) { let { isDisabled: t, onBlurWithin: n, onFocusWithin: r, onFocusWithinChange: i } = e, o = S.useRef({ isFocusWithin: !1 }), s = S.useCallback(u => { o.current.isFocusWithin && !u.currentTarget.contains(u.relatedTarget) && (o.current.isFocusWithin = !1, n && n(u), i && i(!1)) }, [n, i, o]), a = vC(s), l = S.useCallback(u => { !o.current.isFocusWithin && document.activeElement === u.target && (r && r(u), i && i(!0), o.current.isFocusWithin = !0, a(u)) }, [r, i, a]); return t ? { focusWithinProps: { onFocus: void 0, onBlur: void 0 } } : { focusWithinProps: { onFocus: l, onBlur: s } } } let _d = !1, Rp = 0; function Om() { _d = !0, setTimeout(() => { _d = !1 }, 50) } function Gb(e) { e.pointerType === "touch" && Om() } function fN() { if (!(typeof document > "u")) return typeof PointerEvent < "u" ? document.addEventListener("pointerup", Gb) : document.addEventListener("touchend", Om), Rp++, () => { Rp--, !(Rp > 0) && (typeof PointerEvent < "u" ? document.removeEventListener("pointerup", Gb) : document.removeEventListener("touchend", Om)) } } function Bo(e) { let { onHoverStart: t, onHoverChange: n, onHoverEnd: r, isDisabled: i } = e, [o, s] = S.useState(!1), a = S.useRef({ isHovered: !1, ignoreEmulatedMouseEvents: !1, pointerType: "", target: null }).current; S.useEffect(fN, []); let { hoverProps: l, triggerHoverEnd: u } = S.useMemo(() => { let c = (p, m) => { if (a.pointerType = m, i || m === "touch" || a.isHovered || !p.currentTarget.contains(p.target)) return; a.isHovered = !0; let v = p.currentTarget; a.target = v, t && t({ type: "hoverstart", target: v, pointerType: m }), n && n(!0), s(!0) }, d = (p, m) => { if (a.pointerType = "", a.target = null, m === "touch" || !a.isHovered) return; a.isHovered = !1; let v = p.currentTarget; r && r({ type: "hoverend", target: v, pointerType: m }), n && n(!1), s(!1) }, f = {}; return typeof PointerEvent < "u" ? (f.onPointerEnter = p => { _d && p.pointerType === "mouse" || c(p, p.pointerType) }, f.onPointerLeave = p => { !i && p.currentTarget.contains(p.target) && d(p, p.pointerType) }) : (f.onTouchStart = () => { a.ignoreEmulatedMouseEvents = !0 }, f.onMouseEnter = p => { !a.ignoreEmulatedMouseEvents && !_d && c(p, "mouse"), a.ignoreEmulatedMouseEvents = !1 }, f.onMouseLeave = p => { !i && p.currentTarget.contains(p.target) && d(p, "mouse") }), { hoverProps: f, triggerHoverEnd: d } }, [t, n, r, i, a]); return S.useEffect(() => { i && u({ currentTarget: a.target }, a.pointerType) }, [i]), { hoverProps: l, isHovered: o } } function Kb(e) { if (!e) return; let t = !0; return n => { let r = { ...n, preventDefault() { n.preventDefault() }, isDefaultPrevented() { return n.isDefaultPrevented() }, stopPropagation() { console.error("stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.") }, continuePropagation() { t = !1 } }; e(r), t && n.stopPropagation() } } function pN(e) { return { keyboardProps: e.isDisabled ? {} : { onKeyDown: Kb(e.onKeyDown), onKeyUp: Kb(e.onKeyUp) } } } function CC(e) { const t = $n(e); if (aN() === "virtual") { let n = t.activeElement; NL(() => { t.activeElement === n && e.isConnected && Db(e) }) } else Db(e) } function hN(e) { const t = ML(e); if (!(e instanceof t.HTMLElement) && !(e instanceof t.SVGElement)) return !1; let { display: n, visibility: r } = e.style, i = n !== "none" && r !== "hidden" && r !== "collapse"; if (i) { const { getComputedStyle: o } = e.ownerDocument.defaultView; let { display: s, visibility: a } = o(e); i = s !== "none" && a !== "hidden" && a !== "collapse" } return i } function mN(e, t) { return !e.hasAttribute("hidden") && !e.hasAttribute("data-react-aria-prevent-focus") && (e.nodeName === "DETAILS" && t && t.nodeName !== "SUMMARY" ? e.hasAttribute("open") : !0) } function PC(e, t) { return e.nodeName !== "#comment" && hN(e) && mN(e, t) && (!e.parentElement || PC(e.parentElement, e)) } const qb = se.createContext(null), jm = "react-aria-focus-scope-restore"; let Ge = null; function gN(e) { let { children: t, contain: n, restoreFocus: r, autoFocus: i } = e, o = S.useRef(null), s = S.useRef(null), a = S.useRef([]), { parentNode: l } = S.useContext(qb) || {}, u = S.useMemo(() => new Dm({ scopeRef: a }), [a]); fr(() => { let f = l || Tt.root; if (Tt.getTreeNode(f.scopeRef) && Ge && !Rd(Ge, f.scopeRef)) { let p = Tt.getTreeNode(Ge); p && (f = p) } f.addChild(u), Tt.addNode(u) }, [u, l]), fr(() => { let f = Tt.getTreeNode(a); f && (f.contain = !!n) }, [n]), fr(() => { var f; let p = (f = o.current) === null || f === void 0 ? void 0 : f.nextSibling, m = [], v = x => x.stopPropagation(); for (; p && p !== s.current;)m.push(p), p.addEventListener(jm, v), p = p.nextSibling; return a.current = m, () => { for (let x of m) x.removeEventListener(jm, v) } }, [t]), SN(a, r, n), wN(a, n), EN(a, r, n), xN(a, i), S.useEffect(() => { const f = $n(a.current ? a.current[0] : void 0).activeElement; let p = null; if (er(f, a.current)) { for (let m of Tt.traverse()) m.scopeRef && er(f, m.scopeRef.current) && (p = m); p === Tt.getTreeNode(a) && (Ge = p.scopeRef) } }, [a]), fr(() => () => { var f, p, m; let v = (m = (p = Tt.getTreeNode(a)) === null || p === void 0 || (f = p.parent) === null || f === void 0 ? void 0 : f.scopeRef) !== null && m !== void 0 ? m : null; (a === Ge || Rd(a, Ge)) && (!v || Tt.getTreeNode(v)) && (Ge = v), Tt.removeTreeNode(a) }, [a]); let c = S.useMemo(() => vN(a), []), d = S.useMemo(() => ({ focusManager: c, parentNode: u }), [u, c]); return se.createElement(qb.Provider, { value: d }, se.createElement("span", { "data-focus-scope-start": !0, hidden: !0, ref: o }), t, se.createElement("span", { "data-focus-scope-end": !0, hidden: !0, ref: s })) } function vN(e) { return { focusNext(t = {}) { let n = e.current, { from: r, tabbable: i, wrap: o, accept: s } = t, a = r || $n(n[0]).activeElement, l = n[0].previousElementSibling, u = yo(n), c = Li(u, { tabbable: i, accept: s }, n); c.currentNode = er(a, n) ? a : l; let d = c.nextNode(); return !d && o && (c.currentNode = l, d = c.nextNode()), d && Kr(d, !0), d }, focusPrevious(t = {}) { let n = e.current, { from: r, tabbable: i, wrap: o, accept: s } = t, a = r || $n(n[0]).activeElement, l = n[n.length - 1].nextElementSibling, u = yo(n), c = Li(u, { tabbable: i, accept: s }, n); c.currentNode = er(a, n) ? a : l; let d = c.previousNode(); return !d && o && (c.currentNode = l, d = c.previousNode()), d && Kr(d, !0), d }, focusFirst(t = {}) { let n = e.current, { tabbable: r, accept: i } = t, o = yo(n), s = Li(o, { tabbable: r, accept: i }, n); s.currentNode = n[0].previousElementSibling; let a = s.nextNode(); return a && Kr(a, !0), a }, focusLast(t = {}) { let n = e.current, { tabbable: r, accept: i } = t, o = yo(n), s = Li(o, { tabbable: r, accept: i }, n); s.currentNode = n[n.length - 1].nextElementSibling; let a = s.previousNode(); return a && Kr(a, !0), a } } } const Qv = ["input:not([disabled]):not([type=hidden])", "select:not([disabled])", "textarea:not([disabled])", "button:not([disabled])", "a[href]", "area[href]", "summary", "iframe", "object", "embed", "audio[controls]", "video[controls]", "[contenteditable]"], yN = Qv.join(":not([hidden]),") + ",[tabindex]:not([disabled]):not([hidden])"; Qv.push('[tabindex]:not([tabindex="-1"]):not([disabled])'); const bN = Qv.join(':not([hidden]):not([tabindex="-1"]),'); function yo(e) { return e[0].parentElement } function nl(e) { let t = Tt.getTreeNode(Ge); for (; t && t.scopeRef !== e;) { if (t.contain) return !1; t = t.parent } return !0 } function wN(e, t) { let n = S.useRef(void 0), r = S.useRef(void 0); fr(() => { let i = e.current; if (!t) { r.current && (cancelAnimationFrame(r.current), r.current = void 0); return } const o = $n(i ? i[0] : void 0); let s = u => { if (u.key !== "Tab" || u.altKey || u.ctrlKey || u.metaKey || !nl(e) || u.isComposing) return; let c = o.activeElement, d = e.current; if (!d || !er(c, d)) return; let f = yo(d), p = Li(f, { tabbable: !0 }, d); if (!c) return; p.currentNode = c; let m = u.shiftKey ? p.previousNode() : p.nextNode(); m || (p.currentNode = u.shiftKey ? d[d.length - 1].nextElementSibling : d[0].previousElementSibling, m = u.shiftKey ? p.previousNode() : p.nextNode()), u.preventDefault(), m && Kr(m, !0) }, a = u => { (!Ge || Rd(Ge, e)) && er(u.target, e.current) ? (Ge = e, n.current = u.target) : nl(e) && !bo(u.target, e) ? n.current ? n.current.focus() : Ge && Ge.current && Im(Ge.current) : nl(e) && (n.current = u.target) }, l = u => { r.current && cancelAnimationFrame(r.current), r.current = requestAnimationFrame(() => { if (o.activeElement && nl(e) && !bo(o.activeElement, e)) if (Ge = e, o.body.contains(u.target)) { var c; n.current = u.target, (c = n.current) === null || c === void 0 || c.focus() } else Ge.current && Im(Ge.current) }) }; return o.addEventListener("keydown", s, !1), o.addEventListener("focusin", a, !1), i == null || i.forEach(u => u.addEventListener("focusin", a, !1)), i == null || i.forEach(u => u.addEventListener("focusout", l, !1)), () => { o.removeEventListener("keydown", s, !1), o.removeEventListener("focusin", a, !1), i == null || i.forEach(u => u.removeEventListener("focusin", a, !1)), i == null || i.forEach(u => u.removeEventListener("focusout", l, !1)) } }, [e, t]), fr(() => () => { r.current && cancelAnimationFrame(r.current) }, [r]) } function $C(e) { return bo(e) } function er(e, t) { return !e || !t ? !1 : t.some(n => n.contains(e)) } function bo(e, t = null) { if (e instanceof Element && e.closest("[data-react-aria-top-layer]")) return !0; for (let { scopeRef: n } of Tt.traverse(Tt.getTreeNode(t))) if (n && er(e, n.current)) return !0; return !1 } function Rd(e, t) { var n; let r = (n = Tt.getTreeNode(t)) === null || n === void 0 ? void 0 : n.parent; for (; r;) { if (r.scopeRef === e) return !0; r = r.parent } return !1 } function Kr(e, t = !1) { if (e != null && !t) try { CC(e) } catch { } else if (e != null) try { e.focus() } catch { } } function AC(e, t = !0) { let n = e[0].previousElementSibling, r = yo(e), i = Li(r, { tabbable: t }, e); i.currentNode = n; let o = i.nextNode(); return t && !o && (r = yo(e), i = Li(r, { tabbable: !1 }, e), i.currentNode = n, o = i.nextNode()), o } function Im(e, t = !0) { Kr(AC(e, t)) } function xN(e, t) { const n = se.useRef(t); S.useEffect(() => { if (n.current) { Ge = e; const r = $n(e.current ? e.current[0] : void 0); !er(r.activeElement, Ge.current) && e.current && Im(e.current) } n.current = !1 }, [e]) } function SN(e, t, n) { fr(() => { if (t || n) return; let r = e.current; const i = $n(r ? r[0] : void 0); let o = s => { let a = s.target; er(a, e.current) ? Ge = e : $C(a) || (Ge = null) }; return i.addEventListener("focusin", o, !1), r == null || r.forEach(s => s.addEventListener("focusin", o, !1)), () => { i.removeEventListener("focusin", o, !1), r == null || r.forEach(s => s.removeEventListener("focusin", o, !1)) } }, [e, t, n]) } function Yb(e) { let t = Tt.getTreeNode(Ge); for (; t && t.scopeRef !== e;) { if (t.nodeToRestore) return !1; t = t.parent } return (t == null ? void 0 : t.scopeRef) === e } function EN(e, t, n) { const r = S.useRef(typeof document < "u" ? $n(e.current ? e.current[0] : void 0).activeElement : null); fr(() => { let i = e.current; const o = $n(i ? i[0] : void 0); if (!t || n) return; let s = () => { (!Ge || Rd(Ge, e)) && er(o.activeElement, e.current) && (Ge = e) }; return o.addEventListener("focusin", s, !1), i == null || i.forEach(a => a.addEventListener("focusin", s, !1)), () => { o.removeEventListener("focusin", s, !1), i == null || i.forEach(a => a.removeEventListener("focusin", s, !1)) } }, [e, n]), fr(() => { const i = $n(e.current ? e.current[0] : void 0); if (!t) return; let o = s => { if (s.key !== "Tab" || s.altKey || s.ctrlKey || s.metaKey || !nl(e) || s.isComposing) return; let a = i.activeElement; if (!bo(a, e) || !Yb(e)) return; let l = Tt.getTreeNode(e); if (!l) return; let u = l.nodeToRestore, c = Li(i.body, { tabbable: !0 }); c.currentNode = a; let d = s.shiftKey ? c.previousNode() : c.nextNode(); if ((!u || !i.body.contains(u) || u === i.body) && (u = void 0, l.nodeToRestore = void 0), (!d || !bo(d, e)) && u) { c.currentNode = u; do d = s.shiftKey ? c.previousNode() : c.nextNode(); while (bo(d, e)); s.preventDefault(), s.stopPropagation(), d ? Kr(d, !0) : $C(u) ? Kr(u, !0) : a.blur() } }; return n || i.addEventListener("keydown", o, !0), () => { n || i.removeEventListener("keydown", o, !0) } }, [e, t, n]), fr(() => { const i = $n(e.current ? e.current[0] : void 0); if (!t) return; let o = Tt.getTreeNode(e); if (o) { var s; return o.nodeToRestore = (s = r.current) !== null && s !== void 0 ? s : void 0, () => { let a = Tt.getTreeNode(e); if (!a) return; let l = a.nodeToRestore; if (t && l && (i.activeElement && bo(i.activeElement, e) || i.activeElement === i.body && Yb(e))) { let u = Tt.clone(); requestAnimationFrame(() => { if (i.activeElement === i.body) { let c = u.getTreeNode(e); for (; c;) { if (c.nodeToRestore && c.nodeToRestore.isConnected) { Qb(c.nodeToRestore); return } c = c.parent } for (c = u.getTreeNode(e); c;) { if (c.scopeRef && c.scopeRef.current && Tt.getTreeNode(c.scopeRef)) { let d = AC(c.scopeRef.current, !0); Qb(d); return } c = c.parent } } }) } } } }, [e, t]) } function Qb(e) { e.dispatchEvent(new CustomEvent(jm, { bubbles: !0, cancelable: !0 })) && Kr(e) } function Li(e, t, n) { let r = t != null && t.tabbable ? bN : yN, i = $n(e).createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode(o) { var s; return !(t == null || (s = t.from) === null || s === void 0) && s.contains(o) ? NodeFilter.FILTER_REJECT : o.matches(r) && PC(o) && (!n || er(o, n)) && (!(t != null && t.accept) || t.accept(o)) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP } }); return t != null && t.from && (i.currentNode = t.from), i } class Xv { get size() { return this.fastMap.size } getTreeNode(t) { return this.fastMap.get(t) } addTreeNode(t, n, r) { let i = this.fastMap.get(n ?? null); if (!i) return; let o = new Dm({ scopeRef: t }); i.addChild(o), o.parent = i, this.fastMap.set(t, o), r && (o.nodeToRestore = r) } addNode(t) { this.fastMap.set(t.scopeRef, t) } removeTreeNode(t) { if (t === null) return; let n = this.fastMap.get(t); if (!n) return; let r = n.parent; for (let o of this.traverse()) o !== n && n.nodeToRestore && o.nodeToRestore && n.scopeRef && n.scopeRef.current && er(o.nodeToRestore, n.scopeRef.current) && (o.nodeToRestore = n.nodeToRestore); let i = n.children; r && (r.removeChild(n), i.size > 0 && i.forEach(o => r && r.addChild(o))), this.fastMap.delete(n.scopeRef) } *traverse(t = this.root) { if (t.scopeRef != null && (yield t), t.children.size > 0) for (let n of t.children) yield* this.traverse(n) } clone() { var t; let n = new Xv; var r; for (let i of this.traverse()) n.addTreeNode(i.scopeRef, (r = (t = i.parent) === null || t === void 0 ? void 0 : t.scopeRef) !== null && r !== void 0 ? r : null, i.nodeToRestore); return n } constructor() { this.fastMap = new Map, this.root = new Dm({ scopeRef: null }), this.fastMap.set(null, this.root) } } class Dm { addChild(t) { this.children.add(t), t.parent = this } removeChild(t) { this.children.delete(t), t.parent = void 0 } constructor(t) { this.children = new Set, this.contain = !1, this.scopeRef = t.scopeRef } } let Tt = new Xv; function ri(e = {}) { let { autoFocus: t = !1, isTextInput: n, within: r } = e, i = S.useRef({ isFocused: !1, isFocusVisible: t || EC() }), [o, s] = S.useState(!1), [a, l] = S.useState(() => i.current.isFocused && i.current.isFocusVisible), u = S.useCallback(() => l(i.current.isFocused && i.current.isFocusVisible), []), c = S.useCallback(p => { i.current.isFocused = p, s(p), u() }, [u]); dN(p => { i.current.isFocusVisible = p, u() }, [], { isTextInput: n }); let { focusProps: d } = yC({ isDisabled: r, onFocusChange: c }), { focusWithinProps: f } = TC({ isDisabled: !r, onFocusWithinChange: c }); return { isFocused: o, isFocusVisible: a, focusProps: r ? f : d } } let TN = se.createContext(null); function CN(e) { let t = S.useContext(TN) || {}; OL(t, e); let { ref: n, ...r } = t; return r } function Jv(e, t) { let { focusProps: n } = yC(e), { keyboardProps: r } = pN(e), i = Ib(n, r), o = CN(t), s = e.isDisabled ? {} : o, a = S.useRef(e.autoFocus); return S.useEffect(() => { a.current && t.current && CC(t.current), a.current = !1 }, [t]), { focusableProps: Ib({ ...i, tabIndex: e.excludeFromTabOrder && !e.isDisabled ? -1 : void 0 }, s) } } const Lp = typeof document < "u" && window.visualViewport, PN = new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]); let fc = 0, Np; function $N(e = {}) { let { isDisabled: t } = e; JT(() => { if (!t) return fc++, fc === 1 && (tC() ? Np = MN() : Np = AN()), () => { fc--, fc === 0 && Np() } }, [t]) } function AN() { return ni(ks(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`), ks(document.documentElement, "overflow", "hidden")) } function MN() { let e, t, n = u => { e = oC(u.target, !0), !(e === document.documentElement && e === document.body) && e instanceof HTMLElement && window.getComputedStyle(e).overscrollBehavior === "auto" && (t = ks(e, "overscrollBehavior", "contain")) }, r = u => { if (!e || e === document.documentElement || e === document.body) { u.preventDefault(); return } e.scrollHeight === e.clientHeight && e.scrollWidth === e.clientWidth && u.preventDefault() }, i = u => { let c = u.target; Jb(c) && c !== document.activeElement && (u.preventDefault(), a(), c.style.transform = "translateY(-2000px)", c.focus(), requestAnimationFrame(() => { c.style.transform = "" })), t && t() }, o = u => { let c = u.target; Jb(c) && (a(), c.style.transform = "translateY(-2000px)", requestAnimationFrame(() => { c.style.transform = "", Lp && (Lp.height < window.innerHeight ? requestAnimationFrame(() => { Xb(c) }) : Lp.addEventListener("resize", () => Xb(c), { once: !0 })) })) }, s = null, a = () => { if (s) return; let u = () => { window.scrollTo(0, 0) }, c = window.pageXOffset, d = window.pageYOffset; s = ni(La(window, "scroll", u), ks(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`), ks(document.documentElement, "overflow", "hidden"), ks(document.body, "marginTop", `-${d}px`), () => { window.scrollTo(c, d) }), window.scrollTo(0, 0) }, l = ni(La(document, "touchstart", n, { passive: !1, capture: !0 }), La(document, "touchmove", r, { passive: !1, capture: !0 }), La(document, "touchend", i, { passive: !1, capture: !0 }), La(document, "focus", o, !0)); return () => { t == null || t(), s == null || s(), l() } } function ks(e, t, n) { let r = e.style[t]; return e.style[t] = n, () => { e.style[t] = r } } function La(e, t, n, r) { return e.addEventListener(t, n, r), () => { e.removeEventListener(t, n, r) } } function Xb(e) { let t = document.scrollingElement || document.documentElement, n = e; for (; n && n !== t;) { let r = oC(n); if (r !== document.documentElement && r !== document.body && r !== n) { let i = r.getBoundingClientRect().top, o = n.getBoundingClientRect().top; o > i + n.clientHeight && (r.scrollTop += o - i) } n = r.parentElement } } function Jb(e) { return e instanceof HTMLInputElement && !PN.has(e.type) || e instanceof HTMLTextAreaElement || e instanceof HTMLElement && e.isContentEditable } const Fm = se.createContext(null); function kN(e) { let { children: t } = e, n = S.useContext(Fm), [r, i] = S.useState(0), o = S.useMemo(() => ({ parent: n, modalCount: r, addModal() { i(s => s + 1), n && n.addModal() }, removeModal() { i(s => s - 1), n && n.removeModal() } }), [n, r]); return se.createElement(Fm.Provider, { value: o }, t) } function _N() { let e = S.useContext(Fm); return { modalProviderProps: { "aria-hidden": e && e.modalCount > 0 ? !0 : void 0 } } } function RN(e) { let { modalProviderProps: t } = _N(); return se.createElement("div", { "data-overlay-container": !0, ...e, ...t }) } function LN(e) { return se.createElement(kN, null, se.createElement(RN, e)) } const NN = S.createContext({}); function ON() { var e; return (e = S.useContext(NN)) !== null && e !== void 0 ? e : {} } const jN = se.createContext(null); function IN(e) { let t = Vv(), { portalContainer: n = t ? null : document.body, isExiting: r } = e, [i, o] = S.useState(!1), s = S.useMemo(() => ({ contain: i, setContain: o }), [i, o]), { getContainer: a } = ON(); if (!e.portalContainer && a && (n = a()), !n) return null; let l = e.children; return e.disableFocusManagement || (l = se.createElement(gN, { restoreFocus: !0, contain: i && !r }, l)), l = se.createElement(jN.Provider, { value: s }, se.createElement(nN, null, l)), FT.createPortal(l, n) } function MC(e) { if (typeof Proxy > "u") return e; const t = new Map, n = (...r) => e(...r); return new Proxy(n, { get: (r, i) => i === "create" ? e : (t.has(i) || t.set(i, e(i)), t.get(i)) }) } function Lf(e) { return e !== null && typeof e == "object" && typeof e.start == "function" } const zm = e => Array.isArray(e); function kC(e, t) { if (!Array.isArray(t)) return !1; const n = t.length; if (n !== e.length) return !1; for (let r = 0; r < n; r++)if (t[r] !== e[r]) return !1; return !0 } function Yl(e) { return typeof e == "string" || Array.isArray(e) } function Zb(e) { const t = [{}, {}]; return e == null || e.values.forEach((n, r) => { t[0][r] = n.get(), t[1][r] = n.getVelocity() }), t } function Zv(e, t, n, r) { if (typeof t == "function") { const [i, o] = Zb(r); t = t(n !== void 0 ? n : e.custom, i, o) } if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") { const [i, o] = Zb(r); t = t(n !== void 0 ? n : e.custom, i, o) } return t } function Nf(e, t, n) { const r = e.getProps(); return Zv(r, t, n !== void 0 ? n : r.custom, e) } const ey = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], ty = ["initial", ...ey], $u = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], Xo = new Set($u), Yr = e => e * 1e3, Qr = e => e / 1e3, DN = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, FN = e => ({ type: "spring", stiffness: 550, damping: e === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), zN = { type: "keyframes", duration: .8 }, VN = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, BN = (e, { keyframes: t }) => t.length > 2 ? zN : Xo.has(e) ? e.startsWith("scale") ? FN(t[1]) : DN : VN; function ny(e, t) { return e ? e[t] || e.default || e : void 0 } const ry = { skipAnimations: !1, useManualTiming: !1 }, UN = e => e !== null; function Of(e, { repeat: t, repeatType: n = "loop" }, r) { const i = e.filter(UN), o = t && n !== "loop" && t % 2 === 1 ? 0 : i.length - 1; return !o || r === void 0 ? i[o] : r } const Mn = e => e; let Vm = Mn; function HN(e) { let t = new Set, n = new Set, r = !1, i = !1; const o = new WeakSet; let s = { delta: 0, timestamp: 0, isProcessing: !1 }; function a(u) { o.has(u) && (l.schedule(u), e()), u(s) } const l = { schedule: (u, c = !1, d = !1) => { const p = d && r ? t : n; return c && o.add(u), p.has(u) || p.add(u), u }, cancel: u => { n.delete(u), o.delete(u) }, process: u => { if (s = u, r) { i = !0; return } r = !0, [t, n] = [n, t], t.forEach(a), t.clear(), r = !1, i && (i = !1, l.process(u)) } }; return l } const pc = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"], WN = 40; function _C(e, t) { let n = !1, r = !0; const i = { delta: 0, timestamp: 0, isProcessing: !1 }, o = () => n = !0, s = pc.reduce((g, h) => (g[h] = HN(o), g), {}), { read: a, resolveKeyframes: l, update: u, preRender: c, render: d, postRender: f } = s, p = () => { const g = performance.now(); n = !1, i.delta = r ? 1e3 / 60 : Math.max(Math.min(g - i.timestamp, WN), 1), i.timestamp = g, i.isProcessing = !0, a.process(i), l.process(i), u.process(i), c.process(i), d.process(i), f.process(i), i.isProcessing = !1, n && t && (r = !1, e(p)) }, m = () => { n = !0, r = !0, i.isProcessing || e(p) }; return { schedule: pc.reduce((g, h) => { const y = s[h]; return g[h] = (E, P = !1, $ = !1) => (n || m(), y.schedule(E, P, $)), g }, {}), cancel: g => { for (let h = 0; h < pc.length; h++)s[pc[h]].cancel(g) }, state: i, steps: s } } const { schedule: qe, cancel: qi, state: Ft, steps: Op } = _C(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Mn, !0), RC = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, GN = 1e-7, KN = 12; function qN(e, t, n, r, i) { let o, s, a = 0; do s = t + (n - t) / 2, o = RC(s, r, i) - e, o > 0 ? n = s : t = s; while (Math.abs(o) > GN && ++a < KN); return s } function Au(e, t, n, r) { if (e === t && n === r) return Mn; const i = o => qN(o, 0, 1, e, n); return o => o === 0 || o === 1 ? o : RC(i(o), t, r) } const LC = e => t => t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, NC = e => t => 1 - e(1 - t), OC = Au(.33, 1.53, .69, .99), iy = NC(OC), jC = LC(iy), IC = e => (e *= 2) < 1 ? .5 * iy(e) : .5 * (2 - Math.pow(2, -10 * (e - 1))), oy = e => 1 - Math.sin(Math.acos(e)), DC = NC(oy), FC = LC(oy), zC = e => /^0[^.\s]+$/u.test(e); function YN(e) { return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || zC(e) : !0 } const VC = e => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e), BC = e => t => typeof t == "string" && t.startsWith(e), UC = BC("--"), QN = BC("var(--"), sy = e => QN(e) ? XN.test(e.split("/*")[0].trim()) : !1, XN = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, JN = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function ZN(e) { const t = JN.exec(e); if (!t) return [,]; const [, n, r, i] = t; return [`--${n ?? r}`, i] } function HC(e, t, n = 1) { const [r, i] = ZN(e); if (!r) return; const o = window.getComputedStyle(t).getPropertyValue(r); if (o) { const s = o.trim(); return VC(s) ? parseFloat(s) : s } return sy(i) ? HC(i, t, n + 1) : i } const ii = (e, t, n) => n > t ? t : n < e ? e : n, pa = { test: e => typeof e == "number", parse: parseFloat, transform: e => e }, Ql = { ...pa, transform: e => ii(0, 1, e) }, hc = { ...pa, default: 1 }, Mu = e => ({ test: t => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1, parse: parseFloat, transform: t => `${t}${e}` }), vi = Mu("deg"), kr = Mu("%"), ve = Mu("px"), eO = Mu("vh"), tO = Mu("vw"), ew = { ...kr, parse: e => kr.parse(e) / 100, transform: e => kr.transform(e * 100) }, nO = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"]), tw = e => e === pa || e === ve, nw = (e, t) => parseFloat(e.split(", ")[t]), rw = (e, t) => (n, { transform: r }) => { if (r === "none" || !r) return 0; const i = r.match(/^matrix3d\((.+)\)$/u); if (i) return nw(i[1], t); { const o = r.match(/^matrix\((.+)\)$/u); return o ? nw(o[1], e) : 0 } }, rO = new Set(["x", "y", "z"]), iO = $u.filter(e => !rO.has(e)); function oO(e) { const t = []; return iO.forEach(n => { const r = e.getValue(n); r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0)) }), t } const oa = { width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n), height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n), top: (e, { top: t }) => parseFloat(t), left: (e, { left: t }) => parseFloat(t), bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min), right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min), x: rw(4, 13), y: rw(5, 14) }; oa.translateX = oa.x; oa.translateY = oa.y; const WC = e => t => t.test(e), sO = { test: e => e === "auto", parse: e => e }, GC = [pa, ve, kr, vi, tO, eO, sO], iw = e => GC.find(WC(e)), ko = new Set; let Bm = !1, Um = !1; function KC() { if (Um) { const e = Array.from(ko).filter(r => r.needsMeasurement), t = new Set(e.map(r => r.element)), n = new Map; t.forEach(r => { const i = oO(r); i.length && (n.set(r, i), r.render()) }), e.forEach(r => r.measureInitialState()), t.forEach(r => { r.render(); const i = n.get(r); i && i.forEach(([o, s]) => { var a; (a = r.getValue(o)) === null || a === void 0 || a.set(s) }) }), e.forEach(r => r.measureEndState()), e.forEach(r => { r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY) }) } Um = !1, Bm = !1, ko.forEach(e => e.complete()), ko.clear() } function qC() { ko.forEach(e => { e.readKeyframes(), e.needsMeasurement && (Um = !0) }) } function aO() { qC(), KC() } class ay { constructor(t, n, r, i, o, s = !1) { this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...t], this.onComplete = n, this.name = r, this.motionValue = i, this.element = o, this.isAsync = s } scheduleResolve() { this.isScheduled = !0, this.isAsync ? (ko.add(this), Bm || (Bm = !0, qe.read(qC), qe.resolveKeyframes(KC))) : (this.readKeyframes(), this.complete()) } readKeyframes() { const { unresolvedKeyframes: t, name: n, element: r, motionValue: i } = this; for (let o = 0; o < t.length; o++)if (t[o] === null) if (o === 0) { const s = i == null ? void 0 : i.get(), a = t[t.length - 1]; if (s !== void 0) t[0] = s; else if (r && n) { const l = r.readValue(n, a); l != null && (t[0] = l) } t[0] === void 0 && (t[0] = a), i && s === void 0 && i.set(t[0]) } else t[o] = t[o - 1] } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete() { this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), ko.delete(this) } cancel() { this.isComplete || (this.isScheduled = !1, ko.delete(this)) } resume() { this.isComplete || this.scheduleResolve() } } const wl = e => Math.round(e * 1e5) / 1e5, ly = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu; function lO(e) { return e == null } const uO = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, uy = (e, t) => n => !!(typeof n == "string" && uO.test(n) && n.startsWith(e) || t && !lO(n) && Object.prototype.hasOwnProperty.call(n, t)), YC = (e, t, n) => r => { if (typeof r != "string") return r; const [i, o, s, a] = r.match(ly); return { [e]: parseFloat(i), [t]: parseFloat(o), [n]: parseFloat(s), alpha: a !== void 0 ? parseFloat(a) : 1 } }, cO = e => ii(0, 255, e), jp = { ...pa, transform: e => Math.round(cO(e)) }, wo = { test: uy("rgb", "red"), parse: YC("red", "green", "blue"), transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) => "rgba(" + jp.transform(e) + ", " + jp.transform(t) + ", " + jp.transform(n) + ", " + wl(Ql.transform(r)) + ")" }; function dO(e) { let t = "", n = "", r = "", i = ""; return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), i = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), i = e.substring(4, 5), t += t, n += n, r += r, i += i), { red: parseInt(t, 16), green: parseInt(n, 16), blue: parseInt(r, 16), alpha: i ? parseInt(i, 16) / 255 : 1 } } const Hm = { test: uy("#"), parse: dO, transform: wo.transform }, _s = { test: uy("hsl", "hue"), parse: YC("hue", "saturation", "lightness"), transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(e) + ", " + kr.transform(wl(t)) + ", " + kr.transform(wl(n)) + ", " + wl(Ql.transform(r)) + ")" }, qt = { test: e => wo.test(e) || Hm.test(e) || _s.test(e), parse: e => wo.test(e) ? wo.parse(e) : _s.test(e) ? _s.parse(e) : Hm.parse(e), transform: e => typeof e == "string" ? e : e.hasOwnProperty("red") ? wo.transform(e) : _s.transform(e) }, fO = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu; function pO(e) { var t, n; return isNaN(e) && typeof e == "string" && (((t = e.match(ly)) === null || t === void 0 ? void 0 : t.length) || 0) + (((n = e.match(fO)) === null || n === void 0 ? void 0 : n.length) || 0) > 0 } const QC = "number", XC = "color", hO = "var", mO = "var(", ow = "${}", gO = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function Xl(e) { const t = e.toString(), n = [], r = { color: [], number: [], var: [] }, i = []; let o = 0; const a = t.replace(gO, l => (qt.test(l) ? (r.color.push(o), i.push(XC), n.push(qt.parse(l))) : l.startsWith(mO) ? (r.var.push(o), i.push(hO), n.push(l)) : (r.number.push(o), i.push(QC), n.push(parseFloat(l))), ++o, ow)).split(ow); return { values: n, split: a, indexes: r, types: i } } function JC(e) { return Xl(e).values } function ZC(e) { const { split: t, types: n } = Xl(e), r = t.length; return i => { let o = ""; for (let s = 0; s < r; s++)if (o += t[s], i[s] !== void 0) { const a = n[s]; a === QC ? o += wl(i[s]) : a === XC ? o += qt.transform(i[s]) : o += i[s] } return o } } const vO = e => typeof e == "number" ? 0 : e; function yO(e) { const t = JC(e); return ZC(e)(t.map(vO)) } const Yi = { test: pO, parse: JC, createTransformer: ZC, getAnimatableNone: yO }, bO = new Set(["brightness", "contrast", "saturate", "opacity"]); function wO(e) { const [t, n] = e.slice(0, -1).split("("); if (t === "drop-shadow") return e; const [r] = n.match(ly) || []; if (!r) return e; const i = n.replace(r, ""); let o = bO.has(t) ? 1 : 0; return r !== n && (o *= 100), t + "(" + o + i + ")" } const xO = /\b([a-z-]*)\(.*?\)/gu, Wm = { ...Yi, getAnimatableNone: e => { const t = e.match(xO); return t ? t.map(wO).join(" ") : e } }, SO = { borderWidth: ve, borderTopWidth: ve, borderRightWidth: ve, borderBottomWidth: ve, borderLeftWidth: ve, borderRadius: ve, radius: ve, borderTopLeftRadius: ve, borderTopRightRadius: ve, borderBottomRightRadius: ve, borderBottomLeftRadius: ve, width: ve, maxWidth: ve, height: ve, maxHeight: ve, top: ve, right: ve, bottom: ve, left: ve, padding: ve, paddingTop: ve, paddingRight: ve, paddingBottom: ve, paddingLeft: ve, margin: ve, marginTop: ve, marginRight: ve, marginBottom: ve, marginLeft: ve, backgroundPositionX: ve, backgroundPositionY: ve }, EO = { rotate: vi, rotateX: vi, rotateY: vi, rotateZ: vi, scale: hc, scaleX: hc, scaleY: hc, scaleZ: hc, skew: vi, skewX: vi, skewY: vi, distance: ve, translateX: ve, translateY: ve, translateZ: ve, x: ve, y: ve, z: ve, perspective: ve, transformPerspective: ve, opacity: Ql, originX: ew, originY: ew, originZ: ve }, sw = { ...pa, transform: Math.round }, cy = { ...SO, ...EO, zIndex: sw, size: ve, fillOpacity: Ql, strokeOpacity: Ql, numOctaves: sw }, TO = { ...cy, color: qt, backgroundColor: qt, outlineColor: qt, fill: qt, stroke: qt, borderColor: qt, borderTopColor: qt, borderRightColor: qt, borderBottomColor: qt, borderLeftColor: qt, filter: Wm, WebkitFilter: Wm }, dy = e => TO[e]; function eP(e, t) { let n = dy(e); return n !== Wm && (n = Yi), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0 } const CO = new Set(["auto", "none", "0"]); function PO(e, t, n) { let r = 0, i; for (; r < e.length && !i;) { const o = e[r]; typeof o == "string" && !CO.has(o) && Xl(o).values.length && (i = e[r]), r++ } if (i && n) for (const o of t) e[o] = eP(n, i) } class tP extends ay { constructor(t, n, r, i, o) { super(t, n, r, i, o, !0) } readKeyframes() { const { unresolvedKeyframes: t, element: n, name: r } = this; if (!n || !n.current) return; super.readKeyframes(); for (let l = 0; l < t.length; l++) { let u = t[l]; if (typeof u == "string" && (u = u.trim(), sy(u))) { const c = HC(u, n.current); c !== void 0 && (t[l] = c), l === t.length - 1 && (this.finalKeyframe = u) } } if (this.resolveNoneKeyframes(), !nO.has(r) || t.length !== 2) return; const [i, o] = t, s = iw(i), a = iw(o); if (s !== a) if (tw(s) && tw(a)) for (let l = 0; l < t.length; l++) { const u = t[l]; typeof u == "string" && (t[l] = parseFloat(u)) } else this.needsMeasurement = !0 } resolveNoneKeyframes() { const { unresolvedKeyframes: t, name: n } = this, r = []; for (let i = 0; i < t.length; i++)YN(t[i]) && r.push(i); r.length && PO(t, r, n) } measureInitialState() { const { element: t, unresolvedKeyframes: n, name: r } = this; if (!t || !t.current) return; r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = oa[r](t.measureViewportBox(), window.getComputedStyle(t.current)), n[0] = this.measuredOrigin; const i = n[n.length - 1]; i !== void 0 && t.getValue(r, i).jump(i, !1) } measureEndState() { var t; const { element: n, name: r, unresolvedKeyframes: i } = this; if (!n || !n.current) return; const o = n.getValue(r); o && o.jump(this.measuredOrigin, !1); const s = i.length - 1, a = i[s]; i[s] = oa[r](n.measureViewportBox(), window.getComputedStyle(n.current)), a !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = a), !((t = this.removedTransforms) === null || t === void 0) && t.length && this.removedTransforms.forEach(([l, u]) => { n.getValue(l).set(u) }), this.resolveNoneKeyframes() } } function fy(e) { return typeof e == "function" } let Kc; function $O() { Kc = void 0 } const _r = { now: () => (Kc === void 0 && _r.set(Ft.isProcessing || ry.useManualTiming ? Ft.timestamp : performance.now()), Kc), set: e => { Kc = e, queueMicrotask($O) } }, aw = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && (Yi.test(e) || e === "0") && !e.startsWith("url(")); function AO(e) { const t = e[0]; if (e.length === 1) return !0; for (let n = 0; n < e.length; n++)if (e[n] !== t) return !0 } function MO(e, t, n, r) { const i = e[0]; if (i === null) return !1; if (t === "display" || t === "visibility") return !0; const o = e[e.length - 1], s = aw(i, t), a = aw(o, t); return !s || !a ? !1 : AO(e) || (n === "spring" || fy(n)) && r } const kO = 40; class nP { constructor({ autoplay: t = !0, delay: n = 0, type: r = "keyframes", repeat: i = 0, repeatDelay: o = 0, repeatType: s = "loop", ...a }) { this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = _r.now(), this.options = { autoplay: t, delay: n, type: r, repeat: i, repeatDelay: o, repeatType: s, ...a }, this.updateFinishedPromise() } calcStartTime() { return this.resolvedAt ? this.resolvedAt - this.createdAt > kO ? this.resolvedAt : this.createdAt : this.createdAt } get resolved() { return !this._resolved && !this.hasAttemptedResolve && aO(), this._resolved } onKeyframesResolved(t, n) { this.resolvedAt = _r.now(), this.hasAttemptedResolve = !0; const { name: r, type: i, velocity: o, delay: s, onComplete: a, onUpdate: l, isGenerator: u } = this.options; if (!u && !MO(t, r, i, o)) if (s) this.options.duration = 0; else { l == null || l(Of(t, this.options, n)), a == null || a(), this.resolveFinishedPromise(); return } const c = this.initPlayback(t, n); c !== !1 && (this._resolved = { keyframes: t, finalKeyframe: n, ...c }, this.onPostResolved()) } onPostResolved() { } then(t, n) { return this.currentFinishedPromise.then(t, n) } flatten() { this.options.type = "keyframes", this.options.ease = "linear" } updateFinishedPromise() { this.currentFinishedPromise = new Promise(t => { this.resolveFinishedPromise = t }) } } const sa = (e, t, n) => { const r = t - e; return r === 0 ? 1 : (n - e) / r }, rP = (e, t, n = 10) => { let r = ""; const i = Math.max(Math.round(t / n), 2); for (let o = 0; o < i; o++)r += e(sa(0, i - 1, o)) + ", "; return `linear(${r.substring(0, r.length - 2)})` }; function iP(e, t) { return t ? e * (1e3 / t) : 0 } const _O = 5; function oP(e, t, n) { const r = Math.max(t - _O, 0); return iP(n - e(r), t - r) } const st = { stiffness: 100, damping: 10, mass: 1, velocity: 0, duration: 800, bounce: .3, visualDuration: .3, restSpeed: { granular: .01, default: 2 }, restDelta: { granular: .005, default: .5 }, minDuration: .01, maxDuration: 10, minDamping: .05, maxDamping: 1 }, Ip = .001; function RO({ duration: e = st.duration, bounce: t = st.bounce, velocity: n = st.velocity, mass: r = st.mass }) { let i, o, s = 1 - t; s = ii(st.minDamping, st.maxDamping, s), e = ii(st.minDuration, st.maxDuration, Qr(e)), s < 1 ? (i = u => { const c = u * s, d = c * e, f = c - n, p = Gm(u, s), m = Math.exp(-d); return Ip - f / p * m }, o = u => { const d = u * s * e, f = d * n + n, p = Math.pow(s, 2) * Math.pow(u, 2) * e, m = Math.exp(-d), v = Gm(Math.pow(u, 2), s); return (-i(u) + Ip > 0 ? -1 : 1) * ((f - p) * m) / v }) : (i = u => { const c = Math.exp(-u * e), d = (u - n) * e + 1; return -Ip + c * d }, o = u => { const c = Math.exp(-u * e), d = (n - u) * (e * e); return c * d }); const a = 5 / e, l = NO(i, o, a); if (e = Yr(e), isNaN(l)) return { stiffness: st.stiffness, damping: st.damping, duration: e }; { const u = Math.pow(l, 2) * r; return { stiffness: u, damping: s * 2 * Math.sqrt(r * u), duration: e } } } const LO = 12; function NO(e, t, n) { let r = n; for (let i = 1; i < LO; i++)r = r - e(r) / t(r); return r } function Gm(e, t) { return e * Math.sqrt(1 - t * t) } const Km = 2e4; function sP(e) { let t = 0; const n = 50; let r = e.next(t); for (; !r.done && t < Km;)t += n, r = e.next(t); return t >= Km ? 1 / 0 : t } const OO = ["duration", "bounce"], jO = ["stiffness", "damping", "mass"]; function lw(e, t) { return t.some(n => e[n] !== void 0) } function IO(e) { let t = { velocity: st.velocity, stiffness: st.stiffness, damping: st.damping, mass: st.mass, isResolvedFromDuration: !1, ...e }; if (!lw(e, jO) && lw(e, OO)) if (e.visualDuration) { const n = e.visualDuration, r = 2 * Math.PI / (n * 1.2), i = r * r, o = 2 * ii(.05, 1, 1 - e.bounce) * Math.sqrt(i); t = { ...t, mass: st.mass, stiffness: i, damping: o } } else { const n = RO(e); t = { ...t, ...n, mass: st.mass }, t.isResolvedFromDuration = !0 } return t } function aP(e = st.visualDuration, t = st.bounce) { const n = typeof e != "object" ? { visualDuration: e, keyframes: [0, 1], bounce: t } : e; let { restSpeed: r, restDelta: i } = n; const o = n.keyframes[0], s = n.keyframes[n.keyframes.length - 1], a = { done: !1, value: o }, { stiffness: l, damping: u, mass: c, duration: d, velocity: f, isResolvedFromDuration: p } = IO({ ...n, velocity: -Qr(n.velocity || 0) }), m = f || 0, v = u / (2 * Math.sqrt(l * c)), x = s - o, g = Qr(Math.sqrt(l / c)), h = Math.abs(x) < 5; r || (r = h ? st.restSpeed.granular : st.restSpeed.default), i || (i = h ? st.restDelta.granular : st.restDelta.default); let y; if (v < 1) { const P = Gm(g, v); y = $ => { const L = Math.exp(-v * g * $); return s - L * ((m + v * g * x) / P * Math.sin(P * $) + x * Math.cos(P * $)) } } else if (v === 1) y = P => s - Math.exp(-g * P) * (x + (m + g * x) * P); else { const P = g * Math.sqrt(v * v - 1); y = $ => { const L = Math.exp(-v * g * $), b = Math.min(P * $, 300); return s - L * ((m + v * g * x) * Math.sinh(b) + P * x * Math.cosh(b)) / P } } const E = { calculatedDuration: p && d || null, next: P => { const $ = y(P); if (p) a.done = P >= d; else { let L = 0; v < 1 && (L = P === 0 ? Yr(m) : oP(y, P, $)); const b = Math.abs(L) <= r, M = Math.abs(s - $) <= i; a.done = b && M } return a.value = a.done ? s : $, a }, toString: () => { const P = Math.min(sP(E), Km), $ = rP(L => E.next(P * L).value, P, 30); return P + "ms " + $ } }; return E } function uw({ keyframes: e, velocity: t = 0, power: n = .8, timeConstant: r = 325, bounceDamping: i = 10, bounceStiffness: o = 500, modifyTarget: s, min: a, max: l, restDelta: u = .5, restSpeed: c }) { const d = e[0], f = { done: !1, value: d }, p = b => a !== void 0 && b < a || l !== void 0 && b > l, m = b => a === void 0 ? l : l === void 0 || Math.abs(a - b) < Math.abs(l - b) ? a : l; let v = n * t; const x = d + v, g = s === void 0 ? x : s(x); g !== x && (v = g - d); const h = b => -v * Math.exp(-b / r), y = b => g + h(b), E = b => { const M = h(b), R = y(b); f.done = Math.abs(M) <= u, f.value = f.done ? g : R }; let P, $; const L = b => { p(f.value) && (P = b, $ = aP({ keyframes: [f.value, m(f.value)], velocity: oP(y, b, f.value), damping: i, stiffness: o, restDelta: u, restSpeed: c })) }; return L(0), { calculatedDuration: null, next: b => { let M = !1; return !$ && P === void 0 && (M = !0, E(b), L(b)), P !== void 0 && b >= P ? $.next(b - P) : (!M && E(b), f) } } } const DO = Au(.42, 0, 1, 1), FO = Au(0, 0, .58, 1), lP = Au(.42, 0, .58, 1), zO = e => Array.isArray(e) && typeof e[0] != "number", py = e => Array.isArray(e) && typeof e[0] == "number", cw = { linear: Mn, easeIn: DO, easeInOut: lP, easeOut: FO, circIn: oy, circInOut: FC, circOut: DC, backIn: iy, backInOut: jC, backOut: OC, anticipate: IC }, dw = e => { if (py(e)) { Vm(e.length === 4); const [t, n, r, i] = e; return Au(t, n, r, i) } else if (typeof e == "string") return Vm(cw[e] !== void 0), cw[e]; return e }, VO = (e, t) => n => t(e(n)), ku = (...e) => e.reduce(VO), et = (e, t, n) => e + (t - e) * n; function Dp(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e } function BO({ hue: e, saturation: t, lightness: n, alpha: r }) { e /= 360, t /= 100, n /= 100; let i = 0, o = 0, s = 0; if (!t) i = o = s = n; else { const a = n < .5 ? n * (1 + t) : n + t - n * t, l = 2 * n - a; i = Dp(l, a, e + 1 / 3), o = Dp(l, a, e), s = Dp(l, a, e - 1 / 3) } return { red: Math.round(i * 255), green: Math.round(o * 255), blue: Math.round(s * 255), alpha: r } } function Ld(e, t) { return n => n > 0 ? t : e } const Fp = (e, t, n) => { const r = e * e, i = n * (t * t - r) + r; return i < 0 ? 0 : Math.sqrt(i) }, UO = [Hm, wo, _s], HO = e => UO.find(t => t.test(e)); function fw(e) { const t = HO(e); if (!t) return !1; let n = t.parse(e); return t === _s && (n = BO(n)), n } const pw = (e, t) => { const n = fw(e), r = fw(t); if (!n || !r) return Ld(e, t); const i = { ...n }; return o => (i.red = Fp(n.red, r.red, o), i.green = Fp(n.green, r.green, o), i.blue = Fp(n.blue, r.blue, o), i.alpha = et(n.alpha, r.alpha, o), wo.transform(i)) }, qm = new Set(["none", "hidden"]); function WO(e, t) { return qm.has(e) ? n => n <= 0 ? e : t : n => n >= 1 ? t : e } function GO(e, t) { return n => et(e, t, n) } function hy(e) { return typeof e == "number" ? GO : typeof e == "string" ? sy(e) ? Ld : qt.test(e) ? pw : YO : Array.isArray(e) ? uP : typeof e == "object" ? qt.test(e) ? pw : KO : Ld } function uP(e, t) { const n = [...e], r = n.length, i = e.map((o, s) => hy(o)(o, t[s])); return o => { for (let s = 0; s < r; s++)n[s] = i[s](o); return n } } function KO(e, t) { const n = { ...e, ...t }, r = {}; for (const i in n) e[i] !== void 0 && t[i] !== void 0 && (r[i] = hy(e[i])(e[i], t[i])); return i => { for (const o in r) n[o] = r[o](i); return n } } function qO(e, t) { var n; const r = [], i = { color: 0, var: 0, number: 0 }; for (let o = 0; o < t.values.length; o++) { const s = t.types[o], a = e.indexes[s][i[s]], l = (n = e.values[a]) !== null && n !== void 0 ? n : 0; r[o] = l, i[s]++ } return r } const YO = (e, t) => { const n = Yi.createTransformer(t), r = Xl(e), i = Xl(t); return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? qm.has(e) && !i.values.length || qm.has(t) && !r.values.length ? WO(e, t) : ku(uP(qO(r, i), i.values), n) : Ld(e, t) }; function cP(e, t, n) { return typeof e == "number" && typeof t == "number" && typeof n == "number" ? et(e, t, n) : hy(e)(e, t) } function QO(e, t, n) { const r = [], i = n || cP, o = e.length - 1; for (let s = 0; s < o; s++) { let a = i(e[s], e[s + 1]); if (t) { const l = Array.isArray(t) ? t[s] || Mn : t; a = ku(l, a) } r.push(a) } return r } function XO(e, t, { clamp: n = !0, ease: r, mixer: i } = {}) { const o = e.length; if (Vm(o === t.length), o === 1) return () => t[0]; if (o === 2 && e[0] === e[1]) return () => t[1]; e[0] > e[o - 1] && (e = [...e].reverse(), t = [...t].reverse()); const s = QO(t, r, i), a = s.length, l = u => { let c = 0; if (a > 1) for (; c < e.length - 2 && !(u < e[c + 1]); c++); const d = sa(e[c], e[c + 1], u); return s[c](d) }; return n ? u => l(ii(e[0], e[o - 1], u)) : l } function JO(e, t) { const n = e[e.length - 1]; for (let r = 1; r <= t; r++) { const i = sa(0, t, r); e.push(et(n, 1, i)) } } function ZO(e) { const t = [0]; return JO(t, e.length - 1), t } function e3(e, t) { return e.map(n => n * t) } function t3(e, t) { return e.map(() => t || lP).splice(0, e.length - 1) } function Nd({ duration: e = 300, keyframes: t, times: n, ease: r = "easeInOut" }) { const i = zO(r) ? r.map(dw) : dw(r), o = { done: !1, value: t[0] }, s = e3(n && n.length === t.length ? n : ZO(t), e), a = XO(s, t, { ease: Array.isArray(i) ? i : t3(t, i) }); return { calculatedDuration: e, next: l => (o.value = a(l), o.done = l >= e, o) } } const n3 = e => { const t = ({ timestamp: n }) => e(n); return { start: () => qe.update(t, !0), stop: () => qi(t), now: () => Ft.isProcessing ? Ft.timestamp : _r.now() } }, r3 = { decay: uw, inertia: uw, tween: Nd, keyframes: Nd, spring: aP }, i3 = e => e / 100; class my extends nP { constructor(t) { super(t), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; this.teardown(); const { onStop: l } = this.options; l && l() }; const { name: n, motionValue: r, element: i, keyframes: o } = this.options, s = (i == null ? void 0 : i.KeyframeResolver) || ay, a = (l, u) => this.onKeyframesResolved(l, u); this.resolver = new s(o, a, n, r, i), this.resolver.scheduleResolve() } flatten() { super.flatten(), this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes)) } initPlayback(t) { const { type: n = "keyframes", repeat: r = 0, repeatDelay: i = 0, repeatType: o, velocity: s = 0 } = this.options, a = fy(n) ? n : r3[n] || Nd; let l, u; a !== Nd && typeof t[0] != "number" && (l = ku(i3, cP(t[0], t[1])), t = [0, 100]); const c = a({ ...this.options, keyframes: t }); o === "mirror" && (u = a({ ...this.options, keyframes: [...t].reverse(), velocity: -s })), c.calculatedDuration === null && (c.calculatedDuration = sP(c)); const { calculatedDuration: d } = c, f = d + i, p = f * (r + 1) - i; return { generator: c, mirroredGenerator: u, mapPercentToKeyframes: l, calculatedDuration: d, resolvedDuration: f, totalDuration: p } } onPostResolved() { const { autoplay: t = !0 } = this.options; this.play(), this.pendingPlayState === "paused" || !t ? this.pause() : this.state = this.pendingPlayState } tick(t, n = !1) { const { resolved: r } = this; if (!r) { const { keyframes: b } = this.options; return { done: !0, value: b[b.length - 1] } } const { finalKeyframe: i, generator: o, mirroredGenerator: s, mapPercentToKeyframes: a, keyframes: l, calculatedDuration: u, totalDuration: c, resolvedDuration: d } = r; if (this.startTime === null) return o.next(0); const { delay: f, repeat: p, repeatType: m, repeatDelay: v, onUpdate: x } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - c / this.speed, this.startTime)), n ? this.currentTime = t : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(t - this.startTime) * this.speed; const g = this.currentTime - f * (this.speed >= 0 ? 1 : -1), h = this.speed >= 0 ? g < 0 : g > c; this.currentTime = Math.max(g, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = c); let y = this.currentTime, E = o; if (p) { const b = Math.min(this.currentTime, c) / d; let M = Math.floor(b), R = b % 1; !R && b >= 1 && (R = 1), R === 1 && M--, M = Math.min(M, p + 1), !!(M % 2) && (m === "reverse" ? (R = 1 - R, v && (R -= v / d)) : m === "mirror" && (E = s)), y = ii(0, 1, R) * d } const P = h ? { done: !1, value: l[0] } : E.next(y); a && (P.value = a(P.value)); let { done: $ } = P; !h && u !== null && ($ = this.speed >= 0 ? this.currentTime >= c : this.currentTime <= 0); const L = this.holdTime === null && (this.state === "finished" || this.state === "running" && $); return L && i !== void 0 && (P.value = Of(l, this.options, i)), x && x(P.value), L && this.finish(), P } get duration() { const { resolved: t } = this; return t ? Qr(t.calculatedDuration) : 0 } get time() { return Qr(this.currentTime) } set time(t) { t = Yr(t), this.currentTime = t, this.holdTime !== null || this.speed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.speed) } get speed() { return this.playbackSpeed } set speed(t) { const n = this.playbackSpeed !== t; this.playbackSpeed = t, n && (this.time = Qr(this.currentTime)) } play() { if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) { this.pendingPlayState = "running"; return } if (this.isStopped) return; const { driver: t = n3, onPlay: n, startTime: r } = this.options; this.driver || (this.driver = t(o => this.tick(o))), n && n(); const i = this.driver.now(); this.holdTime !== null ? this.startTime = i - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = i) : this.startTime = r ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start() } pause() { var t; if (!this._resolved) { this.pendingPlayState = "paused"; return } this.state = "paused", this.holdTime = (t = this.currentTime) !== null && t !== void 0 ? t : 0 } complete() { this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null } finish() { this.teardown(), this.state = "finished"; const { onComplete: t } = this.options; t && t() } cancel() { this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise() } teardown() { this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel() } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(t) { return this.startTime = 0, this.tick(t, !0) } } const o3 = new Set(["opacity", "clipPath", "filter", "transform"]); function gy(e) { let t; return () => (t === void 0 && (t = e()), t) } const s3 = { linearEasing: void 0 }; function a3(e, t) { const n = gy(e); return () => { var r; return (r = s3[t]) !== null && r !== void 0 ? r : n() } } const Od = a3(() => { try { document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" }) } catch { return !1 } return !0 }, "linearEasing"); function dP(e) { return !!(typeof e == "function" && Od() || !e || typeof e == "string" && (e in Ym || Od()) || py(e) || Array.isArray(e) && e.every(dP)) } const rl = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`, Ym = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: rl([0, .65, .55, 1]), circOut: rl([.55, 0, 1, .45]), backIn: rl([.31, .01, .66, -.59]), backOut: rl([.33, 1.53, .69, .99]) }; function fP(e, t) { if (e) return typeof e == "function" && Od() ? rP(e, t) : py(e) ? rl(e) : Array.isArray(e) ? e.map(n => fP(n, t) || Ym.easeOut) : Ym[e] } function l3(e, t, n, { delay: r = 0, duration: i = 300, repeat: o = 0, repeatType: s = "loop", ease: a = "easeInOut", times: l } = {}) { const u = { [t]: n }; l && (u.offset = l); const c = fP(a, i); return Array.isArray(c) && (u.easing = c), e.animate(u, { delay: r, duration: i, easing: Array.isArray(c) ? "linear" : c, fill: "both", iterations: o + 1, direction: s === "reverse" ? "alternate" : "normal" }) } function hw(e, t) { e.timeline = t, e.onfinish = null } const u3 = gy(() => Object.hasOwnProperty.call(Element.prototype, "animate")), jd = 10, c3 = 2e4; function d3(e) { return fy(e.type) || e.type === "spring" || !dP(e.ease) } function f3(e, t) { const n = new my({ ...t, keyframes: e, repeat: 0, delay: 0, isGenerator: !0 }); let r = { done: !1, value: e[0] }; const i = []; let o = 0; for (; !r.done && o < c3;)r = n.sample(o), i.push(r.value), o += jd; return { times: void 0, keyframes: i, duration: o - jd, ease: "linear" } } const pP = { anticipate: IC, backInOut: jC, circInOut: FC }; function p3(e) { return e in pP } class mw extends nP { constructor(t) { super(t); const { name: n, motionValue: r, element: i, keyframes: o } = this.options; this.resolver = new tP(o, (s, a) => this.onKeyframesResolved(s, a), n, r, i), this.resolver.scheduleResolve() } initPlayback(t, n) { var r; let { duration: i = 300, times: o, ease: s, type: a, motionValue: l, name: u, startTime: c } = this.options; if (!(!((r = l.owner) === null || r === void 0) && r.current)) return !1; if (typeof s == "string" && Od() && p3(s) && (s = pP[s]), d3(this.options)) { const { onComplete: f, onUpdate: p, motionValue: m, element: v, ...x } = this.options, g = f3(t, x); t = g.keyframes, t.length === 1 && (t[1] = t[0]), i = g.duration, o = g.times, s = g.ease, a = "keyframes" } const d = l3(l.owner.current, u, t, { ...this.options, duration: i, times: o, ease: s }); return d.startTime = c ?? this.calcStartTime(), this.pendingTimeline ? (hw(d, this.pendingTimeline), this.pendingTimeline = void 0) : d.onfinish = () => { const { onComplete: f } = this.options; l.set(Of(t, this.options, n)), f && f(), this.cancel(), this.resolveFinishedPromise() }, { animation: d, duration: i, times: o, type: a, ease: s, keyframes: t } } get duration() { const { resolved: t } = this; if (!t) return 0; const { duration: n } = t; return Qr(n) } get time() { const { resolved: t } = this; if (!t) return 0; const { animation: n } = t; return Qr(n.currentTime || 0) } set time(t) { const { resolved: n } = this; if (!n) return; const { animation: r } = n; r.currentTime = Yr(t) } get speed() { const { resolved: t } = this; if (!t) return 1; const { animation: n } = t; return n.playbackRate } set speed(t) { const { resolved: n } = this; if (!n) return; const { animation: r } = n; r.playbackRate = t } get state() { const { resolved: t } = this; if (!t) return "idle"; const { animation: n } = t; return n.playState } get startTime() { const { resolved: t } = this; if (!t) return null; const { animation: n } = t; return n.startTime } attachTimeline(t) { if (!this._resolved) this.pendingTimeline = t; else { const { resolved: n } = this; if (!n) return Mn; const { animation: r } = n; hw(r, t) } return Mn } play() { if (this.isStopped) return; const { resolved: t } = this; if (!t) return; const { animation: n } = t; n.playState === "finished" && this.updateFinishedPromise(), n.play() } pause() { const { resolved: t } = this; if (!t) return; const { animation: n } = t; n.pause() } stop() { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; this.resolveFinishedPromise(), this.updateFinishedPromise(); const { resolved: t } = this; if (!t) return; const { animation: n, keyframes: r, duration: i, type: o, ease: s, times: a } = t; if (n.playState === "idle" || n.playState === "finished") return; if (this.time) { const { motionValue: u, onUpdate: c, onComplete: d, element: f, ...p } = this.options, m = new my({ ...p, keyframes: r, duration: i, type: o, ease: s, times: a, isGenerator: !0 }), v = Yr(this.time); u.setWithVelocity(m.sample(v - jd).value, m.sample(v).value, jd) } const { onStop: l } = this.options; l && l(), this.cancel() } complete() { const { resolved: t } = this; t && t.animation.finish() } cancel() { const { resolved: t } = this; t && t.animation.cancel() } static supports(t) { const { motionValue: n, name: r, repeatDelay: i, repeatType: o, damping: s, type: a } = t; return u3() && r && o3.has(r) && n && n.owner && n.owner.current instanceof HTMLElement && !n.owner.getProps().onUpdate && !i && o !== "mirror" && s !== 0 && a !== "inertia" } } const h3 = gy(() => window.ScrollTimeline !== void 0); class m3 { constructor(t) { this.stop = () => this.runAll("stop"), this.animations = t.filter(Boolean) } then(t, n) { return Promise.all(this.animations).then(t).catch(n) } getAll(t) { return this.animations[0][t] } setAll(t, n) { for (let r = 0; r < this.animations.length; r++)this.animations[r][t] = n } attachTimeline(t, n) { const r = this.animations.map(i => h3() && i.attachTimeline ? i.attachTimeline(t) : n(i)); return () => { r.forEach((i, o) => { i && i(), this.animations[o].stop() }) } } get time() { return this.getAll("time") } set time(t) { this.setAll("time", t) } get speed() { return this.getAll("speed") } set speed(t) { this.setAll("speed", t) } get startTime() { return this.getAll("startTime") } get duration() { let t = 0; for (let n = 0; n < this.animations.length; n++)t = Math.max(t, this.animations[n].duration); return t } runAll(t) { this.animations.forEach(n => n[t]()) } flatten() { this.runAll("flatten") } play() { this.runAll("play") } pause() { this.runAll("pause") } cancel() { this.runAll("cancel") } complete() { this.runAll("complete") } } function g3({ when: e, delay: t, delayChildren: n, staggerChildren: r, staggerDirection: i, repeat: o, repeatType: s, repeatDelay: a, from: l, elapsed: u, ...c }) { return !!Object.keys(c).length } const vy = (e, t, n, r = {}, i, o) => s => { const a = ny(r, e) || {}, l = a.delay || r.delay || 0; let { elapsed: u = 0 } = r; u = u - Yr(l); let c = { keyframes: Array.isArray(n) ? n : [null, n], ease: "easeOut", velocity: t.getVelocity(), ...a, delay: -u, onUpdate: f => { t.set(f), a.onUpdate && a.onUpdate(f) }, onComplete: () => { s(), a.onComplete && a.onComplete() }, name: e, motionValue: t, element: o ? void 0 : i }; g3(a) || (c = { ...c, ...BN(e, c) }), c.duration && (c.duration = Yr(c.duration)), c.repeatDelay && (c.repeatDelay = Yr(c.repeatDelay)), c.from !== void 0 && (c.keyframes[0] = c.from); let d = !1; if ((c.type === !1 || c.duration === 0 && !c.repeatDelay) && (c.duration = 0, c.delay === 0 && (d = !0)), ry.skipAnimations && (d = !0, c.duration = 0, c.delay = 0), d && !o && t.get() !== void 0) { const f = Of(c.keyframes, a); if (f !== void 0) return qe.update(() => { c.onUpdate(f), c.onComplete() }), new m3([]) } return !o && mw.supports(c) ? new mw(c) : new my(c) }, v3 = e => !!(e && typeof e == "object" && e.mix && e.toValue), y3 = e => zm(e) ? e[e.length - 1] || 0 : e; function yy(e, t) { e.indexOf(t) === -1 && e.push(t) } function by(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } class wy { constructor() { this.subscriptions = [] } add(t) { return yy(this.subscriptions, t), () => by(this.subscriptions, t) } notify(t, n, r) { const i = this.subscriptions.length; if (i) if (i === 1) this.subscriptions[0](t, n, r); else for (let o = 0; o < i; o++) { const s = this.subscriptions[o]; s && s(t, n, r) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } const gw = 30, b3 = e => !isNaN(parseFloat(e)); class w3 { constructor(t, n = {}) { this.version = "11.15.0", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (r, i = !0) => { const o = _r.now(); this.updatedAt !== o && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), i && this.events.renderRequest && this.events.renderRequest.notify(this.current) }, this.hasAnimated = !1, this.setCurrent(t), this.owner = n.owner } setCurrent(t) { this.current = t, this.updatedAt = _r.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = b3(this.current)) } setPrevFrameValue(t = this.current) { this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt } onChange(t) { return this.on("change", t) } on(t, n) { this.events[t] || (this.events[t] = new wy); const r = this.events[t].add(n); return t === "change" ? () => { r(), qe.read(() => { this.events.change.getSize() || this.stop() }) } : r } clearListeners() { for (const t in this.events) this.events[t].clear() } attach(t, n) { this.passiveEffect = t, this.stopPassiveEffect = n } set(t, n = !0) { !n || !this.passiveEffect ? this.updateAndNotify(t, n) : this.passiveEffect(t, this.updateAndNotify) } setWithVelocity(t, n, r) { this.set(n), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - r } jump(t, n = !0) { this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } get() { return this.current } getPrevious() { return this.prev } getVelocity() { const t = _r.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > gw) return 0; const n = Math.min(this.updatedAt - this.prevUpdatedAt, gw); return iP(parseFloat(this.current) - parseFloat(this.prevFrameValue), n) } start(t) { return this.stop(), new Promise(n => { this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function Jl(e, t) { return new w3(e, t) } function x3(e, t, n) { e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, Jl(n)) } function S3(e, t) { const n = Nf(e, t); let { transitionEnd: r = {}, transition: i = {}, ...o } = n || {}; o = { ...o, ...r }; for (const s in o) { const a = y3(o[s]); x3(e, s, a) } } const xy = e => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), E3 = "framerAppearId", hP = "data-" + xy(E3); function mP(e) { return e.props[hP] } const Qt = e => !!(e && e.getVelocity); function T3(e) { return !!(Qt(e) && e.add) } function Qm(e, t) { const n = e.getValue("willChange"); if (T3(n)) return n.add(t) } function C3({ protectedKeys: e, needsAnimating: t }, n) { const r = e.hasOwnProperty(n) && t[n] !== !0; return t[n] = !1, r } function gP(e, t, { delay: n = 0, transitionOverride: r, type: i } = {}) { var o; let { transition: s = e.getDefaultTransition(), transitionEnd: a, ...l } = t; r && (s = r); const u = [], c = i && e.animationState && e.animationState.getState()[i]; for (const d in l) { const f = e.getValue(d, (o = e.latestValues[d]) !== null && o !== void 0 ? o : null), p = l[d]; if (p === void 0 || c && C3(c, d)) continue; const m = { delay: n, ...ny(s || {}, d) }; let v = !1; if (window.MotionHandoffAnimation) { const g = mP(e); if (g) { const h = window.MotionHandoffAnimation(g, d, qe); h !== null && (m.startTime = h, v = !0) } } Qm(e, d), f.start(vy(d, f, p, e.shouldReduceMotion && Xo.has(d) ? { type: !1 } : m, e, v)); const x = f.animation; x && u.push(x) } return a && Promise.all(u).then(() => { qe.update(() => { a && S3(e, a) }) }), u } function Xm(e, t, n = {}) { var r; const i = Nf(e, t, n.type === "exit" ? (r = e.presenceContext) === null || r === void 0 ? void 0 : r.custom : void 0); let { transition: o = e.getDefaultTransition() || {} } = i || {}; n.transitionOverride && (o = n.transitionOverride); const s = i ? () => Promise.all(gP(e, i, n)) : () => Promise.resolve(), a = e.variantChildren && e.variantChildren.size ? (u = 0) => { const { delayChildren: c = 0, staggerChildren: d, staggerDirection: f } = o; return P3(e, t, c + u, d, f, n) } : () => Promise.resolve(), { when: l } = o; if (l) { const [u, c] = l === "beforeChildren" ? [s, a] : [a, s]; return u().then(() => c()) } else return Promise.all([s(), a(n.delay)]) } function P3(e, t, n = 0, r = 0, i = 1, o) { const s = [], a = (e.variantChildren.size - 1) * r, l = i === 1 ? (u = 0) => u * r : (u = 0) => a - u * r; return Array.from(e.variantChildren).sort($3).forEach((u, c) => { u.notify("AnimationStart", t), s.push(Xm(u, t, { ...o, delay: n + l(c) }).then(() => u.notify("AnimationComplete", t))) }), Promise.all(s) } function $3(e, t) { return e.sortNodePosition(t) } function A3(e, t, n = {}) { e.notify("AnimationStart", t); let r; if (Array.isArray(t)) { const i = t.map(o => Xm(e, o, n)); r = Promise.all(i) } else if (typeof t == "string") r = Xm(e, t, n); else { const i = typeof t == "function" ? Nf(e, t, n.custom) : t; r = Promise.all(gP(e, i, n)) } return r.then(() => { e.notify("AnimationComplete", t) }) } const M3 = ty.length; function vP(e) { if (!e) return; if (!e.isControllingVariants) { const n = e.parent ? vP(e.parent) || {} : {}; return e.props.initial !== void 0 && (n.initial = e.props.initial), n } const t = {}; for (let n = 0; n < M3; n++) { const r = ty[n], i = e.props[r]; (Yl(i) || i === !1) && (t[r] = i) } return t } const k3 = [...ey].reverse(), _3 = ey.length; function R3(e) { return t => Promise.all(t.map(({ animation: n, options: r }) => A3(e, n, r))) } function L3(e) { let t = R3(e), n = vw(), r = !0; const i = l => (u, c) => { var d; const f = Nf(e, c, l === "exit" ? (d = e.presenceContext) === null || d === void 0 ? void 0 : d.custom : void 0); if (f) { const { transition: p, transitionEnd: m, ...v } = f; u = { ...u, ...v, ...m } } return u }; function o(l) { t = l(e) } function s(l) { const { props: u } = e, c = vP(e.parent) || {}, d = [], f = new Set; let p = {}, m = 1 / 0; for (let x = 0; x < _3; x++) { const g = k3[x], h = n[g], y = u[g] !== void 0 ? u[g] : c[g], E = Yl(y), P = g === l ? h.isActive : null; P === !1 && (m = x); let $ = y === c[g] && y !== u[g] && E; if ($ && r && e.manuallyAnimateOnMount && ($ = !1), h.protectedKeys = { ...p }, !h.isActive && P === null || !y && !h.prevProp || Lf(y) || typeof y == "boolean") continue; const L = N3(h.prevProp, y); let b = L || g === l && h.isActive && !$ && E || x > m && E, M = !1; const R = Array.isArray(y) ? y : [y]; let A = R.reduce(i(g), {}); P === !1 && (A = {}); const { prevResolvedValues: _ = {} } = h, C = { ..._, ...A }, k = z => { b = !0, f.has(z) && (M = !0, f.delete(z)), h.needsAnimating[z] = !0; const D = e.getValue(z); D && (D.liveStyle = !1) }; for (const z in C) { const D = A[z], V = _[z]; if (p.hasOwnProperty(z)) continue; let H = !1; zm(D) && zm(V) ? H = !kC(D, V) : H = D !== V, H ? D != null ? k(z) : f.add(z) : D !== void 0 && f.has(z) ? k(z) : h.protectedKeys[z] = !0 } h.prevProp = y, h.prevResolvedValues = A, h.isActive && (p = { ...p, ...A }), r && e.blockInitialAnimation && (b = !1), b && (!($ && L) || M) && d.push(...R.map(z => ({ animation: z, options: { type: g } }))) } if (f.size) { const x = {}; f.forEach(g => { const h = e.getBaseTarget(g), y = e.getValue(g); y && (y.liveStyle = !0), x[g] = h ?? null }), d.push({ animation: x }) } let v = !!d.length; return r && (u.initial === !1 || u.initial === u.animate) && !e.manuallyAnimateOnMount && (v = !1), r = !1, v ? t(d) : Promise.resolve() } function a(l, u) { var c; if (n[l].isActive === u) return Promise.resolve(); (c = e.variantChildren) === null || c === void 0 || c.forEach(f => { var p; return (p = f.animationState) === null || p === void 0 ? void 0 : p.setActive(l, u) }), n[l].isActive = u; const d = s(l); for (const f in n) n[f].protectedKeys = {}; return d } return { animateChanges: s, setActive: a, setAnimateFunction: o, getState: () => n, reset: () => { n = vw(), r = !0 } } } function N3(e, t) { return typeof t == "string" ? t !== e : Array.isArray(t) ? !kC(t, e) : !1 } function so(e = !1) { return { isActive: e, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function vw() { return { animate: so(!0), whileInView: so(), whileHover: so(), whileTap: so(), whileDrag: so(), whileFocus: so(), exit: so() } } class to { constructor(t) { this.isMounted = !1, this.node = t } update() { } } class O3 extends to { constructor(t) { super(t), t.animationState || (t.animationState = L3(t)) } updateAnimationControlsSubscription() { const { animate: t } = this.node.getProps(); Lf(t) && (this.unmountControls = t.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: t } = this.node.getProps(), { animate: n } = this.node.prevProps || {}; t !== n && this.updateAnimationControlsSubscription() } unmount() { var t; this.node.animationState.reset(), (t = this.unmountControls) === null || t === void 0 || t.call(this) } } let j3 = 0; class I3 extends to { constructor() { super(...arguments), this.id = j3++ } update() { if (!this.node.presenceContext) return; const { isPresent: t, onExitComplete: n } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {}; if (!this.node.animationState || t === r) return; const i = this.node.animationState.setActive("exit", !t); n && !t && i.then(() => n(this.id)) } mount() { const { register: t } = this.node.presenceContext || {}; t && (this.unmount = t(this.id)) } unmount() { } } const D3 = { animation: { Feature: O3 }, exit: { Feature: I3 } }, sr = { x: !1, y: !1 }; function yP() { return sr.x || sr.y } function F3(e, t, n) { var r; if (e instanceof Element) return [e]; if (typeof e == "string") { let i = document; const o = (r = void 0) !== null && r !== void 0 ? r : i.querySelectorAll(e); return o ? Array.from(o) : [] } return Array.from(e) } function bP(e, t) { const n = F3(e), r = new AbortController, i = { passive: !0, ...t, signal: r.signal }; return [n, i, () => r.abort()] } function yw(e) { return t => { t.pointerType === "touch" || yP() || e(t) } } function z3(e, t, n = {}) { const [r, i, o] = bP(e, n), s = yw(a => { const { target: l } = a, u = t(a); if (!u || !l) return; const c = yw(d => { u(d), l.removeEventListener("pointerleave", c) }); l.addEventListener("pointerleave", c, i) }); return r.forEach(a => { a.addEventListener("pointerenter", s, i) }), o } const Sy = e => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1, il = new WeakSet; function bw(e) { return t => { t.key === "Enter" && e(t) } } function zp(e, t) { e.dispatchEvent(new PointerEvent("pointer" + t, { isPrimary: !0, bubbles: !0 })) } const V3 = (e, t) => { const n = e.currentTarget; if (!n) return; const r = bw(() => { if (il.has(n)) return; zp(n, "down"); const i = bw(() => { zp(n, "up") }), o = () => zp(n, "cancel"); n.addEventListener("keyup", i, t), n.addEventListener("blur", o, t) }); n.addEventListener("keydown", r, t), n.addEventListener("blur", () => n.removeEventListener("keydown", r), t) }, B3 = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]); function U3(e) { return B3.has(e.tagName) || e.tabIndex !== -1 } const wP = (e, t) => t ? e === t ? !0 : wP(e, t.parentElement) : !1; function ww(e) { return Sy(e) && !yP() } function H3(e, t, n = {}) { const [r, i, o] = bP(e, n), s = a => { const l = a.currentTarget; if (!ww(a) || il.has(l)) return; il.add(l); const u = t(a), c = (p, m) => { window.removeEventListener("pointerup", d), window.removeEventListener("pointercancel", f), !(!ww(p) || !il.has(l)) && (il.delete(l), u && u(p, { success: m })) }, d = p => { c(p, n.useGlobalTarget || wP(l, p.target)) }, f = p => { c(p, !1) }; window.addEventListener("pointerup", d, i), window.addEventListener("pointercancel", f, i) }; return r.forEach(a => { U3(a) || (a.tabIndex = 0), (n.useGlobalTarget ? window : a).addEventListener("pointerdown", s, i), a.addEventListener("focus", u => V3(u, i), i) }), o } function W3(e) { return e === "x" || e === "y" ? sr[e] ? null : (sr[e] = !0, () => { sr[e] = !1 }) : sr.x || sr.y ? null : (sr.x = sr.y = !0, () => { sr.x = sr.y = !1 }) } function _u(e) { return { point: { x: e.pageX, y: e.pageY } } } const G3 = e => t => Sy(t) && e(t, _u(t)); function Zl(e, t, n, r = { passive: !0 }) { return e.addEventListener(t, n, r), () => e.removeEventListener(t, n) } function xl(e, t, n, r) { return Zl(e, t, G3(n), r) } const xw = (e, t) => Math.abs(e - t); function K3(e, t) { const n = xw(e.x, t.x), r = xw(e.y, t.y); return Math.sqrt(n ** 2 + r ** 2) } class xP { constructor(t, n, { transformPagePoint: r, contextWindow: i, dragSnapToOrigin: o = !1 } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; const d = Bp(this.lastMoveEventInfo, this.history), f = this.startEvent !== null, p = K3(d.offset, { x: 0, y: 0 }) >= 3; if (!f && !p) return; const { point: m } = d, { timestamp: v } = Ft; this.history.push({ ...m, timestamp: v }); const { onStart: x, onMove: g } = this.handlers; f || (x && x(this.lastMoveEvent, d), this.startEvent = this.lastMoveEvent), g && g(this.lastMoveEvent, d) }, this.handlePointerMove = (d, f) => { this.lastMoveEvent = d, this.lastMoveEventInfo = Vp(f, this.transformPagePoint), qe.update(this.updatePoint, !0) }, this.handlePointerUp = (d, f) => { this.end(); const { onEnd: p, onSessionEnd: m, resumeAnimation: v } = this.handlers; if (this.dragSnapToOrigin && v && v(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; const x = Bp(d.type === "pointercancel" ? this.lastMoveEventInfo : Vp(f, this.transformPagePoint), this.history); this.startEvent && p && p(d, x), m && m(d, x) }, !Sy(t)) return; this.dragSnapToOrigin = o, this.handlers = n, this.transformPagePoint = r, this.contextWindow = i || window; const s = _u(t), a = Vp(s, this.transformPagePoint), { point: l } = a, { timestamp: u } = Ft; this.history = [{ ...l, timestamp: u }]; const { onSessionStart: c } = n; c && c(t, Bp(a, this.history)), this.removeListeners = ku(xl(this.contextWindow, "pointermove", this.handlePointerMove), xl(this.contextWindow, "pointerup", this.handlePointerUp), xl(this.contextWindow, "pointercancel", this.handlePointerUp)) } updateHandlers(t) { this.handlers = t } end() { this.removeListeners && this.removeListeners(), qi(this.updatePoint) } } function Vp(e, t) { return t ? { point: t(e.point) } : e } function Sw(e, t) { return { x: e.x - t.x, y: e.y - t.y } } function Bp({ point: e }, t) { return { point: e, delta: Sw(e, SP(t)), offset: Sw(e, q3(t)), velocity: Y3(t, .1) } } function q3(e) { return e[0] } function SP(e) { return e[e.length - 1] } function Y3(e, t) { if (e.length < 2) return { x: 0, y: 0 }; let n = e.length - 1, r = null; const i = SP(e); for (; n >= 0 && (r = e[n], !(i.timestamp - r.timestamp > Yr(t)));)n--; if (!r) return { x: 0, y: 0 }; const o = Qr(i.timestamp - r.timestamp); if (o === 0) return { x: 0, y: 0 }; const s = { x: (i.x - r.x) / o, y: (i.y - r.y) / o }; return s.x === 1 / 0 && (s.x = 0), s.y === 1 / 0 && (s.y = 0), s } function Rs(e) { return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current") } const EP = 1e-4, Q3 = 1 - EP, X3 = 1 + EP, TP = .01, J3 = 0 - TP, Z3 = 0 + TP; function Ln(e) { return e.max - e.min } function ej(e, t, n) { return Math.abs(e - t) <= n } function Ew(e, t, n, r = .5) { e.origin = r, e.originPoint = et(t.min, t.max, e.origin), e.scale = Ln(n) / Ln(t), e.translate = et(n.min, n.max, e.origin) - e.originPoint, (e.scale >= Q3 && e.scale <= X3 || isNaN(e.scale)) && (e.scale = 1), (e.translate >= J3 && e.translate <= Z3 || isNaN(e.translate)) && (e.translate = 0) } function Sl(e, t, n, r) { Ew(e.x, t.x, n.x, r ? r.originX : void 0), Ew(e.y, t.y, n.y, r ? r.originY : void 0) } function Tw(e, t, n) { e.min = n.min + t.min, e.max = e.min + Ln(t) } function tj(e, t, n) { Tw(e.x, t.x, n.x), Tw(e.y, t.y, n.y) } function Cw(e, t, n) { e.min = t.min - n.min, e.max = e.min + Ln(t) } function El(e, t, n) { Cw(e.x, t.x, n.x), Cw(e.y, t.y, n.y) } function nj(e, { min: t, max: n }, r) { return t !== void 0 && e < t ? e = r ? et(t, e, r.min) : Math.max(e, t) : n !== void 0 && e > n && (e = r ? et(n, e, r.max) : Math.min(e, n)), e } function Pw(e, t, n) { return { min: t !== void 0 ? e.min + t : void 0, max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0 } } function rj(e, { top: t, left: n, bottom: r, right: i }) { return { x: Pw(e.x, n, i), y: Pw(e.y, t, r) } } function $w(e, t) { let n = t.min - e.min, r = t.max - e.max; return t.max - t.min < e.max - e.min && ([n, r] = [r, n]), { min: n, max: r } } function ij(e, t) { return { x: $w(e.x, t.x), y: $w(e.y, t.y) } } function oj(e, t) { let n = .5; const r = Ln(e), i = Ln(t); return i > r ? n = sa(t.min, t.max - r, e.min) : r > i && (n = sa(e.min, e.max - i, t.min)), ii(0, 1, n) } function sj(e, t) { const n = {}; return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n } const Jm = .35; function aj(e = Jm) { return e === !1 ? e = 0 : e === !0 && (e = Jm), { x: Aw(e, "left", "right"), y: Aw(e, "top", "bottom") } } function Aw(e, t, n) { return { min: Mw(e, t), max: Mw(e, n) } } function Mw(e, t) { return typeof e == "number" ? e : e[t] || 0 } const kw = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), Ls = () => ({ x: kw(), y: kw() }), _w = () => ({ min: 0, max: 0 }), ft = () => ({ x: _w(), y: _w() }); function Un(e) { return [e("x"), e("y")] } function CP({ top: e, left: t, right: n, bottom: r }) { return { x: { min: t, max: n }, y: { min: e, max: r } } } function lj({ x: e, y: t }) { return { top: t.min, right: e.max, bottom: t.max, left: e.min } } function uj(e, t) { if (!t) return e; const n = t({ x: e.left, y: e.top }), r = t({ x: e.right, y: e.bottom }); return { top: n.y, left: n.x, bottom: r.y, right: r.x } } function Up(e) { return e === void 0 || e === 1 } function Zm({ scale: e, scaleX: t, scaleY: n }) { return !Up(e) || !Up(t) || !Up(n) } function uo(e) { return Zm(e) || PP(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY } function PP(e) { return Rw(e.x) || Rw(e.y) } function Rw(e) { return e && e !== "0%" } function Id(e, t, n) { const r = e - n, i = t * r; return n + i } function Lw(e, t, n, r, i) { return i !== void 0 && (e = Id(e, i, r)), Id(e, n, r) + t } function eg(e, t = 0, n = 1, r, i) { e.min = Lw(e.min, t, n, r, i), e.max = Lw(e.max, t, n, r, i) } function $P(e, { x: t, y: n }) { eg(e.x, t.translate, t.scale, t.originPoint), eg(e.y, n.translate, n.scale, n.originPoint) } const Nw = .999999999999, Ow = 1.0000000000001; function cj(e, t, n, r = !1) { const i = n.length; if (!i) return; t.x = t.y = 1; let o, s; for (let a = 0; a < i; a++) { o = n[a], s = o.projectionDelta; const { visualElement: l } = o.options; l && l.props.style && l.props.style.display === "contents" || (r && o.options.layoutScroll && o.scroll && o !== o.root && Os(e, { x: -o.scroll.offset.x, y: -o.scroll.offset.y }), s && (t.x *= s.x.scale, t.y *= s.y.scale, $P(e, s)), r && uo(o.latestValues) && Os(e, o.latestValues)) } t.x < Ow && t.x > Nw && (t.x = 1), t.y < Ow && t.y > Nw && (t.y = 1) } function Ns(e, t) { e.min = e.min + t, e.max = e.max + t } function jw(e, t, n, r, i = .5) { const o = et(e.min, e.max, i); eg(e, t, n, o, r) } function Os(e, t) { jw(e.x, t.x, t.scaleX, t.scale, t.originX), jw(e.y, t.y, t.scaleY, t.scale, t.originY) } function AP(e, t) { return CP(uj(e.getBoundingClientRect(), t)) } function dj(e, t, n) { const r = AP(e, n), { scroll: i } = t; return i && (Ns(r.x, i.offset.x), Ns(r.y, i.offset.y)), r } const MP = ({ current: e }) => e ? e.ownerDocument.defaultView : null, fj = new WeakMap; class pj { constructor(t) { this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = ft(), this.visualElement = t } start(t, { snapToCursor: n = !1 } = {}) { const { presenceContext: r } = this.visualElement; if (r && r.isPresent === !1) return; const i = c => { const { dragSnapToOrigin: d } = this.getProps(); d ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(_u(c).point) }, o = (c, d) => { const { drag: f, dragPropagation: p, onDragStart: m } = this.getProps(); if (f && !p && (this.openDragLock && this.openDragLock(), this.openDragLock = W3(f), !this.openDragLock)) return; this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Un(x => { let g = this.getAxisMotionValue(x).get() || 0; if (kr.test(g)) { const { projection: h } = this.visualElement; if (h && h.layout) { const y = h.layout.layoutBox[x]; y && (g = Ln(y) * (parseFloat(g) / 100)) } } this.originPoint[x] = g }), m && qe.postRender(() => m(c, d)), Qm(this.visualElement, "transform"); const { animationState: v } = this.visualElement; v && v.setActive("whileDrag", !0) }, s = (c, d) => { const { dragPropagation: f, dragDirectionLock: p, onDirectionLock: m, onDrag: v } = this.getProps(); if (!f && !this.openDragLock) return; const { offset: x } = d; if (p && this.currentDirection === null) { this.currentDirection = hj(x), this.currentDirection !== null && m && m(this.currentDirection); return } this.updateAxis("x", d.point, x), this.updateAxis("y", d.point, x), this.visualElement.render(), v && v(c, d) }, a = (c, d) => this.stop(c, d), l = () => Un(c => { var d; return this.getAnimationState(c) === "paused" && ((d = this.getAxisMotionValue(c).animation) === null || d === void 0 ? void 0 : d.play()) }), { dragSnapToOrigin: u } = this.getProps(); this.panSession = new xP(t, { onSessionStart: i, onStart: o, onMove: s, onSessionEnd: a, resumeAnimation: l }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: u, contextWindow: MP(this.visualElement) }) } stop(t, n) { const r = this.isDragging; if (this.cancel(), !r) return; const { velocity: i } = n; this.startAnimation(i); const { onDragEnd: o } = this.getProps(); o && qe.postRender(() => o(t, n)) } cancel() { this.isDragging = !1; const { projection: t, animationState: n } = this.visualElement; t && (t.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; const { dragPropagation: r } = this.getProps(); !r && this.openDragLock && (this.openDragLock(), this.openDragLock = null), n && n.setActive("whileDrag", !1) } updateAxis(t, n, r) { const { drag: i } = this.getProps(); if (!r || !mc(t, i, this.currentDirection)) return; const o = this.getAxisMotionValue(t); let s = this.originPoint[t] + r[t]; this.constraints && this.constraints[t] && (s = nj(s, this.constraints[t], this.elastic[t])), o.set(s) } resolveConstraints() { var t; const { dragConstraints: n, dragElastic: r } = this.getProps(), i = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (t = this.visualElement.projection) === null || t === void 0 ? void 0 : t.layout, o = this.constraints; n && Rs(n) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : n && i ? this.constraints = rj(i.layoutBox, n) : this.constraints = !1, this.elastic = aj(r), o !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && Un(s => { this.constraints !== !1 && this.getAxisMotionValue(s) && (this.constraints[s] = sj(i.layoutBox[s], this.constraints[s])) }) } resolveRefConstraints() { const { dragConstraints: t, onMeasureDragConstraints: n } = this.getProps(); if (!t || !Rs(t)) return !1; const r = t.current, { projection: i } = this.visualElement; if (!i || !i.layout) return !1; const o = dj(r, i.root, this.visualElement.getTransformPagePoint()); let s = ij(i.layout.layoutBox, o); if (n) { const a = n(lj(s)); this.hasMutatedConstraints = !!a, a && (s = CP(a)) } return s } startAnimation(t) { const { drag: n, dragMomentum: r, dragElastic: i, dragTransition: o, dragSnapToOrigin: s, onDragTransitionEnd: a } = this.getProps(), l = this.constraints || {}, u = Un(c => { if (!mc(c, n, this.currentDirection)) return; let d = l && l[c] || {}; s && (d = { min: 0, max: 0 }); const f = i ? 200 : 1e6, p = i ? 40 : 1e7, m = { type: "inertia", velocity: r ? t[c] : 0, bounceStiffness: f, bounceDamping: p, timeConstant: 750, restDelta: 1, restSpeed: 10, ...o, ...d }; return this.startAxisValueAnimation(c, m) }); return Promise.all(u).then(a) } startAxisValueAnimation(t, n) { const r = this.getAxisMotionValue(t); return Qm(this.visualElement, t), r.start(vy(t, r, 0, n, this.visualElement, !1)) } stopAnimation() { Un(t => this.getAxisMotionValue(t).stop()) } pauseAnimation() { Un(t => { var n; return (n = this.getAxisMotionValue(t).animation) === null || n === void 0 ? void 0 : n.pause() }) } getAnimationState(t) { var n; return (n = this.getAxisMotionValue(t).animation) === null || n === void 0 ? void 0 : n.state } getAxisMotionValue(t) { const n = `_drag${t.toUpperCase()}`, r = this.visualElement.getProps(), i = r[n]; return i || this.visualElement.getValue(t, (r.initial ? r.initial[t] : void 0) || 0) } snapToCursor(t) { Un(n => { const { drag: r } = this.getProps(); if (!mc(n, r, this.currentDirection)) return; const { projection: i } = this.visualElement, o = this.getAxisMotionValue(n); if (i && i.layout) { const { min: s, max: a } = i.layout.layoutBox[n]; o.set(t[n] - et(s, a, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: t, dragConstraints: n } = this.getProps(), { projection: r } = this.visualElement; if (!Rs(n) || !r || !this.constraints) return; this.stopAnimation(); const i = { x: 0, y: 0 }; Un(s => { const a = this.getAxisMotionValue(s); if (a && this.constraints !== !1) { const l = a.get(); i[s] = oj({ min: l, max: l }, this.constraints[s]) } }); const { transformTemplate: o } = this.visualElement.getProps(); this.visualElement.current.style.transform = o ? o({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.resolveConstraints(), Un(s => { if (!mc(s, t, null)) return; const a = this.getAxisMotionValue(s), { min: l, max: u } = this.constraints[s]; a.set(et(l, u, i[s])) }) } addListeners() { if (!this.visualElement.current) return; fj.set(this.visualElement, this); const t = this.visualElement.current, n = xl(t, "pointerdown", l => { const { drag: u, dragListener: c = !0 } = this.getProps(); u && c && this.start(l) }), r = () => { const { dragConstraints: l } = this.getProps(); Rs(l) && l.current && (this.constraints = this.resolveRefConstraints()) }, { projection: i } = this.visualElement, o = i.addEventListener("measure", r); i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), qe.read(r); const s = Zl(window, "resize", () => this.scalePositionWithinConstraints()), a = i.addEventListener("didUpdate", ({ delta: l, hasLayoutChanged: u }) => { this.isDragging && u && (Un(c => { const d = this.getAxisMotionValue(c); d && (this.originPoint[c] += l[c].translate, d.set(d.get() + l[c].translate)) }), this.visualElement.render()) }); return () => { s(), n(), o(), a && a() } } getProps() { const t = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: r = !1, dragPropagation: i = !1, dragConstraints: o = !1, dragElastic: s = Jm, dragMomentum: a = !0 } = t; return { ...t, drag: n, dragDirectionLock: r, dragPropagation: i, dragConstraints: o, dragElastic: s, dragMomentum: a } } } function mc(e, t, n) { return (t === !0 || t === e) && (n === null || n === e) } function hj(e, t = 10) { let n = null; return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n } class mj extends to { constructor(t) { super(t), this.removeGroupControls = Mn, this.removeListeners = Mn, this.controls = new pj(t) } mount() { const { dragControls: t } = this.node.getProps(); t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Mn } unmount() { this.removeGroupControls(), this.removeListeners() } } const Iw = e => (t, n) => { e && qe.postRender(() => e(t, n)) }; class gj extends to { constructor() { super(...arguments), this.removePointerDownListener = Mn } onPointerDown(t) { this.session = new xP(t, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: MP(this.node) }) } createPanHandlers() { const { onPanSessionStart: t, onPanStart: n, onPan: r, onPanEnd: i } = this.node.getProps(); return { onSessionStart: Iw(t), onStart: Iw(n), onMove: r, onEnd: (o, s) => { delete this.session, i && qe.postRender(() => i(o, s)) } } } mount() { this.removePointerDownListener = xl(this.node.current, "pointerdown", t => this.onPointerDown(t)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } const jf = S.createContext(null); function vj() { const e = S.useContext(jf); if (e === null) return [!0, null]; const { isPresent: t, onExitComplete: n, register: r } = e, i = S.useId(); S.useEffect(() => r(i), []); const o = S.useCallback(() => n && n(i), [i, n]); return !t && n ? [!1, o] : [!0] } const Ey = S.createContext({}), kP = S.createContext({}), qc = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; function Dw(e, t) { return t.max === t.min ? 0 : e / (t.max - t.min) * 100 } const Na = { correct: (e, t) => { if (!t.target) return e; if (typeof e == "string") if (ve.test(e)) e = parseFloat(e); else return e; const n = Dw(e, t.target.x), r = Dw(e, t.target.y); return `${n}% ${r}%` } }, yj = { correct: (e, { treeScale: t, projectionDelta: n }) => { const r = e, i = Yi.parse(e); if (i.length > 5) return r; const o = Yi.createTransformer(e), s = typeof i[0] != "number" ? 1 : 0, a = n.x.scale * t.x, l = n.y.scale * t.y; i[0 + s] /= a, i[1 + s] /= l; const u = et(a, l, .5); return typeof i[2 + s] == "number" && (i[2 + s] /= u), typeof i[3 + s] == "number" && (i[3 + s] /= u), o(i) } }, Dd = {}; function bj(e) { Object.assign(Dd, e) } const { schedule: Ty, cancel: nW } = _C(queueMicrotask, !1); class wj extends S.Component { componentDidMount() { const { visualElement: t, layoutGroup: n, switchLayoutGroup: r, layoutId: i } = this.props, { projection: o } = t; bj(xj), o && (n.group && n.group.add(o), r && r.register && i && r.register(o), o.root.didUpdate(), o.addEventListener("animationComplete", () => { this.safeToRemove() }), o.setOptions({ ...o.options, onExitComplete: () => this.safeToRemove() })), qc.hasEverUpdated = !0 } getSnapshotBeforeUpdate(t) { const { layoutDependency: n, visualElement: r, drag: i, isPresent: o } = this.props, s = r.projection; return s && (s.isPresent = o, i || t.layoutDependency !== n || n === void 0 ? s.willUpdate() : this.safeToRemove(), t.isPresent !== o && (o ? s.promote() : s.relegate() || qe.postRender(() => { const a = s.getStack(); (!a || !a.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { const { projection: t } = this.props.visualElement; t && (t.root.didUpdate(), Ty.postRender(() => { !t.currentAnimation && t.isLead() && this.safeToRemove() })) } componentWillUnmount() { const { visualElement: t, layoutGroup: n, switchLayoutGroup: r } = this.props, { projection: i } = t; i && (i.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(i), r && r.deregister && r.deregister(i)) } safeToRemove() { const { safeToRemove: t } = this.props; t && t() } render() { return null } } function _P(e) { const [t, n] = vj(), r = S.useContext(Ey); return w.jsx(wj, { ...e, layoutGroup: r, switchLayoutGroup: S.useContext(kP), isPresent: t, safeToRemove: n }) } const xj = { borderRadius: { ...Na, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: Na, borderTopRightRadius: Na, borderBottomLeftRadius: Na, borderBottomRightRadius: Na, boxShadow: yj }, RP = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], Sj = RP.length, Fw = e => typeof e == "string" ? parseFloat(e) : e, zw = e => typeof e == "number" || ve.test(e); function Ej(e, t, n, r, i, o) { i ? (e.opacity = et(0, n.opacity !== void 0 ? n.opacity : 1, Tj(r)), e.opacityExit = et(t.opacity !== void 0 ? t.opacity : 1, 0, Cj(r))) : o && (e.opacity = et(t.opacity !== void 0 ? t.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, r)); for (let s = 0; s < Sj; s++) { const a = `border${RP[s]}Radius`; let l = Vw(t, a), u = Vw(n, a); if (l === void 0 && u === void 0) continue; l || (l = 0), u || (u = 0), l === 0 || u === 0 || zw(l) === zw(u) ? (e[a] = Math.max(et(Fw(l), Fw(u), r), 0), (kr.test(u) || kr.test(l)) && (e[a] += "%")) : e[a] = u } (t.rotate || n.rotate) && (e.rotate = et(t.rotate || 0, n.rotate || 0, r)) } function Vw(e, t) { return e[t] !== void 0 ? e[t] : e.borderRadius } const Tj = LP(0, .5, DC), Cj = LP(.5, .95, Mn); function LP(e, t, n) { return r => r < e ? 0 : r > t ? 1 : n(sa(e, t, r)) } function Bw(e, t) { e.min = t.min, e.max = t.max } function Bn(e, t) { Bw(e.x, t.x), Bw(e.y, t.y) } function Uw(e, t) { e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin } function Hw(e, t, n, r, i) { return e -= t, e = Id(e, 1 / n, r), i !== void 0 && (e = Id(e, 1 / i, r)), e } function Pj(e, t = 0, n = 1, r = .5, i, o = e, s = e) { if (kr.test(t) && (t = parseFloat(t), t = et(s.min, s.max, t / 100) - s.min), typeof t != "number") return; let a = et(o.min, o.max, r); e === o && (a -= t), e.min = Hw(e.min, t, n, a, i), e.max = Hw(e.max, t, n, a, i) } function Ww(e, t, [n, r, i], o, s) { Pj(e, t[n], t[r], t[i], t.scale, o, s) } const $j = ["x", "scaleX", "originX"], Aj = ["y", "scaleY", "originY"]; function Gw(e, t, n, r) { Ww(e.x, t, $j, n ? n.x : void 0, r ? r.x : void 0), Ww(e.y, t, Aj, n ? n.y : void 0, r ? r.y : void 0) } function Kw(e) { return e.translate === 0 && e.scale === 1 } function NP(e) { return Kw(e.x) && Kw(e.y) } function qw(e, t) { return e.min === t.min && e.max === t.max } function Mj(e, t) { return qw(e.x, t.x) && qw(e.y, t.y) } function Yw(e, t) { return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max) } function OP(e, t) { return Yw(e.x, t.x) && Yw(e.y, t.y) } function Qw(e) { return Ln(e.x) / Ln(e.y) } function Xw(e, t) { return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint } class kj { constructor() { this.members = [] } add(t) { yy(this.members, t), t.scheduleRender() } remove(t) { if (by(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) { const n = this.members[this.members.length - 1]; n && this.promote(n) } } relegate(t) { const n = this.members.findIndex(i => t === i); if (n === 0) return !1; let r; for (let i = n; i >= 0; i--) { const o = this.members[i]; if (o.isPresent !== !1) { r = o; break } } return r ? (this.promote(r), !0) : !1 } promote(t, n) { const r = this.lead; if (t !== r && (this.prevLead = r, this.lead = t, t.show(), r)) { r.instance && r.scheduleRender(), t.scheduleRender(), t.resumeFrom = r, n && (t.resumeFrom.preserveOpacity = !0), r.snapshot && (t.snapshot = r.snapshot, t.snapshot.latestValues = r.animationValues || r.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0); const { crossfade: i } = t.options; i === !1 && r.hide() } } exitAnimationComplete() { this.members.forEach(t => { const { options: n, resumingFrom: r } = t; n.onExitComplete && n.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete() }) } scheduleRender() { this.members.forEach(t => { t.instance && t.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } function _j(e, t, n) { let r = ""; const i = e.x.translate / t.x, o = e.y.translate / t.y, s = (n == null ? void 0 : n.z) || 0; if ((i || o || s) && (r = `translate3d(${i}px, ${o}px, ${s}px) `), (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `), n) { const { transformPerspective: u, rotate: c, rotateX: d, rotateY: f, skewX: p, skewY: m } = n; u && (r = `perspective(${u}px) ${r}`), c && (r += `rotate(${c}deg) `), d && (r += `rotateX(${d}deg) `), f && (r += `rotateY(${f}deg) `), p && (r += `skewX(${p}deg) `), m && (r += `skewY(${m}deg) `) } const a = e.x.scale * t.x, l = e.y.scale * t.y; return (a !== 1 || l !== 1) && (r += `scale(${a}, ${l})`), r || "none" } const Rj = (e, t) => e.depth - t.depth; class Lj { constructor() { this.children = [], this.isDirty = !1 } add(t) { yy(this.children, t), this.isDirty = !0 } remove(t) { by(this.children, t), this.isDirty = !0 } forEach(t) { this.isDirty && this.children.sort(Rj), this.isDirty = !1, this.children.forEach(t) } } function Yc(e) { const t = Qt(e) ? e.get() : e; return v3(t) ? t.toValue() : t } function Nj(e, t) { const n = _r.now(), r = ({ timestamp: i }) => { const o = i - n; o >= t && (qi(r), e(o - t)) }; return qe.read(r, !0), () => qi(r) } function Oj(e) { return e instanceof SVGElement && e.tagName !== "svg" } function jj(e, t, n) { const r = Qt(e) ? e : Jl(e); return r.start(vy("", r, t, n)), r.animation } const co = { type: "projectionFrame", totalNodes: 0, resolvedTargetDeltas: 0, recalculatedProjection: 0 }, ol = typeof window < "u" && window.MotionDebug !== void 0, Hp = ["", "X", "Y", "Z"], Ij = { visibility: "hidden" }, Jw = 1e3; let Dj = 0; function Wp(e, t, n, r) { const { latestValues: i } = t; i[e] && (n[e] = i[e], t.setStaticValue(e, 0), r && (r[e] = 0)) } function jP(e) { if (e.hasCheckedOptimisedAppear = !0, e.root === e) return; const { visualElement: t } = e.options; if (!t) return; const n = mP(t); if (window.MotionHasOptimisedAnimation(n, "transform")) { const { layout: i, layoutId: o } = e.options; window.MotionCancelOptimisedAnimation(n, "transform", qe, !(i || o)) } const { parent: r } = e; r && !r.hasCheckedOptimisedAppear && jP(r) } function IP({ attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: r, resetTransform: i }) { return class { constructor(s = {}, a = t == null ? void 0 : t()) { this.id = Dj++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, ol && (co.totalNodes = co.resolvedTargetDeltas = co.recalculatedProjection = 0), this.nodes.forEach(Vj), this.nodes.forEach(Gj), this.nodes.forEach(Kj), this.nodes.forEach(Bj), ol && window.MotionDebug.record(co) }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = s, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0; for (let l = 0; l < this.path.length; l++)this.path[l].shouldResetTransform = !0; this.root === this && (this.nodes = new Lj) } addEventListener(s, a) { return this.eventHandlers.has(s) || this.eventHandlers.set(s, new wy), this.eventHandlers.get(s).add(a) } notifyListeners(s, ...a) { const l = this.eventHandlers.get(s); l && l.notify(...a) } hasListeners(s) { return this.eventHandlers.has(s) } mount(s, a = this.root.hasTreeAnimated) { if (this.instance) return; this.isSVG = Oj(s), this.instance = s; const { layoutId: l, layout: u, visualElement: c } = this.options; if (c && !c.current && c.mount(s), this.root.nodes.add(this), this.parent && this.parent.children.add(this), a && (u || l) && (this.isLayoutDirty = !0), e) { let d; const f = () => this.root.updateBlockedByResize = !1; e(s, () => { this.root.updateBlockedByResize = !0, d && d(), d = Nj(f, 250), qc.hasAnimatedSinceResize && (qc.hasAnimatedSinceResize = !1, this.nodes.forEach(ex)) }) } l && this.root.registerSharedNode(l, this), this.options.animate !== !1 && c && (l || u) && this.addEventListener("didUpdate", ({ delta: d, hasLayoutChanged: f, hasRelativeTargetChanged: p, layout: m }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } const v = this.options.transition || c.getDefaultTransition() || Jj, { onLayoutAnimationStart: x, onLayoutAnimationComplete: g } = c.getProps(), h = !this.targetLayout || !OP(this.targetLayout, m) || p, y = !f && p; if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || y || f && (h || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(d, y); const E = { ...ny(v, "layout"), onPlay: x, onComplete: g }; (c.shouldReduceMotion || this.options.layoutRoot) && (E.delay = 0, E.type = !1), this.startAnimation(E) } else f || ex(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = m }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const s = this.getStack(); s && s.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, qi(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(qj), this.animationId++) } getTransformTemplate() { const { visualElement: s } = this.options; return s && s.getProps().transformTemplate } willUpdate(s = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && jP(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let c = 0; c < this.path.length; c++) { const d = this.path[c]; d.shouldResetTransform = !0, d.updateScroll("snapshot"), d.options.layoutRoot && d.willUpdate(!1) } const { layoutId: a, layout: l } = this.options; if (a === void 0 && !l) return; const u = this.getTransformTemplate(); this.prevTransformTemplateValue = u ? u(this.latestValues, "") : void 0, this.updateSnapshot(), s && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Zw); return } this.isUpdating || this.nodes.forEach(Hj), this.isUpdating = !1, this.nodes.forEach(Wj), this.nodes.forEach(Fj), this.nodes.forEach(zj), this.clearAllSnapshots(); const a = _r.now(); Ft.delta = ii(0, 1e3 / 60, a - Ft.timestamp), Ft.timestamp = a, Ft.isProcessing = !0, Op.update.process(Ft), Op.preRender.process(Ft), Op.render.process(Ft), Ft.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, Ty.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(Uj), this.sharedNodes.forEach(Yj) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, qe.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { qe.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure()) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let l = 0; l < this.path.length; l++)this.path[l].updateScroll(); const s = this.layout; this.layout = this.measure(!1), this.layoutCorrected = ft(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: a } = this.options; a && a.notify("LayoutMeasure", this.layout.layoutBox, s ? s.layoutBox : void 0) } updateScroll(s = "measure") { let a = !!(this.options.layoutScroll && this.instance); if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === s && (a = !1), a) { const l = r(this.instance); this.scroll = { animationId: this.root.animationId, phase: s, isRoot: l, offset: n(this.instance), wasRoot: this.scroll ? this.scroll.isRoot : l } } } resetTransform() { if (!i) return; const s = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, a = this.projectionDelta && !NP(this.projectionDelta), l = this.getTransformTemplate(), u = l ? l(this.latestValues, "") : void 0, c = u !== this.prevTransformTemplateValue; s && (a || uo(this.latestValues) || c) && (i(this.instance, u), this.shouldResetTransform = !1, this.scheduleRender()) } measure(s = !0) { const a = this.measurePageBox(); let l = this.removeElementScroll(a); return s && (l = this.removeTransform(l)), Zj(l), { animationId: this.root.animationId, measuredBox: a, layoutBox: l, latestValues: {}, source: this.id } } measurePageBox() { var s; const { visualElement: a } = this.options; if (!a) return ft(); const l = a.measureViewportBox(); if (!(((s = this.scroll) === null || s === void 0 ? void 0 : s.wasRoot) || this.path.some(eI))) { const { scroll: c } = this.root; c && (Ns(l.x, c.offset.x), Ns(l.y, c.offset.y)) } return l } removeElementScroll(s) { var a; const l = ft(); if (Bn(l, s), !((a = this.scroll) === null || a === void 0) && a.wasRoot) return l; for (let u = 0; u < this.path.length; u++) { const c = this.path[u], { scroll: d, options: f } = c; c !== this.root && d && f.layoutScroll && (d.wasRoot && Bn(l, s), Ns(l.x, d.offset.x), Ns(l.y, d.offset.y)) } return l } applyTransform(s, a = !1) { const l = ft(); Bn(l, s); for (let u = 0; u < this.path.length; u++) { const c = this.path[u]; !a && c.options.layoutScroll && c.scroll && c !== c.root && Os(l, { x: -c.scroll.offset.x, y: -c.scroll.offset.y }), uo(c.latestValues) && Os(l, c.latestValues) } return uo(this.latestValues) && Os(l, this.latestValues), l } removeTransform(s) { const a = ft(); Bn(a, s); for (let l = 0; l < this.path.length; l++) { const u = this.path[l]; if (!u.instance || !uo(u.latestValues)) continue; Zm(u.latestValues) && u.updateSnapshot(); const c = ft(), d = u.measurePageBox(); Bn(c, d), Gw(a, u.latestValues, u.snapshot ? u.snapshot.layoutBox : void 0, c) } return uo(this.latestValues) && Gw(a, this.latestValues), a } setTargetDelta(s) { this.targetDelta = s, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(s) { this.options = { ...this.options, ...s, crossfade: s.crossfade !== void 0 ? s.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Ft.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(s = !1) { var a; const l = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = l.isSharedProjectionDirty); const u = !!this.resumingFrom || this !== l; if (!(s || u && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; const { layout: d, layoutId: f } = this.options; if (!(!this.layout || !(d || f))) { if (this.resolvedRelativeTargetAt = Ft.timestamp, !this.targetDelta && !this.relativeTarget) { const p = this.getClosestProjectingParent(); p && p.layout && this.animationProgress !== 1 ? (this.relativeParent = p, this.forceRelativeParentToResolveTarget(), this.relativeTarget = ft(), this.relativeTargetOrigin = ft(), El(this.relativeTargetOrigin, this.layout.layoutBox, p.layout.layoutBox), Bn(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } if (!(!this.relativeTarget && !this.targetDelta)) { if (this.target || (this.target = ft(), this.targetWithTransforms = ft()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), tj(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Bn(this.target, this.layout.layoutBox), $P(this.target, this.targetDelta)) : Bn(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) { this.attemptToResolveRelativeTarget = !1; const p = this.getClosestProjectingParent(); p && !!p.resumingFrom == !!this.resumingFrom && !p.options.layoutScroll && p.target && this.animationProgress !== 1 ? (this.relativeParent = p, this.forceRelativeParentToResolveTarget(), this.relativeTarget = ft(), this.relativeTargetOrigin = ft(), El(this.relativeTargetOrigin, this.target, p.target), Bn(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } ol && co.resolvedTargetDeltas++ } } } getClosestProjectingParent() { if (!(!this.parent || Zm(this.parent.latestValues) || PP(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } calcProjection() { var s; const a = this.getLead(), l = !!this.resumingFrom || this !== a; let u = !0; if ((this.isProjectionDirty || !((s = this.parent) === null || s === void 0) && s.isProjectionDirty) && (u = !1), l && (this.isSharedProjectionDirty || this.isTransformDirty) && (u = !1), this.resolvedRelativeTargetAt === Ft.timestamp && (u = !1), u) return; const { layout: c, layoutId: d } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(c || d)) return; Bn(this.layoutCorrected, this.layout.layoutBox); const f = this.treeScale.x, p = this.treeScale.y; cj(this.layoutCorrected, this.treeScale, this.path, l), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox, a.targetWithTransforms = ft()); const { target: m } = a; if (!m) { this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()); return } !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (Uw(this.prevProjectionDelta.x, this.projectionDelta.x), Uw(this.prevProjectionDelta.y, this.projectionDelta.y)), Sl(this.projectionDelta, this.layoutCorrected, m, this.latestValues), (this.treeScale.x !== f || this.treeScale.y !== p || !Xw(this.projectionDelta.x, this.prevProjectionDelta.x) || !Xw(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", m)), ol && co.recalculatedProjection++ } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(s = !0) { var a; if ((a = this.options.visualElement) === null || a === void 0 || a.scheduleRender(), s) { const l = this.getStack(); l && l.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = Ls(), this.projectionDelta = Ls(), this.projectionDeltaWithTransform = Ls() } setAnimationOrigin(s, a = !1) { const l = this.snapshot, u = l ? l.latestValues : {}, c = { ...this.latestValues }, d = Ls(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a; const f = ft(), p = l ? l.source : void 0, m = this.layout ? this.layout.source : void 0, v = p !== m, x = this.getStack(), g = !x || x.members.length <= 1, h = !!(v && !g && this.options.crossfade === !0 && !this.path.some(Xj)); this.animationProgress = 0; let y; this.mixTargetDelta = E => { const P = E / 1e3; tx(d.x, s.x, P), tx(d.y, s.y, P), this.setTargetDelta(d), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (El(f, this.layout.layoutBox, this.relativeParent.layout.layoutBox), Qj(this.relativeTarget, this.relativeTargetOrigin, f, P), y && Mj(this.relativeTarget, y) && (this.isProjectionDirty = !1), y || (y = ft()), Bn(y, this.relativeTarget)), v && (this.animationValues = c, Ej(c, u, this.latestValues, P, h, g)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = P }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(s) { this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (qi(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = qe.update(() => { qc.hasAnimatedSinceResize = !0, this.currentAnimation = jj(0, Jw, { ...s, onUpdate: a => { this.mixTargetDelta(a), s.onUpdate && s.onUpdate(a) }, onComplete: () => { s.onComplete && s.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const s = this.getStack(); s && s.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Jw), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const s = this.getLead(); let { targetWithTransforms: a, target: l, layout: u, latestValues: c } = s; if (!(!a || !l || !u)) { if (this !== s && this.layout && u && DP(this.options.animationType, this.layout.layoutBox, u.layoutBox)) { l = this.target || ft(); const d = Ln(this.layout.layoutBox.x); l.x.min = s.target.x.min, l.x.max = l.x.min + d; const f = Ln(this.layout.layoutBox.y); l.y.min = s.target.y.min, l.y.max = l.y.min + f } Bn(a, l), Os(a, c), Sl(this.projectionDeltaWithTransform, this.layoutCorrected, a, c) } } registerSharedNode(s, a) { this.sharedNodes.has(s) || this.sharedNodes.set(s, new kj), this.sharedNodes.get(s).add(a); const u = a.options.initialPromotionConfig; a.promote({ transition: u ? u.transition : void 0, preserveFollowOpacity: u && u.shouldPreserveFollowOpacity ? u.shouldPreserveFollowOpacity(a) : void 0 }) } isLead() { const s = this.getStack(); return s ? s.lead === this : !0 } getLead() { var s; const { layoutId: a } = this.options; return a ? ((s = this.getStack()) === null || s === void 0 ? void 0 : s.lead) || this : this } getPrevLead() { var s; const { layoutId: a } = this.options; return a ? (s = this.getStack()) === null || s === void 0 ? void 0 : s.prevLead : void 0 } getStack() { const { layoutId: s } = this.options; if (s) return this.root.sharedNodes.get(s) } promote({ needsReset: s, transition: a, preserveFollowOpacity: l } = {}) { const u = this.getStack(); u && u.promote(this, l), s && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a }) } relegate() { const s = this.getStack(); return s ? s.relegate(this) : !1 } resetSkewAndRotation() { const { visualElement: s } = this.options; if (!s) return; let a = !1; const { latestValues: l } = s; if ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = !0), !a) return; const u = {}; l.z && Wp("z", s, u, this.animationValues); for (let c = 0; c < Hp.length; c++)Wp(`rotate${Hp[c]}`, s, u, this.animationValues), Wp(`skew${Hp[c]}`, s, u, this.animationValues); s.render(); for (const c in u) s.setStaticValue(c, u[c]), this.animationValues && (this.animationValues[c] = u[c]); s.scheduleRender() } getProjectionStyles(s) { var a, l; if (!this.instance || this.isSVG) return; if (!this.isVisible) return Ij; const u = { visibility: "" }, c = this.getTransformTemplate(); if (this.needsReset) return this.needsReset = !1, u.opacity = "", u.pointerEvents = Yc(s == null ? void 0 : s.pointerEvents) || "", u.transform = c ? c(this.latestValues, "") : "none", u; const d = this.getLead(); if (!this.projectionDelta || !this.layout || !d.target) { const v = {}; return this.options.layoutId && (v.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, v.pointerEvents = Yc(s == null ? void 0 : s.pointerEvents) || ""), this.hasProjected && !uo(this.latestValues) && (v.transform = c ? c({}, "") : "none", this.hasProjected = !1), v } const f = d.animationValues || d.latestValues; this.applyTransformsToTarget(), u.transform = _j(this.projectionDeltaWithTransform, this.treeScale, f), c && (u.transform = c(f, u.transform)); const { x: p, y: m } = this.projectionDelta; u.transformOrigin = `${p.origin * 100}% ${m.origin * 100}% 0`, d.animationValues ? u.opacity = d === this ? (l = (a = f.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : f.opacityExit : u.opacity = d === this ? f.opacity !== void 0 ? f.opacity : "" : f.opacityExit !== void 0 ? f.opacityExit : 0; for (const v in Dd) { if (f[v] === void 0) continue; const { correct: x, applyTo: g } = Dd[v], h = u.transform === "none" ? f[v] : x(f[v], d); if (g) { const y = g.length; for (let E = 0; E < y; E++)u[g[E]] = h } else u[v] = h } return this.options.layoutId && (u.pointerEvents = d === this ? Yc(s == null ? void 0 : s.pointerEvents) || "" : "none"), u } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(s => { var a; return (a = s.currentAnimation) === null || a === void 0 ? void 0 : a.stop() }), this.root.nodes.forEach(Zw), this.root.sharedNodes.clear() } } } function Fj(e) { e.updateLayout() } function zj(e) { var t; const n = ((t = e.resumeFrom) === null || t === void 0 ? void 0 : t.snapshot) || e.snapshot; if (e.isLead() && e.layout && n && e.hasListeners("didUpdate")) { const { layoutBox: r, measuredBox: i } = e.layout, { animationType: o } = e.options, s = n.source !== e.layout.source; o === "size" ? Un(d => { const f = s ? n.measuredBox[d] : n.layoutBox[d], p = Ln(f); f.min = r[d].min, f.max = f.min + p }) : DP(o, n.layoutBox, r) && Un(d => { const f = s ? n.measuredBox[d] : n.layoutBox[d], p = Ln(r[d]); f.max = f.min + p, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[d].max = e.relativeTarget[d].min + p) }); const a = Ls(); Sl(a, r, n.layoutBox); const l = Ls(); s ? Sl(l, e.applyTransform(i, !0), n.measuredBox) : Sl(l, r, n.layoutBox); const u = !NP(a); let c = !1; if (!e.resumeFrom) { const d = e.getClosestProjectingParent(); if (d && !d.resumeFrom) { const { snapshot: f, layout: p } = d; if (f && p) { const m = ft(); El(m, n.layoutBox, f.layoutBox); const v = ft(); El(v, r, p.layoutBox), OP(m, v) || (c = !0), d.options.layoutRoot && (e.relativeTarget = v, e.relativeTargetOrigin = m, e.relativeParent = d) } } } e.notifyListeners("didUpdate", { layout: r, snapshot: n, delta: l, layoutDelta: a, hasLayoutChanged: u, hasRelativeTargetChanged: c }) } else if (e.isLead()) { const { onExitComplete: r } = e.options; r && r() } e.options.transition = void 0 } function Vj(e) { ol && co.totalNodes++, e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty)) } function Bj(e) { e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1 } function Uj(e) { e.clearSnapshot() } function Zw(e) { e.clearMeasurements() } function Hj(e) { e.isLayoutDirty = !1 } function Wj(e) { const { visualElement: t } = e.options; t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform() } function ex(e) { e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0 } function Gj(e) { e.resolveTargetDelta() } function Kj(e) { e.calcProjection() } function qj(e) { e.resetSkewAndRotation() } function Yj(e) { e.removeLeadSnapshot() } function tx(e, t, n) { e.translate = et(t.translate, 0, n), e.scale = et(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint } function nx(e, t, n, r) { e.min = et(t.min, n.min, r), e.max = et(t.max, n.max, r) } function Qj(e, t, n, r) { nx(e.x, t.x, n.x, r), nx(e.y, t.y, n.y, r) } function Xj(e) { return e.animationValues && e.animationValues.opacityExit !== void 0 } const Jj = { duration: .45, ease: [.4, 0, .1, 1] }, rx = e => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), ix = rx("applewebkit/") && !rx("chrome/") ? Math.round : Mn; function ox(e) { e.min = ix(e.min), e.max = ix(e.max) } function Zj(e) { ox(e.x), ox(e.y) } function DP(e, t, n) { return e === "position" || e === "preserve-aspect" && !ej(Qw(t), Qw(n), .2) } function eI(e) { var t; return e !== e.root && ((t = e.scroll) === null || t === void 0 ? void 0 : t.wasRoot) } const tI = IP({ attachResizeListener: (e, t) => Zl(e, "resize", t), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), Gp = { current: void 0 }, FP = IP({ measureScroll: e => ({ x: e.scrollLeft, y: e.scrollTop }), defaultParent: () => { if (!Gp.current) { const e = new tI({}); e.mount(window), e.setOptions({ layoutScroll: !0 }), Gp.current = e } return Gp.current }, resetTransform: (e, t) => { e.style.transform = t !== void 0 ? t : "none" }, checkIsScrollRoot: e => window.getComputedStyle(e).position === "fixed" }), nI = { pan: { Feature: gj }, drag: { Feature: mj, ProjectionNode: FP, MeasureLayout: _P } }; function sx(e, t, n) { const { props: r } = e; e.animationState && r.whileHover && e.animationState.setActive("whileHover", n === "Start"); const i = "onHover" + n, o = r[i]; o && qe.postRender(() => o(t, _u(t))) } class rI extends to { mount() { const { current: t } = this.node; t && (this.unmount = z3(t, n => (sx(this.node, n, "Start"), r => sx(this.node, r, "End")))) } unmount() { } } class iI extends to { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let t = !1; try { t = this.node.current.matches(":focus-visible") } catch { t = !0 } !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = ku(Zl(this.node.current, "focus", () => this.onFocus()), Zl(this.node.current, "blur", () => this.onBlur())) } unmount() { } } function ax(e, t, n) { const { props: r } = e; e.animationState && r.whileTap && e.animationState.setActive("whileTap", n === "Start"); const i = "onTap" + (n === "End" ? "" : n), o = r[i]; o && qe.postRender(() => o(t, _u(t))) } class oI extends to { mount() { const { current: t } = this.node; t && (this.unmount = H3(t, n => (ax(this.node, n, "Start"), (r, { success: i }) => ax(this.node, r, i ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget })) } unmount() { } } const tg = new WeakMap, Kp = new WeakMap, sI = e => { const t = tg.get(e.target); t && t(e) }, aI = e => { e.forEach(sI) }; function lI({ root: e, ...t }) { const n = e || document; Kp.has(n) || Kp.set(n, {}); const r = Kp.get(n), i = JSON.stringify(t); return r[i] || (r[i] = new IntersectionObserver(aI, { root: e, ...t })), r[i] } function uI(e, t, n) { const r = lI(t); return tg.set(e, n), r.observe(e), () => { tg.delete(e), r.unobserve(e) } } const cI = { some: 0, all: 1 }; class dI extends to { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: t = {} } = this.node.getProps(), { root: n, margin: r, amount: i = "some", once: o } = t, s = { root: n ? n.current : void 0, rootMargin: r, threshold: typeof i == "number" ? i : cI[i] }, a = l => { const { isIntersecting: u } = l; if (this.isInView === u || (this.isInView = u, o && !u && this.hasEnteredView)) return; u && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", u); const { onViewportEnter: c, onViewportLeave: d } = this.node.getProps(), f = u ? c : d; f && f(l) }; return uI(this.node.current, s, a) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; const { props: t, prevProps: n } = this.node;["amount", "margin", "root"].some(fI(t, n)) && this.startObserver() } unmount() { } } function fI({ viewport: e = {} }, { viewport: t = {} } = {}) { return n => e[n] !== t[n] } const pI = { inView: { Feature: dI }, tap: { Feature: oI }, focus: { Feature: iI }, hover: { Feature: rI } }, hI = { layout: { ProjectionNode: FP, MeasureLayout: _P } }, eu = S.createContext({ transformPagePoint: e => e, isStatic: !1, reducedMotion: "never" }), If = S.createContext({}), Cy = typeof window < "u", zP = Cy ? S.useLayoutEffect : S.useEffect, Py = S.createContext({ strict: !1 }); function mI(e, t, n, r, i) { var o, s; const { visualElement: a } = S.useContext(If), l = S.useContext(Py), u = S.useContext(jf), c = S.useContext(eu).reducedMotion, d = S.useRef(null); r = r || l.renderer, !d.current && r && (d.current = r(e, { visualState: t, parent: a, props: n, presenceContext: u, blockInitialAnimation: u ? u.initial === !1 : !1, reducedMotionConfig: c })); const f = d.current, p = S.useContext(kP); f && !f.projection && i && (f.type === "html" || f.type === "svg") && gI(d.current, n, i, p); const m = S.useRef(!1); S.useInsertionEffect(() => { f && m.current && f.update(n, u) }); const v = n[hP], x = S.useRef(!!v && !(!((o = window.MotionHandoffIsComplete) === null || o === void 0) && o.call(window, v)) && ((s = window.MotionHasOptimisedAnimation) === null || s === void 0 ? void 0 : s.call(window, v))); return zP(() => { f && (m.current = !0, window.MotionIsMounted = !0, f.updateFeatures(), Ty.render(f.render), x.current && f.animationState && f.animationState.animateChanges()) }), S.useEffect(() => { f && (!x.current && f.animationState && f.animationState.animateChanges(), x.current && (queueMicrotask(() => { var g; (g = window.MotionHandoffMarkAsComplete) === null || g === void 0 || g.call(window, v) }), x.current = !1)) }), f } function gI(e, t, n, r) { const { layoutId: i, layout: o, drag: s, dragConstraints: a, layoutScroll: l, layoutRoot: u } = t; e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : VP(e.parent)), e.projection.setOptions({ layoutId: i, layout: o, alwaysMeasureLayout: !!s || a && Rs(a), visualElement: e, animationType: typeof o == "string" ? o : "both", initialPromotionConfig: r, layoutScroll: l, layoutRoot: u }) } function VP(e) { if (e) return e.options.allowProjection !== !1 ? e.projection : VP(e.parent) } function vI(e, t, n) { return S.useCallback(r => { r && e.mount && e.mount(r), t && (r ? t.mount(r) : t.unmount()), n && (typeof n == "function" ? n(r) : Rs(n) && (n.current = r)) }, [t]) } function Df(e) { return Lf(e.animate) || ty.some(t => Yl(e[t])) } function BP(e) { return !!(Df(e) || e.variants) } function yI(e, t) { if (Df(e)) { const { initial: n, animate: r } = e; return { initial: n === !1 || Yl(n) ? n : void 0, animate: Yl(r) ? r : void 0 } } return e.inherit !== !1 ? t : {} } function bI(e) { const { initial: t, animate: n } = yI(e, S.useContext(If)); return S.useMemo(() => ({ initial: t, animate: n }), [lx(t), lx(n)]) } function lx(e) { return Array.isArray(e) ? e.join(" ") : e } const ux = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, aa = {}; for (const e in ux) aa[e] = { isEnabled: t => ux[e].some(n => !!t[n]) }; function ng(e) { for (const t in e) aa[t] = { ...aa[t], ...e[t] } } const wI = Symbol.for("motionComponentSymbol"); function xI({ preloadedFeatures: e, createVisualElement: t, useRender: n, useVisualState: r, Component: i }) { e && ng(e); function o(a, l) { let u; const c = { ...S.useContext(eu), ...a, layoutId: SI(a) }, { isStatic: d } = c, f = bI(a), p = r(a, d); if (!d && Cy) { EI(); const m = TI(c); u = m.MeasureLayout, f.visualElement = mI(i, p, c, t, m.ProjectionNode) } return w.jsxs(If.Provider, { value: f, children: [u && f.visualElement ? w.jsx(u, { visualElement: f.visualElement, ...c }) : null, n(i, a, vI(p, f.visualElement, l), p, d, f.visualElement)] }) } const s = S.forwardRef(o); return s[wI] = i, s } function SI({ layoutId: e }) { const t = S.useContext(Ey).id; return t && e !== void 0 ? t + "-" + e : e } function EI(e, t) { S.useContext(Py).strict } function TI(e) { const { drag: t, layout: n } = aa; if (!t && !n) return {}; const r = { ...t, ...n }; return { MeasureLayout: t != null && t.isEnabled(e) || n != null && n.isEnabled(e) ? r.MeasureLayout : void 0, ProjectionNode: r.ProjectionNode } } const CI = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function $y(e) { return typeof e != "string" || e.includes("-") ? !1 : !!(CI.indexOf(e) > -1 || /[A-Z]/u.test(e)) } function UP(e, { style: t, vars: n }, r, i) { Object.assign(e.style, t, i && i.getProjectionStyles(r)); for (const o in n) e.style.setProperty(o, n[o]) } const HP = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function WP(e, t, n, r) { UP(e, t, void 0, r); for (const i in t.attrs) e.setAttribute(HP.has(i) ? i : xy(i), t.attrs[i]) } function GP(e, { layout: t, layoutId: n }) { return Xo.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!Dd[e] || e === "opacity") } function Ay(e, t, n) { var r; const { style: i } = e, o = {}; for (const s in i) (Qt(i[s]) || t.style && Qt(t.style[s]) || GP(s, e) || ((r = n == null ? void 0 : n.getValue(s)) === null || r === void 0 ? void 0 : r.liveStyle) !== void 0) && (o[s] = i[s]); return o } function KP(e, t, n) { const r = Ay(e, t, n); for (const i in e) if (Qt(e[i]) || Qt(t[i])) { const o = $u.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i; r[o] = e[i] } return r } function Ff(e) { const t = S.useRef(null); return t.current === null && (t.current = e()), t.current } function PI({ scrapeMotionValuesFromProps: e, createRenderState: t, onMount: n }, r, i, o) { const s = { latestValues: $I(r, i, o, e), renderState: t() }; return n && (s.mount = a => n(r, a, s)), s } const qP = e => (t, n) => { const r = S.useContext(If), i = S.useContext(jf), o = () => PI(e, t, r, i); return n ? o() : Ff(o) }; function $I(e, t, n, r) { const i = {}, o = r(e, {}); for (const f in o) i[f] = Yc(o[f]); let { initial: s, animate: a } = e; const l = Df(e), u = BP(e); t && u && !l && e.inherit !== !1 && (s === void 0 && (s = t.initial), a === void 0 && (a = t.animate)); let c = n ? n.initial === !1 : !1; c = c || s === !1; const d = c ? a : s; if (d && typeof d != "boolean" && !Lf(d)) { const f = Array.isArray(d) ? d : [d]; for (let p = 0; p < f.length; p++) { const m = Zv(e, f[p]); if (m) { const { transitionEnd: v, transition: x, ...g } = m; for (const h in g) { let y = g[h]; if (Array.isArray(y)) { const E = c ? y.length - 1 : 0; y = y[E] } y !== null && (i[h] = y) } for (const h in v) i[h] = v[h] } } } return i } const My = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }), YP = () => ({ ...My(), attrs: {} }), QP = (e, t) => t && typeof e == "number" ? t.transform(e) : e, AI = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, MI = $u.length; function kI(e, t, n) { let r = "", i = !0; for (let o = 0; o < MI; o++) { const s = $u[o], a = e[s]; if (a === void 0) continue; let l = !0; if (typeof a == "number" ? l = a === (s.startsWith("scale") ? 1 : 0) : l = parseFloat(a) === 0, !l || n) { const u = QP(a, cy[s]); if (!l) { i = !1; const c = AI[s] || s; r += `${c}(${u}) ` } n && (t[s] = u) } } return r = r.trim(), n ? r = n(t, i ? "" : r) : i && (r = "none"), r } function ky(e, t, n) { const { style: r, vars: i, transformOrigin: o } = e; let s = !1, a = !1; for (const l in t) { const u = t[l]; if (Xo.has(l)) { s = !0; continue } else if (UC(l)) { i[l] = u; continue } else { const c = QP(u, cy[l]); l.startsWith("origin") ? (a = !0, o[l] = c) : r[l] = c } } if (t.transform || (s || n ? r.transform = kI(t, e.transform, n) : r.transform && (r.transform = "none")), a) { const { originX: l = "50%", originY: u = "50%", originZ: c = 0 } = o; r.transformOrigin = `${l} ${u} ${c}` } } function cx(e, t, n) { return typeof e == "string" ? e : ve.transform(t + n * e) } function _I(e, t, n) { const r = cx(t, e.x, e.width), i = cx(n, e.y, e.height); return `${r} ${i}` } const RI = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, LI = { offset: "strokeDashoffset", array: "strokeDasharray" }; function NI(e, t, n = 1, r = 0, i = !0) { e.pathLength = 1; const o = i ? RI : LI; e[o.offset] = ve.transform(-r); const s = ve.transform(t), a = ve.transform(n); e[o.array] = `${s} ${a}` } function _y(e, { attrX: t, attrY: n, attrScale: r, originX: i, originY: o, pathLength: s, pathSpacing: a = 1, pathOffset: l = 0, ...u }, c, d) { if (ky(e, u, d), c) { e.style.viewBox && (e.attrs.viewBox = e.style.viewBox); return } e.attrs = e.style, e.style = {}; const { attrs: f, style: p, dimensions: m } = e; f.transform && (m && (p.transform = f.transform), delete f.transform), m && (i !== void 0 || o !== void 0 || p.transform) && (p.transformOrigin = _I(m, i !== void 0 ? i : .5, o !== void 0 ? o : .5)), t !== void 0 && (f.x = t), n !== void 0 && (f.y = n), r !== void 0 && (f.scale = r), s !== void 0 && NI(f, s, a, l, !1) } const Ry = e => typeof e == "string" && e.toLowerCase() === "svg", OI = { useVisualState: qP({ scrapeMotionValuesFromProps: KP, createRenderState: YP, onMount: (e, t, { renderState: n, latestValues: r }) => { qe.read(() => { try { n.dimensions = typeof t.getBBox == "function" ? t.getBBox() : t.getBoundingClientRect() } catch { n.dimensions = { x: 0, y: 0, width: 0, height: 0 } } }), qe.render(() => { _y(n, r, Ry(t.tagName), e.transformTemplate), WP(t, n) }) } }) }, jI = { useVisualState: qP({ scrapeMotionValuesFromProps: Ay, createRenderState: My }) }; function XP(e, t, n) { for (const r in t) !Qt(t[r]) && !GP(r, n) && (e[r] = t[r]) } function II({ transformTemplate: e }, t) { return S.useMemo(() => { const n = My(); return ky(n, t, e), Object.assign({}, n.vars, n.style) }, [t]) } function DI(e, t) { const n = e.style || {}, r = {}; return XP(r, n, e), Object.assign(r, II(e, t)), r } function FI(e, t) { const n = {}, r = DI(e, t); return e.drag && e.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0), n.style = r, n } const zI = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function Fd(e) { return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || zI.has(e) } let JP = e => !Fd(e); function ZP(e) { e && (JP = t => t.startsWith("on") ? !Fd(t) : e(t)) } try { ZP(require("@emotion/is-prop-valid").default) } catch { } function VI(e, t, n) { const r = {}; for (const i in e) i === "values" && typeof e.values == "object" || (JP(i) || n === !0 && Fd(i) || !t && !Fd(i) || e.draggable && i.startsWith("onDrag")) && (r[i] = e[i]); return r } function BI(e, t, n, r) { const i = S.useMemo(() => { const o = YP(); return _y(o, t, Ry(r), e.transformTemplate), { ...o.attrs, style: { ...o.style } } }, [t]); if (e.style) { const o = {}; XP(o, e.style, e), i.style = { ...o, ...i.style } } return i } function UI(e = !1) { return (n, r, i, { latestValues: o }, s) => { const l = ($y(n) ? BI : FI)(r, o, s, n), u = VI(r, typeof n == "string", e), c = n !== S.Fragment ? { ...u, ...l, ref: i } : {}, { children: d } = r, f = S.useMemo(() => Qt(d) ? d.get() : d, [d]); return S.createElement(n, { ...c, children: f }) } } function e$(e, t) { return function (r, { forwardMotionProps: i } = { forwardMotionProps: !1 }) { const s = { ...$y(r) ? OI : jI, preloadedFeatures: e, useRender: UI(i), createVisualElement: t, Component: r }; return xI(s) } } const rg = { current: null }, t$ = { current: !1 }; function HI() { if (t$.current = !0, !!Cy) if (window.matchMedia) { const e = window.matchMedia("(prefers-reduced-motion)"), t = () => rg.current = e.matches; e.addListener(t), t() } else rg.current = !1 } function WI(e, t, n) { for (const r in t) { const i = t[r], o = n[r]; if (Qt(i)) e.addValue(r, i); else if (Qt(o)) e.addValue(r, Jl(i, { owner: e })); else if (o !== i) if (e.hasValue(r)) { const s = e.getValue(r); s.liveStyle === !0 ? s.jump(i) : s.hasAnimated || s.set(i) } else { const s = e.getStaticValue(r); e.addValue(r, Jl(s !== void 0 ? s : i, { owner: e })) } } for (const r in n) t[r] === void 0 && e.removeValue(r); return t } const dx = new WeakMap, GI = [...GC, qt, Yi], KI = e => GI.find(WC(e)), fx = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]; class qI { scrapeMotionValuesFromProps(t, n, r) { return {} } constructor({ parent: t, props: n, presenceContext: r, reducedMotionConfig: i, blockInitialAnimation: o, visualState: s }, a = {}) { this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = ay, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.renderScheduledAt = 0, this.scheduleRender = () => { const f = _r.now(); this.renderScheduledAt < f && (this.renderScheduledAt = f, qe.render(this.render, !1, !0)) }; const { latestValues: l, renderState: u } = s; this.latestValues = l, this.baseTarget = { ...l }, this.initialValues = n.initial ? { ...l } : {}, this.renderState = u, this.parent = t, this.props = n, this.presenceContext = r, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = i, this.options = a, this.blockInitialAnimation = !!o, this.isControllingVariants = Df(n), this.isVariantNode = BP(n), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(t && t.current); const { willChange: c, ...d } = this.scrapeMotionValuesFromProps(n, {}, this); for (const f in d) { const p = d[f]; l[f] !== void 0 && Qt(p) && p.set(l[f], !1) } } mount(t) { this.current = t, dx.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, r) => this.bindToMotionValue(r, n)), t$.current || HI(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : rg.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext) } unmount() { dx.delete(this.current), this.projection && this.projection.unmount(), qi(this.notifyUpdate), qi(this.render), this.valueSubscriptions.forEach(t => t()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this); for (const t in this.events) this.events[t].clear(); for (const t in this.features) { const n = this.features[t]; n && (n.unmount(), n.isMounted = !1) } this.current = null } bindToMotionValue(t, n) { this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)(); const r = Xo.has(t), i = n.on("change", a => { this.latestValues[t] = a, this.props.onUpdate && qe.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0) }), o = n.on("renderRequest", this.scheduleRender); let s; window.MotionCheckAppearSync && (s = window.MotionCheckAppearSync(this, t, n)), this.valueSubscriptions.set(t, () => { i(), o(), s && s(), n.owner && n.stop() }) } sortNodePosition(t) { return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current) } updateFeatures() { let t = "animation"; for (t in aa) { const n = aa[t]; if (!n) continue; const { isEnabled: r, Feature: i } = n; if (!this.features[t] && i && r(this.props) && (this.features[t] = new i(this)), this.features[t]) { const o = this.features[t]; o.isMounted ? o.update() : (o.mount(), o.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : ft() } getStaticValue(t) { return this.latestValues[t] } setStaticValue(t, n) { this.latestValues[t] = n } update(t, n) { (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n; for (let r = 0; r < fx.length; r++) { const i = fx[r]; this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]); const o = "on" + i, s = t[o]; s && (this.propEventSubscriptions[i] = this.on(i, s)) } this.prevMotionValues = WI(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(t) { return this.props.variants ? this.props.variants[t] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } addVariantChild(t) { const n = this.getClosestVariantNode(); if (n) return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t) } addValue(t, n) { const r = this.values.get(t); n !== r && (r && this.removeValue(t), this.bindToMotionValue(t, n), this.values.set(t, n), this.latestValues[t] = n.get()) } removeValue(t) { this.values.delete(t); const n = this.valueSubscriptions.get(t); n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState) } hasValue(t) { return this.values.has(t) } getValue(t, n) { if (this.props.values && this.props.values[t]) return this.props.values[t]; let r = this.values.get(t); return r === void 0 && n !== void 0 && (r = Jl(n === null ? void 0 : n, { owner: this }), this.addValue(t, r)), r } readValue(t, n) { var r; let i = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : (r = this.getBaseTargetFromProps(this.props, t)) !== null && r !== void 0 ? r : this.readValueFromInstance(this.current, t, this.options); return i != null && (typeof i == "string" && (VC(i) || zC(i)) ? i = parseFloat(i) : !KI(i) && Yi.test(n) && (i = eP(t, n)), this.setBaseTarget(t, Qt(i) ? i.get() : i)), Qt(i) ? i.get() : i } setBaseTarget(t, n) { this.baseTarget[t] = n } getBaseTarget(t) { var n; const { initial: r } = this.props; let i; if (typeof r == "string" || typeof r == "object") { const s = Zv(this.props, r, (n = this.presenceContext) === null || n === void 0 ? void 0 : n.custom); s && (i = s[t]) } if (r && i !== void 0) return i; const o = this.getBaseTargetFromProps(this.props, t); return o !== void 0 && !Qt(o) ? o : this.initialValues[t] !== void 0 && i === void 0 ? void 0 : this.baseTarget[t] } on(t, n) { return this.events[t] || (this.events[t] = new wy), this.events[t].add(n) } notify(t, ...n) { this.events[t] && this.events[t].notify(...n) } } class n$ extends qI { constructor() { super(...arguments), this.KeyframeResolver = tP } sortInstanceNodePosition(t, n) { return t.compareDocumentPosition(n) & 2 ? 1 : -1 } getBaseTargetFromProps(t, n) { return t.style ? t.style[n] : void 0 } removeValueFromRenderState(t, { vars: n, style: r }) { delete n[t], delete r[t] } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: t } = this.props; Qt(t) && (this.childSubscription = t.on("change", n => { this.current && (this.current.textContent = `${n}`) })) } } function YI(e) { return window.getComputedStyle(e) } class QI extends n$ { constructor() { super(...arguments), this.type = "html", this.renderInstance = UP } readValueFromInstance(t, n) { if (Xo.has(n)) { const r = dy(n); return r && r.default || 0 } else { const r = YI(t), i = (UC(n) ? r.getPropertyValue(n) : r[n]) || 0; return typeof i == "string" ? i.trim() : i } } measureInstanceViewportBox(t, { transformPagePoint: n }) { return AP(t, n) } build(t, n, r) { ky(t, n, r.transformTemplate) } scrapeMotionValuesFromProps(t, n, r) { return Ay(t, n, r) } } class XI extends n$ { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = ft } getBaseTargetFromProps(t, n) { return t[n] } readValueFromInstance(t, n) { if (Xo.has(n)) { const r = dy(n); return r && r.default || 0 } return n = HP.has(n) ? n : xy(n), t.getAttribute(n) } scrapeMotionValuesFromProps(t, n, r) { return KP(t, n, r) } build(t, n, r) { _y(t, n, this.isSVGTag, r.transformTemplate) } renderInstance(t, n, r, i) { WP(t, n, r, i) } mount(t) { this.isSVGTag = Ry(t.tagName), super.mount(t) } } const JI = (e, t) => $y(e) ? new XI(t) : new QI(t, { allowProjection: e !== S.Fragment }), ZI = e$({ ...D3, ...pI, ...nI, ...hI }, JI), oi = MC(ZI), e4 = e$(), Ly = MC(e4); class t4 extends S.Component { getSnapshotBeforeUpdate(t) { const n = this.props.childRef.current; if (n && t.isPresent && !this.props.isPresent) { const r = this.props.sizeRef.current; r.height = n.offsetHeight || 0, r.width = n.offsetWidth || 0, r.top = n.offsetTop, r.left = n.offsetLeft } return null } componentDidUpdate() { } render() { return this.props.children } } function n4({ children: e, isPresent: t }) {
  const n = S.useId(), r = S.useRef(null), i = S.useRef({ width: 0, height: 0, top: 0, left: 0 }), { nonce: o } = S.useContext(eu); return S.useInsertionEffect(() => {
    const { width: s, height: a, top: l, left: u } = i.current; if (t || !r.current || !s || !a) return; r.current.dataset.motionPopId = n; const c = document.createElement("style"); return o && (c.nonce = o), document.head.appendChild(c), c.sheet && c.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${s}px !important;
            height: ${a}px !important;
            top: ${l}px !important;
            left: ${u}px !important;
          }
        `), () => { document.head.removeChild(c) }
  }, [t]), w.jsx(t4, { isPresent: t, childRef: r, sizeRef: i, children: S.cloneElement(e, { ref: r }) })
} const r4 = ({ children: e, initial: t, isPresent: n, onExitComplete: r, custom: i, presenceAffectsLayout: o, mode: s }) => { const a = Ff(i4), l = S.useId(), u = S.useCallback(d => { a.set(d, !0); for (const f of a.values()) if (!f) return; r && r() }, [a, r]), c = S.useMemo(() => ({ id: l, initial: t, isPresent: n, custom: i, onExitComplete: u, register: d => (a.set(d, !1), () => a.delete(d)) }), o ? [Math.random(), u] : [n, u]); return S.useMemo(() => { a.forEach((d, f) => a.set(f, !1)) }, [n]), S.useEffect(() => { !n && !a.size && r && r() }, [n]), s === "popLayout" && (e = w.jsx(n4, { isPresent: n, children: e })), w.jsx(jf.Provider, { value: c, children: e }) }; function i4() { return new Map } const gc = e => e.key || ""; function px(e) { const t = []; return S.Children.forEach(e, n => { S.isValidElement(n) && t.push(n) }), t } const r$ = ({ children: e, exitBeforeEnter: t, custom: n, initial: r = !0, onExitComplete: i, presenceAffectsLayout: o = !0, mode: s = "sync" }) => { const a = S.useMemo(() => px(e), [e]), l = a.map(gc), u = S.useRef(!0), c = S.useRef(a), d = Ff(() => new Map), [f, p] = S.useState(a), [m, v] = S.useState(a); zP(() => { u.current = !1, c.current = a; for (let h = 0; h < m.length; h++) { const y = gc(m[h]); l.includes(y) ? d.delete(y) : d.get(y) !== !0 && d.set(y, !1) } }, [m, l.length, l.join("-")]); const x = []; if (a !== f) { let h = [...a]; for (let y = 0; y < m.length; y++) { const E = m[y], P = gc(E); l.includes(P) || (h.splice(y, 0, E), x.push(E)) } s === "wait" && x.length && (h = x), v(px(h)), p(a); return } const { forceRender: g } = S.useContext(Ey); return w.jsx(w.Fragment, { children: m.map(h => { const y = gc(h), E = a === m || l.includes(y), P = () => { if (d.has(y)) d.set(y, !0); else return; let $ = !0; d.forEach(L => { L || ($ = !1) }), $ && (g == null || g(), v(c.current), i && i()) }; return w.jsx(r4, { isPresent: E, initial: !u.current || r ? void 0 : !1, custom: E ? void 0 : n, presenceAffectsLayout: o, mode: s, onExitComplete: E ? void 0 : P, children: h }, y) }) }) }; function o4({ children: e, isValidProp: t, ...n }) { t && ZP(t), n = { ...S.useContext(eu), ...n }, n.isStatic = Ff(() => n.isStatic); const r = S.useMemo(() => n, [JSON.stringify(n.transition), n.transformPagePoint, n.reducedMotion]); return w.jsx(eu.Provider, { value: r, children: e }) } function Ny({ children: e, features: t, strict: n = !1 }) { const [, r] = S.useState(!qp(t)), i = S.useRef(void 0); if (!qp(t)) { const { renderer: o, ...s } = t; i.current = o, ng(s) } return S.useEffect(() => { qp(t) && t().then(({ renderer: o, ...s }) => { ng(s), i.current = o, r(!0) }) }, []), w.jsx(Py.Provider, { value: { renderer: i.current, strict: n }, children: e }) } function qp(e) { return typeof e == "function" } var s4 = ({ children: e, navigate: t, disableAnimation: n, useHref: r, disableRipple: i = !1, skipFramerMotionAnimations: o = n, reducedMotion: s = "never", validationBehavior: a, locale: l = "en-US", defaultDates: u, createCalendar: c, ...d }) => { let f = e; t && (f = w.jsx(xL, { navigate: t, useHref: r, children: f })); const p = S.useMemo(() => (n && o && (ry.skipAnimations = !0), { createCalendar: c, defaultDates: u, disableAnimation: n, disableRipple: i, validationBehavior: a }), [c, u == null ? void 0 : u.maxDate, u == null ? void 0 : u.minDate, n, i, a]); return w.jsx(FR, { value: p, children: w.jsx(JR, { locale: l, children: w.jsx(o4, { reducedMotion: s, children: w.jsx(LN, { ...d, children: f }) }) }) }) }; function _t(e) { return S.forwardRef(e) } var ha = (e, t, n = !0) => { if (!t) return [e, {}]; const r = t.reduce((i, o) => o in e ? { ...i, [o]: e[o] } : i, {}); return n ? [Object.keys(e).filter(o => !t.includes(o)).reduce((o, s) => ({ ...o, [s]: e[s] }), {}), r] : [e, r] }, vc = ["small", "medium", "large"], ig = { theme: { opacity: ["disabled"], spacing: ["divider"], borderWidth: vc, borderRadius: vc }, classGroups: { shadow: [{ shadow: vc }], "font-size": [{ text: ["tiny", ...vc] }], "bg-image": ["bg-stripe-gradient-default", "bg-stripe-gradient-primary", "bg-stripe-gradient-secondary", "bg-stripe-gradient-success", "bg-stripe-gradient-warning", "bg-stripe-gradient-danger"] } }, hx = e => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, Sn = e => !e || typeof e != "object" || Object.keys(e).length === 0, a4 = (e, t) => JSON.stringify(e) === JSON.stringify(t); function i$(e, t) { e.forEach(function (n) { Array.isArray(n) ? i$(n, t) : t.push(n) }) } function o$(e) { let t = []; return i$(e, t), t } var s$ = (...e) => o$(e).filter(Boolean), a$ = (e, t) => { let n = {}, r = Object.keys(e), i = Object.keys(t); for (let o of r) if (i.includes(o)) { let s = e[o], a = t[o]; typeof s == "object" && typeof a == "object" ? n[o] = a$(s, a) : Array.isArray(s) || Array.isArray(a) ? n[o] = s$(a, s) : n[o] = a + " " + s } else n[o] = e[o]; for (let o of i) r.includes(o) || (n[o] = t[o]); return n }, mx = e => !e || typeof e != "string" ? e : e.replace(/\s+/g, " ").trim(); function l4() { for (var e = 0, t, n, r = ""; e < arguments.length;)(t = arguments[e++]) && (n = l$(t)) && (r && (r += " "), r += n); return r } function l$(e) { if (typeof e == "string") return e; for (var t, n = "", r = 0; r < e.length; r++)e[r] && (t = l$(e[r])) && (n && (n += " "), n += t); return n } var Oy = "-"; function u4(e) { var t = d4(e), n = e.conflictingClassGroups, r = e.conflictingClassGroupModifiers, i = r === void 0 ? {} : r; function o(a) { var l = a.split(Oy); return l[0] === "" && l.length !== 1 && l.shift(), u$(l, t) || c4(a) } function s(a, l) { var u = n[a] || []; return l && i[a] ? [].concat(u, i[a]) : u } return { getClassGroupId: o, getConflictingClassGroupIds: s } } function u$(e, t) { var s; if (e.length === 0) return t.classGroupId; var n = e[0], r = t.nextPart.get(n), i = r ? u$(e.slice(1), r) : void 0; if (i) return i; if (t.validators.length !== 0) { var o = e.join(Oy); return (s = t.validators.find(function (a) { var l = a.validator; return l(o) })) == null ? void 0 : s.classGroupId } } var gx = /^\[(.+)\]$/; function c4(e) { if (gx.test(e)) { var t = gx.exec(e)[1], n = t == null ? void 0 : t.substring(0, t.indexOf(":")); if (n) return "arbitrary.." + n } } function d4(e) { var t = e.theme, n = e.prefix, r = { nextPart: new Map, validators: [] }, i = p4(Object.entries(e.classGroups), n); return i.forEach(function (o) { var s = o[0], a = o[1]; og(a, r, s, t) }), r } function og(e, t, n, r) { e.forEach(function (i) { if (typeof i == "string") { var o = i === "" ? t : vx(t, i); o.classGroupId = n; return } if (typeof i == "function") { if (f4(i)) { og(i(r), t, n, r); return } t.validators.push({ validator: i, classGroupId: n }); return } Object.entries(i).forEach(function (s) { var a = s[0], l = s[1]; og(l, vx(t, a), n, r) }) }) } function vx(e, t) { var n = e; return t.split(Oy).forEach(function (r) { n.nextPart.has(r) || n.nextPart.set(r, { nextPart: new Map, validators: [] }), n = n.nextPart.get(r) }), n } function f4(e) { return e.isThemeGetter } function p4(e, t) { return t ? e.map(function (n) { var r = n[0], i = n[1], o = i.map(function (s) { return typeof s == "string" ? t + s : typeof s == "object" ? Object.fromEntries(Object.entries(s).map(function (a) { var l = a[0], u = a[1]; return [t + l, u] })) : s }); return [r, o] }) : e } function h4(e) { if (e < 1) return { get: function () { }, set: function () { } }; var t = 0, n = new Map, r = new Map; function i(o, s) { n.set(o, s), t++, t > e && (t = 0, r = n, n = new Map) } return { get: function (s) { var a = n.get(s); if (a !== void 0) return a; if ((a = r.get(s)) !== void 0) return i(s, a), a }, set: function (s, a) { n.has(s) ? n.set(s, a) : i(s, a) } } } var c$ = "!"; function m4(e) { var t = e.separator || ":", n = t.length === 1, r = t[0], i = t.length; return function (s) { for (var a = [], l = 0, u = 0, c, d = 0; d < s.length; d++) { var f = s[d]; if (l === 0) { if (f === r && (n || s.slice(d, d + i) === t)) { a.push(s.slice(u, d)), u = d + i; continue } if (f === "/") { c = d; continue } } f === "[" ? l++ : f === "]" && l-- } var p = a.length === 0 ? s : s.substring(u), m = p.startsWith(c$), v = m ? p.substring(1) : p, x = c && c > u ? c - u : void 0; return { modifiers: a, hasImportantModifier: m, baseClassName: v, maybePostfixModifierPosition: x } } } function g4(e) { if (e.length <= 1) return e; var t = [], n = []; return e.forEach(function (r) { var i = r[0] === "["; i ? (t.push.apply(t, n.sort().concat([r])), n = []) : n.push(r) }), t.push.apply(t, n.sort()), t } function v4(e) { return { cache: h4(e.cacheSize), splitModifiers: m4(e), ...u4(e) } } var y4 = /\s+/; function b4(e, t) { var n = t.splitModifiers, r = t.getClassGroupId, i = t.getConflictingClassGroupIds, o = new Set; return e.trim().split(y4).map(function (s) { var a = n(s), l = a.modifiers, u = a.hasImportantModifier, c = a.baseClassName, d = a.maybePostfixModifierPosition, f = r(d ? c.substring(0, d) : c), p = !!d; if (!f) { if (!d) return { isTailwindClass: !1, originalClassName: s }; if (f = r(c), !f) return { isTailwindClass: !1, originalClassName: s }; p = !1 } var m = g4(l).join(":"), v = u ? m + c$ : m; return { isTailwindClass: !0, modifierId: v, classGroupId: f, originalClassName: s, hasPostfixModifier: p } }).reverse().filter(function (s) { if (!s.isTailwindClass) return !0; var a = s.modifierId, l = s.classGroupId, u = s.hasPostfixModifier, c = a + l; return o.has(c) ? !1 : (o.add(c), i(l, u).forEach(function (d) { return o.add(a + d) }), !0) }).reverse().map(function (s) { return s.originalClassName }).join(" ") } function sg() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; var r, i, o, s = a; function a(u) { var c = t[0], d = t.slice(1), f = d.reduce(function (p, m) { return m(p) }, c()); return r = v4(f), i = r.cache.get, o = r.cache.set, s = l, l(u) } function l(u) { var c = i(u); if (c) return c; var d = b4(u, r); return o(u, d), d } return function () { return s(l4.apply(null, arguments)) } } function Ue(e) { var t = function (r) { return r[e] || [] }; return t.isThemeGetter = !0, t } var d$ = /^\[(?:([a-z-]+):)?(.+)\]$/i, w4 = /^\d+\/\d+$/, x4 = new Set(["px", "full", "screen"]), S4 = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, E4 = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, T4 = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/; function or(e) { return xo(e) || x4.has(e) || w4.test(e) || ag(e) } function ag(e) { return Jo(e, "length", k4) } function C4(e) { return Jo(e, "size", f$) } function P4(e) { return Jo(e, "position", f$) } function $4(e) { return Jo(e, "url", _4) } function yc(e) { return Jo(e, "number", xo) } function xo(e) { return !Number.isNaN(Number(e)) } function A4(e) { return e.endsWith("%") && xo(e.slice(0, -1)) } function Oa(e) { return yx(e) || Jo(e, "number", yx) } function Me(e) { return d$.test(e) } function ja() { return !0 } function pi(e) { return S4.test(e) } function M4(e) { return Jo(e, "", R4) } function Jo(e, t, n) { var r = d$.exec(e); return r ? r[1] ? r[1] === t : n(r[2]) : !1 } function k4(e) { return E4.test(e) } function f$() { return !1 } function _4(e) { return e.startsWith("url(") } function yx(e) { return Number.isInteger(Number(e)) } function R4(e) { return T4.test(e) } function lg() { var e = Ue("colors"), t = Ue("spacing"), n = Ue("blur"), r = Ue("brightness"), i = Ue("borderColor"), o = Ue("borderRadius"), s = Ue("borderSpacing"), a = Ue("borderWidth"), l = Ue("contrast"), u = Ue("grayscale"), c = Ue("hueRotate"), d = Ue("invert"), f = Ue("gap"), p = Ue("gradientColorStops"), m = Ue("gradientColorStopPositions"), v = Ue("inset"), x = Ue("margin"), g = Ue("opacity"), h = Ue("padding"), y = Ue("saturate"), E = Ue("scale"), P = Ue("sepia"), $ = Ue("skew"), L = Ue("space"), b = Ue("translate"), M = function () { return ["auto", "contain", "none"] }, R = function () { return ["auto", "hidden", "clip", "visible", "scroll"] }, A = function () { return ["auto", Me, t] }, _ = function () { return [Me, t] }, C = function () { return ["", or] }, k = function () { return ["auto", xo, Me] }, O = function () { return ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"] }, U = function () { return ["solid", "dashed", "dotted", "double", "none"] }, z = function () { return ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"] }, D = function () { return ["start", "end", "center", "between", "around", "evenly", "stretch"] }, V = function () { return ["", "0", Me] }, H = function () { return ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"] }, T = function () { return [xo, yc] }, N = function () { return [xo, Me] }; return { cacheSize: 500, theme: { colors: [ja], spacing: [or], blur: ["none", "", pi, Me], brightness: T(), borderColor: [e], borderRadius: ["none", "", "full", pi, Me], borderSpacing: _(), borderWidth: C(), contrast: T(), grayscale: V(), hueRotate: N(), invert: V(), gap: _(), gradientColorStops: [e], gradientColorStopPositions: [A4, ag], inset: A(), margin: A(), opacity: T(), padding: _(), saturate: T(), scale: T(), sepia: V(), skew: N(), space: _(), translate: _() }, classGroups: { aspect: [{ aspect: ["auto", "square", "video", Me] }], container: ["container"], columns: [{ columns: [pi] }], "break-after": [{ "break-after": H() }], "break-before": [{ "break-before": H() }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], float: [{ float: ["right", "left", "none"] }], clear: [{ clear: ["left", "right", "both", "none"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: [].concat(O(), [Me]) }], overflow: [{ overflow: R() }], "overflow-x": [{ "overflow-x": R() }], "overflow-y": [{ "overflow-y": R() }], overscroll: [{ overscroll: M() }], "overscroll-x": [{ "overscroll-x": M() }], "overscroll-y": [{ "overscroll-y": M() }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: [v] }], "inset-x": [{ "inset-x": [v] }], "inset-y": [{ "inset-y": [v] }], start: [{ start: [v] }], end: [{ end: [v] }], top: [{ top: [v] }], right: [{ right: [v] }], bottom: [{ bottom: [v] }], left: [{ left: [v] }], visibility: ["visible", "invisible", "collapse"], z: [{ z: ["auto", Oa] }], basis: [{ basis: A() }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["wrap", "wrap-reverse", "nowrap"] }], flex: [{ flex: ["1", "auto", "initial", "none", Me] }], grow: [{ grow: V() }], shrink: [{ shrink: V() }], order: [{ order: ["first", "last", "none", Oa] }], "grid-cols": [{ "grid-cols": [ja] }], "col-start-end": [{ col: ["auto", { span: ["full", Oa] }, Me] }], "col-start": [{ "col-start": k() }], "col-end": [{ "col-end": k() }], "grid-rows": [{ "grid-rows": [ja] }], "row-start-end": [{ row: ["auto", { span: [Oa] }, Me] }], "row-start": [{ "row-start": k() }], "row-end": [{ "row-end": k() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": ["auto", "min", "max", "fr", Me] }], "auto-rows": [{ "auto-rows": ["auto", "min", "max", "fr", Me] }], gap: [{ gap: [f] }], "gap-x": [{ "gap-x": [f] }], "gap-y": [{ "gap-y": [f] }], "justify-content": [{ justify: ["normal"].concat(D()) }], "justify-items": [{ "justify-items": ["start", "end", "center", "stretch"] }], "justify-self": [{ "justify-self": ["auto", "start", "end", "center", "stretch"] }], "align-content": [{ content: ["normal"].concat(D(), ["baseline"]) }], "align-items": [{ items: ["start", "end", "center", "baseline", "stretch"] }], "align-self": [{ self: ["auto", "start", "end", "center", "stretch", "baseline"] }], "place-content": [{ "place-content": [].concat(D(), ["baseline"]) }], "place-items": [{ "place-items": ["start", "end", "center", "baseline", "stretch"] }], "place-self": [{ "place-self": ["auto", "start", "end", "center", "stretch"] }], p: [{ p: [h] }], px: [{ px: [h] }], py: [{ py: [h] }], ps: [{ ps: [h] }], pe: [{ pe: [h] }], pt: [{ pt: [h] }], pr: [{ pr: [h] }], pb: [{ pb: [h] }], pl: [{ pl: [h] }], m: [{ m: [x] }], mx: [{ mx: [x] }], my: [{ my: [x] }], ms: [{ ms: [x] }], me: [{ me: [x] }], mt: [{ mt: [x] }], mr: [{ mr: [x] }], mb: [{ mb: [x] }], ml: [{ ml: [x] }], "space-x": [{ "space-x": [L] }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": [L] }], "space-y-reverse": ["space-y-reverse"], w: [{ w: ["auto", "min", "max", "fit", Me, t] }], "min-w": [{ "min-w": ["min", "max", "fit", Me, or] }], "max-w": [{ "max-w": ["0", "none", "full", "min", "max", "fit", "prose", { screen: [pi] }, pi, Me] }], h: [{ h: [Me, t, "auto", "min", "max", "fit"] }], "min-h": [{ "min-h": ["min", "max", "fit", Me, or] }], "max-h": [{ "max-h": [Me, t, "min", "max", "fit"] }], "font-size": [{ text: ["base", pi, ag] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", yc] }], "font-family": [{ font: [ja] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractons"], tracking: [{ tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", Me] }], "line-clamp": [{ "line-clamp": ["none", xo, yc] }], leading: [{ leading: ["none", "tight", "snug", "normal", "relaxed", "loose", Me, or] }], "list-image": [{ "list-image": ["none", Me] }], "list-style-type": [{ list: ["none", "disc", "decimal", Me] }], "list-style-position": [{ list: ["inside", "outside"] }], "placeholder-color": [{ placeholder: [e] }], "placeholder-opacity": [{ "placeholder-opacity": [g] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "text-color": [{ text: [e] }], "text-opacity": [{ "text-opacity": [g] }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: [].concat(U(), ["wavy"]) }], "text-decoration-thickness": [{ decoration: ["auto", "from-font", or] }], "underline-offset": [{ "underline-offset": ["auto", Me, or] }], "text-decoration-color": [{ decoration: [e] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], indent: [{ indent: _() }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Me] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", Me] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-opacity": [{ "bg-opacity": [g] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: [].concat(O(), [P4]) }], "bg-repeat": [{ bg: ["no-repeat", { repeat: ["", "x", "y", "round", "space"] }] }], "bg-size": [{ bg: ["auto", "cover", "contain", C4] }], "bg-image": [{ bg: ["none", { "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, $4] }], "bg-color": [{ bg: [e] }], "gradient-from-pos": [{ from: [m] }], "gradient-via-pos": [{ via: [m] }], "gradient-to-pos": [{ to: [m] }], "gradient-from": [{ from: [p] }], "gradient-via": [{ via: [p] }], "gradient-to": [{ to: [p] }], rounded: [{ rounded: [o] }], "rounded-s": [{ "rounded-s": [o] }], "rounded-e": [{ "rounded-e": [o] }], "rounded-t": [{ "rounded-t": [o] }], "rounded-r": [{ "rounded-r": [o] }], "rounded-b": [{ "rounded-b": [o] }], "rounded-l": [{ "rounded-l": [o] }], "rounded-ss": [{ "rounded-ss": [o] }], "rounded-se": [{ "rounded-se": [o] }], "rounded-ee": [{ "rounded-ee": [o] }], "rounded-es": [{ "rounded-es": [o] }], "rounded-tl": [{ "rounded-tl": [o] }], "rounded-tr": [{ "rounded-tr": [o] }], "rounded-br": [{ "rounded-br": [o] }], "rounded-bl": [{ "rounded-bl": [o] }], "border-w": [{ border: [a] }], "border-w-x": [{ "border-x": [a] }], "border-w-y": [{ "border-y": [a] }], "border-w-s": [{ "border-s": [a] }], "border-w-e": [{ "border-e": [a] }], "border-w-t": [{ "border-t": [a] }], "border-w-r": [{ "border-r": [a] }], "border-w-b": [{ "border-b": [a] }], "border-w-l": [{ "border-l": [a] }], "border-opacity": [{ "border-opacity": [g] }], "border-style": [{ border: [].concat(U(), ["hidden"]) }], "divide-x": [{ "divide-x": [a] }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": [a] }], "divide-y-reverse": ["divide-y-reverse"], "divide-opacity": [{ "divide-opacity": [g] }], "divide-style": [{ divide: U() }], "border-color": [{ border: [i] }], "border-color-x": [{ "border-x": [i] }], "border-color-y": [{ "border-y": [i] }], "border-color-t": [{ "border-t": [i] }], "border-color-r": [{ "border-r": [i] }], "border-color-b": [{ "border-b": [i] }], "border-color-l": [{ "border-l": [i] }], "divide-color": [{ divide: [i] }], "outline-style": [{ outline: [""].concat(U()) }], "outline-offset": [{ "outline-offset": [Me, or] }], "outline-w": [{ outline: [or] }], "outline-color": [{ outline: [e] }], "ring-w": [{ ring: C() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: [e] }], "ring-opacity": [{ "ring-opacity": [g] }], "ring-offset-w": [{ "ring-offset": [or] }], "ring-offset-color": [{ "ring-offset": [e] }], shadow: [{ shadow: ["", "inner", "none", pi, M4] }], "shadow-color": [{ shadow: [ja] }], opacity: [{ opacity: [g] }], "mix-blend": [{ "mix-blend": z() }], "bg-blend": [{ "bg-blend": z() }], filter: [{ filter: ["", "none"] }], blur: [{ blur: [n] }], brightness: [{ brightness: [r] }], contrast: [{ contrast: [l] }], "drop-shadow": [{ "drop-shadow": ["", "none", pi, Me] }], grayscale: [{ grayscale: [u] }], "hue-rotate": [{ "hue-rotate": [c] }], invert: [{ invert: [d] }], saturate: [{ saturate: [y] }], sepia: [{ sepia: [P] }], "backdrop-filter": [{ "backdrop-filter": ["", "none"] }], "backdrop-blur": [{ "backdrop-blur": [n] }], "backdrop-brightness": [{ "backdrop-brightness": [r] }], "backdrop-contrast": [{ "backdrop-contrast": [l] }], "backdrop-grayscale": [{ "backdrop-grayscale": [u] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [c] }], "backdrop-invert": [{ "backdrop-invert": [d] }], "backdrop-opacity": [{ "backdrop-opacity": [g] }], "backdrop-saturate": [{ "backdrop-saturate": [y] }], "backdrop-sepia": [{ "backdrop-sepia": [P] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": [s] }], "border-spacing-x": [{ "border-spacing-x": [s] }], "border-spacing-y": [{ "border-spacing-y": [s] }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", Me] }], duration: [{ duration: N() }], ease: [{ ease: ["linear", "in", "out", "in-out", Me] }], delay: [{ delay: N() }], animate: [{ animate: ["none", "spin", "ping", "pulse", "bounce", Me] }], transform: [{ transform: ["", "gpu", "none"] }], scale: [{ scale: [E] }], "scale-x": [{ "scale-x": [E] }], "scale-y": [{ "scale-y": [E] }], rotate: [{ rotate: [Oa, Me] }], "translate-x": [{ "translate-x": [b] }], "translate-y": [{ "translate-y": [b] }], "skew-x": [{ "skew-x": [$] }], "skew-y": [{ "skew-y": [$] }], "transform-origin": [{ origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", Me] }], accent: [{ accent: ["auto", e] }], appearance: ["appearance-none"], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Me] }], "caret-color": [{ caret: [e] }], "pointer-events": [{ "pointer-events": ["none", "auto"] }], resize: [{ resize: ["none", "y", "x", ""] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": _() }], "scroll-mx": [{ "scroll-mx": _() }], "scroll-my": [{ "scroll-my": _() }], "scroll-ms": [{ "scroll-ms": _() }], "scroll-me": [{ "scroll-me": _() }], "scroll-mt": [{ "scroll-mt": _() }], "scroll-mr": [{ "scroll-mr": _() }], "scroll-mb": [{ "scroll-mb": _() }], "scroll-ml": [{ "scroll-ml": _() }], "scroll-p": [{ "scroll-p": _() }], "scroll-px": [{ "scroll-px": _() }], "scroll-py": [{ "scroll-py": _() }], "scroll-ps": [{ "scroll-ps": _() }], "scroll-pe": [{ "scroll-pe": _() }], "scroll-pt": [{ "scroll-pt": _() }], "scroll-pr": [{ "scroll-pr": _() }], "scroll-pb": [{ "scroll-pb": _() }], "scroll-pl": [{ "scroll-pl": _() }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "pinch-zoom", "manipulation", { pan: ["x", "left", "right", "y", "up", "down"] }] }], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", Me] }], fill: [{ fill: [e, "none"] }], "stroke-w": [{ stroke: [or, yc] }], stroke: [{ stroke: [e, "none"] }], sr: ["sr-only", "not-sr-only"] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] } } } function L4(e, t) { for (var n in t) p$(e, n, t[n]); return e } var N4 = Object.prototype.hasOwnProperty, O4 = new Set(["string", "number", "boolean"]); function p$(e, t, n) { if (!N4.call(e, t) || O4.has(typeof n) || n === null) { e[t] = n; return } if (Array.isArray(n) && Array.isArray(e[t])) { e[t] = e[t].concat(n); return } if (typeof n == "object" && typeof e[t] == "object") { if (e[t] === null) { e[t] = n; return } for (var r in n) p$(e[t], r, n[r]) } } function j4(e) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; return typeof e == "function" ? sg.apply(void 0, [lg, e].concat(n)) : sg.apply(void 0, [function () { return L4(lg(), e) }].concat(n)) } var I4 = sg(lg), D4 = { twMerge: !0, twMergeConfig: {}, responsiveVariants: !1 }, h$ = e => e || void 0, tu = (...e) => h$(o$(e).filter(Boolean).join(" ")), Yp = null, zd = {}, ug = !1, Ia = (...e) => t => t.twMerge ? ((!Yp || ug) && (ug = !1, Yp = Sn(zd) ? I4 : j4(zd)), h$(Yp(tu(e)))) : tu(e), bx = (e, t) => { for (let n in t) e.hasOwnProperty(n) ? e[n] = tu(e[n], t[n]) : e[n] = t[n]; return e }, F4 = (e, t) => { let { extend: n = null, slots: r = {}, variants: i = {}, compoundVariants: o = [], compoundSlots: s = [], defaultVariants: a = {} } = e, l = { ...D4, ...t }, u = n != null && n.base ? tu(n.base, e == null ? void 0 : e.base) : e == null ? void 0 : e.base, c = n != null && n.variants && !Sn(n.variants) ? a$(i, n.variants) : i, d = n != null && n.defaultVariants && !Sn(n.defaultVariants) ? { ...n.defaultVariants, ...a } : a; !Sn(l.twMergeConfig) && !a4(l.twMergeConfig, zd) && (ug = !0, zd = l.twMergeConfig); let f = Sn(n == null ? void 0 : n.slots), p = Sn(r) ? {} : { base: tu(e == null ? void 0 : e.base, f && (n == null ? void 0 : n.base)), ...r }, m = f ? p : bx({ ...n == null ? void 0 : n.slots }, Sn(p) ? { base: e == null ? void 0 : e.base } : p), v = g => { if (Sn(c) && Sn(r) && f) return Ia(u, g == null ? void 0 : g.class, g == null ? void 0 : g.className)(l); if (o && !Array.isArray(o)) throw new TypeError(`The "compoundVariants" prop must be an array. Received: ${typeof o}`); if (s && !Array.isArray(s)) throw new TypeError(`The "compoundSlots" prop must be an array. Received: ${typeof s}`); let h = (_, C, k = [], O) => { let U = k; if (typeof C == "string") U = U.concat(mx(C).split(" ").map(z => `${_}:${z}`)); else if (Array.isArray(C)) U = U.concat(C.reduce((z, D) => z.concat(`${_}:${D}`), [])); else if (typeof C == "object" && typeof O == "string") { for (let z in C) if (C.hasOwnProperty(z) && z === O) { let D = C[z]; if (D && typeof D == "string") { let V = mx(D); U[O] ? U[O] = U[O].concat(V.split(" ").map(H => `${_}:${H}`)) : U[O] = V.split(" ").map(H => `${_}:${H}`) } else Array.isArray(D) && D.length > 0 && (U[O] = D.reduce((V, H) => V.concat(`${_}:${H}`), [])) } } return U }, y = (_, C = c, k = null, O = null) => { var U; let z = C[_]; if (!z || Sn(z)) return null; let D = (U = O == null ? void 0 : O[_]) != null ? U : g == null ? void 0 : g[_]; if (D === null) return null; let V = hx(D), H = Array.isArray(l.responsiveVariants) && l.responsiveVariants.length > 0 || l.responsiveVariants === !0, T = d == null ? void 0 : d[_], N = []; if (typeof V == "object" && H) for (let [Q, q] of Object.entries(V)) { let te = z[q]; if (Q === "initial") { T = q; continue } Array.isArray(l.responsiveVariants) && !l.responsiveVariants.includes(Q) || (N = h(Q, te, N, k)) } let W = z[V] || z[hx(T)]; return typeof N == "object" && typeof k == "string" && N[k] ? bx(N, W) : N.length > 0 ? (N.push(W), N) : W }, E = () => c ? Object.keys(c).map(_ => y(_, c)) : null, P = (_, C) => { if (!c || typeof c != "object") return null; let k = new Array; for (let O in c) { let U = y(O, c, _, C), z = _ === "base" && typeof U == "string" ? U : U && U[_]; z && (k[k.length] = z) } return k }, $ = {}; for (let _ in g) g[_] !== void 0 && ($[_] = g[_]); let L = (_, C) => { var k; let O = typeof (g == null ? void 0 : g[_]) == "object" ? { [_]: (k = g[_]) == null ? void 0 : k.initial } : {}; return { ...d, ...$, ...O, ...C } }, b = (_ = [], C) => { let k = []; for (let { class: O, className: U, ...z } of _) { let D = !0; for (let [V, H] of Object.entries(z)) { let T = L(V, C); if (Array.isArray(H)) { if (!H.includes(T[V])) { D = !1; break } } else if (T[V] !== H) { D = !1; break } } D && (O && k.push(O), U && k.push(U)) } return k }, M = _ => { let C = b(o, _), k = b(n == null ? void 0 : n.compoundVariants, _); return s$(k, C) }, R = _ => { let C = M(_); if (!Array.isArray(C)) return C; let k = {}; for (let O of C) if (typeof O == "string" && (k.base = Ia(k.base, O)(l)), typeof O == "object") for (let [U, z] of Object.entries(O)) k[U] = Ia(k[U], z)(l); return k }, A = _ => { if (s.length < 1) return null; let C = {}; for (let { slots: k = [], class: O, className: U, ...z } of s) { if (!Sn(z)) { let D = !0; for (let V of Object.keys(z)) { let H = L(V, _)[V]; if (H === void 0 || (Array.isArray(z[V]) ? !z[V].includes(H) : z[V] !== H)) { D = !1; break } } if (!D) continue } for (let D of k) C[D] = C[D] || [], C[D].push([O, U]) } return C }; if (!Sn(r) || !f) { let _ = {}; if (typeof m == "object" && !Sn(m)) for (let C of Object.keys(m)) _[C] = k => { var O, U; return Ia(m[C], P(C, k), ((O = R(k)) != null ? O : [])[C], ((U = A(k)) != null ? U : [])[C], k == null ? void 0 : k.class, k == null ? void 0 : k.className)(l) }; return _ } return Ia(u, E(), M(), g == null ? void 0 : g.class, g == null ? void 0 : g.className)(l) }, x = () => { if (!(!c || typeof c != "object")) return Object.keys(c) }; return v.variantKeys = x(), v.extend = n, v.base = u, v.slots = m, v.variants = c, v.defaultVariants = d, v.compoundSlots = s, v.compoundVariants = o, v }, In = (e, t) => { var n, r, i; return F4(e, { ...t, twMerge: (n = void 0) != null ? n : !0, twMergeConfig: { theme: { ...(r = void 0) == null ? void 0 : r.theme, ...ig.theme }, classGroups: { ...(i = void 0) == null ? void 0 : i.classGroups, ...ig.classGroups } } }) }, wx = In({ slots: { base: "relative inline-flex flex-col gap-2 items-center justify-center", wrapper: "relative flex", circle1: ["absolute", "w-full", "h-full", "rounded-full", "animate-spinner-ease-spin", "border-2", "border-solid", "border-t-transparent", "border-l-transparent", "border-r-transparent"], circle2: ["absolute", "w-full", "h-full", "rounded-full", "opacity-75", "animate-spinner-linear-spin", "border-2", "border-dotted", "border-t-transparent", "border-l-transparent", "border-r-transparent"], label: "text-foreground dark:text-foreground-dark font-regular" }, variants: { size: { sm: { wrapper: "w-5 h-5", circle1: "border-2", circle2: "border-2", label: "text-small" }, md: { wrapper: "w-8 h-8", circle1: "border-3", circle2: "border-3", label: "text-medium" }, lg: { wrapper: "w-10 h-10", circle1: "border-3", circle2: "border-3", label: "text-large" } }, color: { current: { circle1: "border-b-current", circle2: "border-b-current" }, white: { circle1: "border-b-white", circle2: "border-b-white" }, default: { circle1: "border-b-default", circle2: "border-b-default" }, primary: { circle1: "border-b-primary", circle2: "border-b-primary" }, secondary: { circle1: "border-b-secondary", circle2: "border-b-secondary" }, success: { circle1: "border-b-success", circle2: "border-b-success" }, warning: { circle1: "border-b-warning", circle2: "border-b-warning" }, danger: { circle1: "border-b-danger", circle2: "border-b-danger" } }, labelColor: { foreground: { label: "text-foreground" }, primary: { label: "text-primary" }, secondary: { label: "text-secondary" }, success: { label: "text-success" }, warning: { label: "text-warning" }, danger: { label: "text-danger" } } }, defaultVariants: { size: "md", color: "primary", labelColor: "foreground" } }), Zo = ["outline-none", "data-[focus-visible=true]:z-10", "data-[focus-visible=true]:outline-2", "data-[focus-visible=true]:outline-focus", "data-[focus-visible=true]:outline-offset-2"], z4 = ["outline-none", "group-data-[focus-visible=true]:z-10", "group-data-[focus-visible=true]:ring-2", "group-data-[focus-visible=true]:ring-focus", "group-data-[focus-visible=true]:ring-offset-2", "group-data-[focus-visible=true]:ring-offset-background"], V4 = ["outline-none", "ring-2", "ring-focus", "ring-offset-2", "ring-offset-background"], Qp = ["absolute", "top-1/2", "left-1/2", "-translate-x-1/2", "-translate-y-1/2"], ls = { default: ["[&+.border-medium.border-default]:ms-[calc(theme(borderWidth.medium)*-1)]"], primary: ["[&+.border-medium.border-primary]:ms-[calc(theme(borderWidth.medium)*-1)]"], secondary: ["[&+.border-medium.border-secondary]:ms-[calc(theme(borderWidth.medium)*-1)]"], success: ["[&+.border-medium.border-success]:ms-[calc(theme(borderWidth.medium)*-1)]"], warning: ["[&+.border-medium.border-warning]:ms-[calc(theme(borderWidth.medium)*-1)]"], danger: ["[&+.border-medium.border-danger]:ms-[calc(theme(borderWidth.medium)*-1)]"] }, B4 = { default: "bg-default text-default-foreground", primary: "bg-primary text-primary-foreground", secondary: "bg-secondary text-secondary-foreground", success: "bg-success text-success-foreground", warning: "bg-warning text-warning-foreground", danger: "bg-danger text-danger-foreground", foreground: "bg-foreground text-background" }, U4 = { default: "shadow-lg shadow-default/50 bg-default text-default-foreground", primary: "shadow-lg shadow-primary/40 bg-primary text-primary-foreground", secondary: "shadow-lg shadow-secondary/40 bg-secondary text-secondary-foreground", success: "shadow-lg shadow-success/40 bg-success text-success-foreground", warning: "shadow-lg shadow-warning/40 bg-warning text-warning-foreground", danger: "shadow-lg shadow-danger/40 bg-danger text-danger-foreground", foreground: "shadow-lg shadow-foreground/40 bg-foreground text-background" }, H4 = { default: "bg-transparent border-default text-foreground", primary: "bg-transparent border-primary text-primary", secondary: "bg-transparent border-secondary text-secondary", success: "bg-transparent border-success text-success", warning: "bg-transparent border-warning text-warning", danger: "bg-transparent border-danger text-danger", foreground: "bg-transparent border-foreground text-foreground" }, W4 = { default: "bg-default/40 text-default-700", primary: "bg-primary/20 text-primary-600", secondary: "bg-secondary/20 text-secondary-600", success: "bg-success/20 text-success-700 dark:text-success", warning: "bg-warning/20 text-warning-700 dark:text-warning", danger: "bg-danger/20 text-danger-600 dark:text-danger-500", foreground: "bg-foreground/10 text-foreground" }, G4 = { default: "border-default bg-default-100 text-default-foreground", primary: "border-default bg-default-100 text-primary", secondary: "border-default bg-default-100 text-secondary", success: "border-default bg-default-100 text-success", warning: "border-default bg-default-100 text-warning", danger: "border-default bg-default-100 text-danger", foreground: "border-default bg-default-100 text-foreground" }, K4 = { default: "bg-transparent text-default-foreground", primary: "bg-transparent text-primary", secondary: "bg-transparent text-secondary", success: "bg-transparent text-success", warning: "bg-transparent text-warning", danger: "bg-transparent text-danger", foreground: "bg-transparent text-foreground" }, q4 = { default: "border-default text-default-foreground", primary: "border-primary text-primary", secondary: "border-secondary text-secondary", success: "border-success text-success", warning: "border-warning text-warning", danger: "border-danger text-danger", foreground: "border-foreground text-foreground hover:!bg-foreground" }, J = { solid: B4, shadow: U4, bordered: H4, flat: W4, faded: G4, light: K4, ghost: q4 }, Y4 = In({ slots: { base: ["inline-flex items-center justify-center gap-2 rounded-small outline-none", ...Zo], wrapper: "inline-flex flex-col items-start", name: "text-small text-inherit", description: "text-tiny text-foreground-400" } }), xx = In({ slots: { base: ["group", "relative", "overflow-hidden", "bg-content3 dark:bg-content2", "pointer-events-none", "before:opacity-100", "before:absolute", "before:inset-0", "before:-translate-x-full", "before:animate-[shimmer_2s_infinite]", "before:border-t", "before:border-content4/30", "before:bg-gradient-to-r", "before:from-transparent", "before:via-content4", "dark:before:via-default-700/10", "before:to-transparent", "after:opacity-100", "after:absolute", "after:inset-0", "after:-z-10", "after:bg-content3", "dark:after:bg-content2", "data-[loaded=true]:pointer-events-auto", "data-[loaded=true]:overflow-visible", "data-[loaded=true]:!bg-transparent", "data-[loaded=true]:before:opacity-0 data-[loaded=true]:before:-z-10 data-[loaded=true]:before:animate-none", "data-[loaded=true]:after:opacity-0"], content: ["opacity-0", "group-data-[loaded=true]:opacity-100"] }, variants: { disableAnimation: { true: { base: "before:animate-none before:transition-none after:transition-none", content: "transition-none" }, false: { base: "transition-background !duration-300", content: "transition-opacity motion-reduce:transition-none !duration-300" } } }, defaultVariants: {} }), Sx = In({ slots: { base: "group flex flex-col data-[hidden=true]:hidden", label: ["absolute", "z-10", "pointer-events-none", "origin-top-left", "flex-shrink-0", "rtl:origin-top-right", "subpixel-antialiased", "block", "text-small", "text-foreground-500"], mainWrapper: "h-full", inputWrapper: "relative w-full inline-flex tap-highlight-transparent flex-row items-center shadow-sm px-3 gap-3", innerWrapper: "inline-flex w-full items-center h-full box-border", input: ["w-full font-normal bg-transparent !outline-none placeholder:text-foreground-500 focus-visible:outline-none", "data-[has-start-content=true]:ps-1.5", "data-[has-end-content=true]:pe-1.5", "file:cursor-pointer file:bg-transparent file:border-0", "autofill:bg-transparent bg-clip-text"], clearButton: ["p-2", "-m-2", "z-10", "absolute", "end-3", "start-auto", "pointer-events-none", "appearance-none", "outline-none", "select-none", "opacity-0", "hover:!opacity-100", "cursor-pointer", "active:!opacity-70", "rounded-full", ...Zo], helperWrapper: "hidden group-data-[has-helper=true]:flex p-1 relative flex-col gap-1.5", description: "text-tiny text-foreground-400", errorMessage: "text-tiny text-danger" }, variants: { variant: { flat: { inputWrapper: ["bg-default-100", "data-[hover=true]:bg-default-200", "group-data-[focus=true]:bg-default-100"] }, faded: { inputWrapper: ["bg-default-100", "border-medium", "border-default-200", "data-[hover=true]:border-default-400 focus-within:border-default-400"], value: "group-data-[has-value=true]:text-default-foreground" }, bordered: { inputWrapper: ["border-medium", "border-default-200", "data-[hover=true]:border-default-400", "group-data-[focus=true]:border-default-foreground"] }, underlined: { inputWrapper: ["!px-1", "!pb-0", "!gap-0", "relative", "box-border", "border-b-medium", "shadow-[0_1px_0px_0_rgba(0,0,0,0.05)]", "border-default-200", "!rounded-none", "hover:border-default-300", "after:content-['']", "after:w-0", "after:origin-center", "after:bg-default-foreground", "after:absolute", "after:left-1/2", "after:-translate-x-1/2", "after:-bottom-[2px]", "after:h-[2px]", "group-data-[focus=true]:after:w-full"], innerWrapper: "pb-1", label: "group-data-[filled-within=true]:text-foreground" } }, color: { default: {}, primary: {}, secondary: {}, success: {}, warning: {}, danger: {} }, size: { sm: { label: "text-tiny", inputWrapper: "h-8 min-h-8 px-2 rounded-small", input: "text-small", clearButton: "text-medium" }, md: { inputWrapper: "h-10 min-h-10 rounded-medium", input: "text-small", clearButton: "text-large" }, lg: { label: "text-medium", inputWrapper: "h-12 min-h-12 rounded-large", input: "text-medium", clearButton: "text-large" } }, radius: { none: { inputWrapper: "rounded-none" }, sm: { inputWrapper: "rounded-small" }, md: { inputWrapper: "rounded-medium" }, lg: { inputWrapper: "rounded-large" }, full: { inputWrapper: "rounded-full" } }, labelPlacement: { outside: { mainWrapper: "flex flex-col" }, "outside-left": { base: "flex-row items-center flex-nowrap data-[has-helper=true]:items-start", inputWrapper: "flex-1", mainWrapper: "flex flex-col", label: "relative text-foreground pe-2 ps-2 pointer-events-auto" }, inside: { label: "cursor-text", inputWrapper: "flex-col items-start justify-center gap-0", innerWrapper: "group-data-[has-label=true]:items-end" } }, fullWidth: { true: { base: "w-full" }, false: {} }, isClearable: { true: { input: "peer pe-6 input-search-cancel-button-none", clearButton: ["peer-data-[filled=true]:pointer-events-auto", "peer-data-[filled=true]:opacity-70 peer-data-[filled=true]:block", "peer-data-[filled=true]:scale-100"] } }, isDisabled: { true: { base: "opacity-disabled pointer-events-none", inputWrapper: "pointer-events-none", label: "pointer-events-none" } }, isInvalid: { true: { label: "!text-danger", input: "!placeholder:text-danger !text-danger" } }, isRequired: { true: { label: "after:content-['*'] after:text-danger after:ms-0.5" } }, isMultiline: { true: { label: "relative", inputWrapper: "!h-auto", innerWrapper: "items-start group-data-[has-label=true]:items-start", input: "resize-none data-[hide-scroll=true]:scrollbar-hide", clearButton: "absolute top-2 right-2 rtl:right-auto rtl:left-2 z-10" } }, disableAnimation: { true: { input: "transition-none", inputWrapper: "transition-none", label: "transition-none" }, false: { inputWrapper: "transition-background motion-reduce:transition-none !duration-150", label: ["will-change-auto", "!duration-200", "!ease-out", "motion-reduce:transition-none", "transition-[transform,color,left,opacity]"], clearButton: ["scale-90", "ease-out", "duration-150", "transition-[opacity,transform]", "motion-reduce:transition-none", "motion-reduce:scale-100"] } } }, defaultVariants: { variant: "flat", color: "default", size: "md", fullWidth: !0, labelPlacement: "inside", isDisabled: !1, isMultiline: !1 }, compoundVariants: [{ variant: "flat", color: "default", class: { input: "group-data-[has-value=true]:text-default-foreground" } }, { variant: "flat", color: "primary", class: { inputWrapper: ["bg-primary-100", "data-[hover=true]:bg-primary-50", "text-primary", "group-data-[focus=true]:bg-primary-50", "placeholder:text-primary"], input: "placeholder:text-primary", label: "text-primary" } }, { variant: "flat", color: "secondary", class: { inputWrapper: ["bg-secondary-100", "text-secondary", "data-[hover=true]:bg-secondary-50", "group-data-[focus=true]:bg-secondary-50", "placeholder:text-secondary"], input: "placeholder:text-secondary", label: "text-secondary" } }, { variant: "flat", color: "success", class: { inputWrapper: ["bg-success-100", "text-success-600", "dark:text-success", "placeholder:text-success-600", "dark:placeholder:text-success", "data-[hover=true]:bg-success-50", "group-data-[focus=true]:bg-success-50"], input: "placeholder:text-success-600 dark:placeholder:text-success", label: "text-success-600 dark:text-success" } }, { variant: "flat", color: "warning", class: { inputWrapper: ["bg-warning-100", "text-warning-600", "dark:text-warning", "placeholder:text-warning-600", "dark:placeholder:text-warning", "data-[hover=true]:bg-warning-50", "group-data-[focus=true]:bg-warning-50"], input: "placeholder:text-warning-600 dark:placeholder:text-warning", label: "text-warning-600 dark:text-warning" } }, { variant: "flat", color: "danger", class: { inputWrapper: ["bg-danger-100", "text-danger", "dark:text-danger-500", "placeholder:text-danger", "dark:placeholder:text-danger-500", "data-[hover=true]:bg-danger-50", "group-data-[focus=true]:bg-danger-50"], input: "placeholder:text-danger dark:placeholder:text-danger-500", label: "text-danger dark:text-danger-500" } }, { variant: "faded", color: "primary", class: { label: "text-primary", inputWrapper: "data-[hover=true]:border-primary focus-within:border-primary" } }, { variant: "faded", color: "secondary", class: { label: "text-secondary", inputWrapper: "data-[hover=true]:border-secondary focus-within:border-secondary" } }, { variant: "faded", color: "success", class: { label: "text-success", inputWrapper: "data-[hover=true]:border-success focus-within:border-success" } }, { variant: "faded", color: "warning", class: { label: "text-warning", inputWrapper: "data-[hover=true]:border-warning focus-within:border-warning" } }, { variant: "faded", color: "danger", class: { label: "text-danger", inputWrapper: "data-[hover=true]:border-danger focus-within:border-danger" } }, { variant: "underlined", color: "default", class: { input: "group-data-[has-value=true]:text-foreground" } }, { variant: "underlined", color: "primary", class: { inputWrapper: "after:bg-primary", label: "text-primary" } }, { variant: "underlined", color: "secondary", class: { inputWrapper: "after:bg-secondary", label: "text-secondary" } }, { variant: "underlined", color: "success", class: { inputWrapper: "after:bg-success", label: "text-success" } }, { variant: "underlined", color: "warning", class: { inputWrapper: "after:bg-warning", label: "text-warning" } }, { variant: "underlined", color: "danger", class: { inputWrapper: "after:bg-danger", label: "text-danger" } }, { variant: "bordered", color: "primary", class: { inputWrapper: "group-data-[focus=true]:border-primary", label: "text-primary" } }, { variant: "bordered", color: "secondary", class: { inputWrapper: "group-data-[focus=true]:border-secondary", label: "text-secondary" } }, { variant: "bordered", color: "success", class: { inputWrapper: "group-data-[focus=true]:border-success", label: "text-success" } }, { variant: "bordered", color: "warning", class: { inputWrapper: "group-data-[focus=true]:border-warning", label: "text-warning" } }, { variant: "bordered", color: "danger", class: { inputWrapper: "group-data-[focus=true]:border-danger", label: "text-danger" } }, { labelPlacement: "inside", color: "default", class: { label: "group-data-[filled-within=true]:text-default-600" } }, { labelPlacement: "outside", color: "default", class: { label: "group-data-[filled-within=true]:text-foreground" } }, { radius: "full", size: ["sm"], class: { inputWrapper: "px-3" } }, { radius: "full", size: "md", class: { inputWrapper: "px-4" } }, { radius: "full", size: "lg", class: { inputWrapper: "px-5" } }, { disableAnimation: !1, variant: ["faded", "bordered"], class: { inputWrapper: "transition-colors motion-reduce:transition-none" } }, { disableAnimation: !1, variant: "underlined", class: { inputWrapper: "after:transition-width motion-reduce:after:transition-none" } }, { variant: ["flat", "faded"], class: { inputWrapper: [...z4] } }, { isInvalid: !0, variant: "flat", class: { inputWrapper: ["!bg-danger-50", "data-[hover=true]:!bg-danger-100", "group-data-[focus=true]:!bg-danger-50"] } }, { isInvalid: !0, variant: "bordered", class: { inputWrapper: "!border-danger group-data-[focus=true]:!border-danger" } }, { isInvalid: !0, variant: "underlined", class: { inputWrapper: "after:!bg-danger" } }, { labelPlacement: "inside", size: "sm", class: { inputWrapper: "h-12 py-1.5 px-3" } }, { labelPlacement: "inside", size: "md", class: { inputWrapper: "h-14 py-2" } }, { labelPlacement: "inside", size: "lg", class: { inputWrapper: "h-16 py-2.5 gap-0" } }, { labelPlacement: "inside", size: "sm", variant: ["bordered", "faded"], class: { inputWrapper: "py-1" } }, { labelPlacement: ["inside", "outside"], class: { label: ["group-data-[filled-within=true]:pointer-events-auto"] } }, { labelPlacement: "outside", isMultiline: !1, class: { base: "relative justify-end", label: ["pb-0", "z-20", "top-1/2", "-translate-y-1/2", "group-data-[filled-within=true]:start-0"] } }, { labelPlacement: ["inside"], class: { label: ["group-data-[filled-within=true]:scale-85"] } }, { labelPlacement: ["inside"], variant: "flat", class: { innerWrapper: "pb-0.5" } }, { variant: "underlined", size: "sm", class: { innerWrapper: "pb-1" } }, { variant: "underlined", size: ["md", "lg"], class: { innerWrapper: "pb-1.5" } }, { labelPlacement: "inside", size: ["sm", "md"], class: { label: "text-small" } }, { labelPlacement: "inside", isMultiline: !1, size: "sm", class: { label: ["group-data-[filled-within=true]:-translate-y-[calc(50%_+_theme(fontSize.tiny)/2_-_8px)]"] } }, { labelPlacement: "inside", isMultiline: !1, size: "md", class: { label: ["group-data-[filled-within=true]:-translate-y-[calc(50%_+_theme(fontSize.small)/2_-_6px)]"] } }, { labelPlacement: "inside", isMultiline: !1, size: "lg", class: { label: ["text-medium", "group-data-[filled-within=true]:-translate-y-[calc(50%_+_theme(fontSize.small)/2_-_8px)]"] } }, { labelPlacement: "inside", variant: ["faded", "bordered"], isMultiline: !1, size: "sm", class: { label: ["group-data-[filled-within=true]:-translate-y-[calc(50%_+_theme(fontSize.tiny)/2_-_8px_-_theme(borderWidth.medium))]"] } }, { labelPlacement: "inside", variant: ["faded", "bordered"], isMultiline: !1, size: "md", class: { label: ["group-data-[filled-within=true]:-translate-y-[calc(50%_+_theme(fontSize.small)/2_-_6px_-_theme(borderWidth.medium))]"] } }, { labelPlacement: "inside", variant: ["faded", "bordered"], isMultiline: !1, size: "lg", class: { label: ["text-medium", "group-data-[filled-within=true]:-translate-y-[calc(50%_+_theme(fontSize.small)/2_-_8px_-_theme(borderWidth.medium))]"] } }, { labelPlacement: "inside", variant: "underlined", isMultiline: !1, size: "sm", class: { label: ["group-data-[filled-within=true]:-translate-y-[calc(50%_+_theme(fontSize.tiny)/2_-_5px)]"] } }, { labelPlacement: "inside", variant: "underlined", isMultiline: !1, size: "md", class: { label: ["group-data-[filled-within=true]:-translate-y-[calc(50%_+_theme(fontSize.small)/2_-_3.5px)]"] } }, { labelPlacement: "inside", variant: "underlined", size: "lg", isMultiline: !1, class: { label: ["text-medium", "group-data-[filled-within=true]:-translate-y-[calc(50%_+_theme(fontSize.small)/2_-_4px)]"] } }, { labelPlacement: "outside", size: "sm", isMultiline: !1, class: { label: ["start-2", "text-tiny", "group-data-[filled-within=true]:-translate-y-[calc(100%_+_theme(fontSize.tiny)/2_+_16px)]"], base: "data-[has-label=true]:mt-[calc(theme(fontSize.small)_+_8px)]" } }, { labelPlacement: "outside", size: "md", isMultiline: !1, class: { label: ["start-3", "end-auto", "text-small", "group-data-[filled-within=true]:-translate-y-[calc(100%_+_theme(fontSize.small)/2_+_20px)]"], base: "data-[has-label=true]:mt-[calc(theme(fontSize.small)_+_10px)]" } }, { labelPlacement: "outside", size: "lg", isMultiline: !1, class: { label: ["start-3", "end-auto", "text-medium", "group-data-[filled-within=true]:-translate-y-[calc(100%_+_theme(fontSize.small)/2_+_24px)]"], base: "data-[has-label=true]:mt-[calc(theme(fontSize.small)_+_12px)]" } }, { labelPlacement: "outside-left", size: "sm", class: { label: "group-data-[has-helper=true]:pt-2" } }, { labelPlacement: "outside-left", size: "md", class: { label: "group-data-[has-helper=true]:pt-3" } }, { labelPlacement: "outside-left", size: "lg", class: { label: "group-data-[has-helper=true]:pt-4" } }, { labelPlacement: ["outside", "outside-left"], isMultiline: !0, class: { inputWrapper: "py-2" } }, { labelPlacement: "outside", isMultiline: !0, class: { label: "pb-1.5" } }, { labelPlacement: "inside", isMultiline: !0, class: { label: "pb-0.5", input: "pt-0" } }, { isMultiline: !0, disableAnimation: !1, class: { input: "transition-height !duration-100 motion-reduce:transition-none" } }, { labelPlacement: ["inside", "outside"], class: { label: ["pe-2", "max-w-full", "text-ellipsis", "overflow-hidden"] } }, { isMultiline: !0, radius: "full", class: { inputWrapper: "data-[has-multiple-rows=true]:rounded-large" } }, { isClearable: !0, isMultiline: !0, class: { clearButton: ["group-data-[has-value=true]:opacity-70 group-data-[has-value=true]:block", "group-data-[has-value=true]:scale-100", "group-data-[has-value=true]:pointer-events-auto"] } }] }), Ex = In({ slots: { base: ["flex", "z-40", "w-full", "h-auto", "items-center", "justify-center", "data-[menu-open=true]:border-none"], wrapper: ["z-40", "flex", "px-6", "gap-4", "w-full", "flex-row", "relative", "flex-nowrap", "items-center", "justify-between", "h-[var(--navbar-height)]"], toggle: ["group", "flex", "items-center", "justify-center", "w-6", "h-full", "outline-none", "rounded-small", "tap-highlight-transparent", ...Zo], srOnly: ["sr-only"], toggleIcon: ["w-full", "h-full", "pointer-events-none", "flex", "flex-col", "items-center", "justify-center", "text-inherit", "group-data-[pressed=true]:opacity-70", "transition-opacity", "before:content-['']", "before:block", "before:h-px", "before:w-6", "before:bg-current", "before:transition-transform", "before:duration-150", "before:-translate-y-1", "before:rotate-0", "group-data-[open=true]:before:translate-y-px", "group-data-[open=true]:before:rotate-45", "after:content-['']", "after:block", "after:h-px", "after:w-6", "after:bg-current", "after:transition-transform", "after:duration-150", "after:translate-y-1", "after:rotate-0", "group-data-[open=true]:after:translate-y-0", "group-data-[open=true]:after:-rotate-45"], brand: ["flex", "basis-0", "flex-row", "flex-grow", "flex-nowrap", "justify-start", "bg-transparent", "items-center", "no-underline", "text-medium", "whitespace-nowrap", "box-border"], content: ["flex", "gap-4", "h-full", "flex-row", "flex-nowrap", "items-center", "data-[justify=start]:justify-start", "data-[justify=start]:flex-grow", "data-[justify=start]:basis-0", "data-[justify=center]:justify-center", "data-[justify=end]:justify-end", "data-[justify=end]:flex-grow", "data-[justify=end]:basis-0"], item: ["text-medium", "whitespace-nowrap", "box-border", "list-none", "data-[active=true]:font-semibold"], menu: ["z-30", "px-6", "pt-2", "fixed", "flex", "max-w-full", "top-[var(--navbar-height)]", "inset-x-0", "bottom-0", "w-screen", "flex-col", "gap-2", "overflow-y-auto"], menuItem: ["text-large", "data-[active=true]:font-semibold"] }, variants: { position: { static: { base: "static" }, sticky: { base: "sticky top-0 inset-x-0" } }, maxWidth: { sm: { wrapper: "max-w-[640px]" }, md: { wrapper: "max-w-[768px]" }, lg: { wrapper: "max-w-[1024px]" }, xl: { wrapper: "max-w-[1280px]" }, "2xl": { wrapper: "max-w-[1536px]" }, full: { wrapper: "max-w-full" } }, hideOnScroll: { true: { base: ["sticky", "top-0", "inset-x-0"] } }, isBordered: { true: { base: ["border-b", "border-divider"] } }, isBlurred: { false: { base: "bg-background", menu: "bg-background" }, true: { base: ["backdrop-blur-lg", "data-[menu-open=true]:backdrop-blur-xl", "backdrop-saturate-150", "bg-background/70"], menu: ["backdrop-blur-xl", "backdrop-saturate-150", "bg-background/70"] } }, disableAnimation: { true: { menu: ["hidden", "h-[calc(100dvh_-_var(--navbar-height))]", "data-[open=true]:flex"] } } }, defaultVariants: { maxWidth: "lg", position: "sticky", isBlurred: !0 } }), Tx = In({ slots: { base: ["p-2.5", "-m-2.5", "overflow-x-scroll", "scrollbar-hide"], wrapper: ["flex", "flex-nowrap", "h-fit", "max-w-fit", "relative", "gap-1", "items-center", "overflow-visible"], item: ["tap-highlight-transparent", "select-none", "touch-none"], prev: "", next: "", cursor: ["absolute", "flex", "overflow-visible", "items-center", "justify-center", "origin-center", "left-0", "select-none", "touch-none", "pointer-events-none", "z-20"], forwardIcon: ["hidden", "group-hover:block", "group-data-[focus-visible=true]:block", "data-[before=true]:rotate-180"], ellipsis: "group-hover:hidden group-data-[focus-visible=true]:hidden", chevronNext: "rotate-180" }, variants: { variant: { bordered: { item: ["border-medium", "border-default", "bg-transparent", "data-[hover=true]:bg-default-100"] }, light: { item: "bg-transparent" }, flat: {}, faded: { item: ["border-medium", "border-default"] } }, color: { default: { cursor: J.solid.default }, primary: { cursor: J.solid.primary }, secondary: { cursor: J.solid.secondary }, success: { cursor: J.solid.success }, warning: { cursor: J.solid.warning }, danger: { cursor: J.solid.danger } }, size: { sm: {}, md: {}, lg: {} }, radius: { none: {}, sm: {}, md: {}, lg: {}, full: {} }, isCompact: { true: { wrapper: "gap-0 shadow-sm", item: ["shadow-none", "first-of-type:rounded-e-none", "last-of-type:rounded-s-none", "[&:not(:first-of-type):not(:last-of-type)]:rounded-none"], prev: "!rounded-e-none", next: "!rounded-s-none" } }, isDisabled: { true: { base: "opacity-disabled pointer-events-none" } }, showShadow: { true: {} }, disableCursorAnimation: { true: { cursor: "hidden" } }, disableAnimation: { true: { item: "transition-none", cursor: "transition-none" }, false: { item: ["data-[pressed=true]:scale-[0.97]", "transition-transform-background"], cursor: ["data-[moving=true]:transition-transform", "!data-[moving=true]:duration-300", "opacity-0", "data-[moving]:opacity-100"] } } }, defaultVariants: { variant: "flat", color: "primary", size: "md", radius: "md", isCompact: !1, isDisabled: !1, showShadow: !1, disableCursorAnimation: !1 }, compoundVariants: [{ showShadow: !0, color: "default", class: { cursor: [J.shadow.default, "shadow-md"] } }, { showShadow: !0, color: "primary", class: { cursor: [J.shadow.primary, "shadow-md"] } }, { showShadow: !0, color: "secondary", class: { cursor: [J.shadow.secondary, "shadow-md"] } }, { showShadow: !0, color: "success", class: { cursor: [J.shadow.success, "shadow-md"] } }, { showShadow: !0, color: "warning", class: { cursor: [J.shadow.warning, "shadow-md"] } }, { showShadow: !0, color: "danger", class: { cursor: [J.shadow.danger, "shadow-md"] } }, { isCompact: !0, variant: "bordered", class: { item: "[&:not(:first-of-type)]:ms-[calc(theme(borderWidth.2)*-1)]" } }, { disableCursorAnimation: !0, color: "default", class: { item: ["data-[active=true]:bg-default-400", "data-[active=true]:border-default-400", "data-[active=true]:text-default-foreground"] } }, { disableCursorAnimation: !0, color: "primary", class: { item: ["data-[active=true]:bg-primary", "data-[active=true]:border-primary", "data-[active=true]:text-primary-foreground"] } }, { disableCursorAnimation: !0, color: "secondary", class: { item: ["data-[active=true]:bg-secondary", "data-[active=true]:border-secondary", "data-[active=true]:text-secondary-foreground"] } }, { disableCursorAnimation: !0, color: "success", class: { item: ["data-[active=true]:bg-success", "data-[active=true]:border-success", "data-[active=true]:text-success-foreground"] } }, { disableCursorAnimation: !0, color: "warning", class: { item: ["data-[active=true]:bg-warning", "data-[active=true]:border-warning", "data-[active=true]:text-warning-foreground"] } }, { disableCursorAnimation: !0, color: "danger", class: { item: ["data-[active=true]:bg-danger", "data-[active=true]:border-danger", "data-[active=true]:text-danger-foreground"] } }, { disableCursorAnimation: !0, showShadow: !0, color: "default", class: { item: ["data-[active=true]:shadow-md", "data-[active=true]:shadow-default/50"] } }, { disableCursorAnimation: !0, showShadow: !0, color: "primary", class: { item: ["data-[active=true]:shadow-md", "data-[active=true]:shadow-primary/40"] } }, { disableCursorAnimation: !0, showShadow: !0, color: "secondary", class: { item: ["data-[active=true]:shadow-md", "data-[active=true]:shadow-secondary/40"] } }, { disableCursorAnimation: !0, showShadow: !0, color: "success", class: { item: ["data-[active=true]:shadow-md", "data-[active=true]:shadow-success/40"] } }, { disableCursorAnimation: !0, showShadow: !0, color: "warning", class: { item: ["data-[active=true]:shadow-md", "data-[active=true]:shadow-warning/40"] } }, { disableCursorAnimation: !0, showShadow: !0, color: "danger", class: { item: ["data-[active=true]:shadow-md", "data-[active=true]:shadow-danger/40"] } }], compoundSlots: [{ slots: ["item", "prev", "next"], class: ["flex", "flex-wrap", "truncate", "box-border", "outline-none", "items-center", "justify-center", "text-default-foreground", ...Zo, "data-[disabled=true]:text-default-300", "data-[disabled=true]:pointer-events-none"] }, { slots: ["item", "prev", "next"], variant: ["flat", "bordered", "faded"], class: ["shadow-sm"] }, { slots: ["item", "prev", "next"], variant: "flat", class: ["bg-default-100", "[&[data-hover=true]:not([data-active=true])]:bg-default-200", "active:bg-default-300"] }, { slots: ["item", "prev", "next"], variant: "faded", class: ["bg-default-50", "[&[data-hover=true]:not([data-active=true])]:bg-default-100", "active:bg-default-200"] }, { slots: ["item", "prev", "next"], variant: "light", class: ["[&[data-hover=true]:not([data-active=true])]:bg-default-100", "active:bg-default-200"] }, { slots: ["item", "cursor", "prev", "next"], size: "sm", class: "min-w-8 w-8 h-8 text-tiny" }, { slots: ["item", "cursor", "prev", "next"], size: "md", class: "min-w-9 w-9 h-9 text-small" }, { slots: ["item", "cursor", "prev", "next"], size: "lg", class: "min-w-10 w-10 h-10 text-medium" }, { slots: ["wrapper", "item", "cursor", "prev", "next"], radius: "none", class: "rounded-none" }, { slots: ["wrapper", "item", "cursor", "prev", "next"], radius: "sm", class: "rounded-small" }, { slots: ["wrapper", "item", "cursor", "prev", "next"], radius: "md", class: "rounded-medium" }, { slots: ["wrapper", "item", "cursor", "prev", "next"], radius: "lg", class: "rounded-large" }, { slots: ["wrapper", "item", "cursor", "prev", "next"], radius: "full", class: "rounded-full" }] }), Q4 = In({ base: "flex flex-col gap-2 items-start" }), X4 = In({ base: ["z-0", "group", "relative", "inline-flex", "items-center", "justify-center", "box-border", "appearance-none", "outline-none", "select-none", "whitespace-nowrap", "min-w-max", "font-normal", "subpixel-antialiased", "overflow-hidden", "tap-highlight-transparent", "data-[pressed=true]:scale-[0.97]", ...Zo], variants: { variant: { solid: "", bordered: "border-medium bg-transparent", light: "bg-transparent", flat: "", faded: "border-medium", shadow: "", ghost: "border-medium bg-transparent" }, size: { sm: "px-3 min-w-16 h-8 text-tiny gap-2 rounded-small", md: "px-4 min-w-20 h-10 text-small gap-2 rounded-medium", lg: "px-6 min-w-24 h-12 text-medium gap-3 rounded-large" }, color: { default: "", primary: "", secondary: "", success: "", warning: "", danger: "" }, radius: { none: "rounded-none", sm: "rounded-small", md: "rounded-medium", lg: "rounded-large", full: "rounded-full" }, fullWidth: { true: "w-full" }, isDisabled: { true: "opacity-disabled pointer-events-none" }, isInGroup: { true: "[&:not(:first-child):not(:last-child)]:rounded-none" }, isIconOnly: { true: "px-0 !gap-0", false: "[&>svg]:max-w-[theme(spacing.8)]" }, disableAnimation: { true: "!transition-none data-[pressed=true]:scale-100", false: "transition-transform-colors-opacity motion-reduce:transition-none" } }, defaultVariants: { size: "md", variant: "solid", color: "default", fullWidth: !1, isDisabled: !1, isInGroup: !1 }, compoundVariants: [{ variant: "solid", color: "default", class: J.solid.default }, { variant: "solid", color: "primary", class: J.solid.primary }, { variant: "solid", color: "secondary", class: J.solid.secondary }, { variant: "solid", color: "success", class: J.solid.success }, { variant: "solid", color: "warning", class: J.solid.warning }, { variant: "solid", color: "danger", class: J.solid.danger }, { variant: "shadow", color: "default", class: J.shadow.default }, { variant: "shadow", color: "primary", class: J.shadow.primary }, { variant: "shadow", color: "secondary", class: J.shadow.secondary }, { variant: "shadow", color: "success", class: J.shadow.success }, { variant: "shadow", color: "warning", class: J.shadow.warning }, { variant: "shadow", color: "danger", class: J.shadow.danger }, { variant: "bordered", color: "default", class: J.bordered.default }, { variant: "bordered", color: "primary", class: J.bordered.primary }, { variant: "bordered", color: "secondary", class: J.bordered.secondary }, { variant: "bordered", color: "success", class: J.bordered.success }, { variant: "bordered", color: "warning", class: J.bordered.warning }, { variant: "bordered", color: "danger", class: J.bordered.danger }, { variant: "flat", color: "default", class: J.flat.default }, { variant: "flat", color: "primary", class: J.flat.primary }, { variant: "flat", color: "secondary", class: J.flat.secondary }, { variant: "flat", color: "success", class: J.flat.success }, { variant: "flat", color: "warning", class: J.flat.warning }, { variant: "flat", color: "danger", class: J.flat.danger }, { variant: "faded", color: "default", class: J.faded.default }, { variant: "faded", color: "primary", class: J.faded.primary }, { variant: "faded", color: "secondary", class: J.faded.secondary }, { variant: "faded", color: "success", class: J.faded.success }, { variant: "faded", color: "warning", class: J.faded.warning }, { variant: "faded", color: "danger", class: J.faded.danger }, { variant: "light", color: "default", class: [J.light.default, "data-[hover=true]:bg-default/40"] }, { variant: "light", color: "primary", class: [J.light.primary, "data-[hover=true]:bg-primary/20"] }, { variant: "light", color: "secondary", class: [J.light.secondary, "data-[hover=true]:bg-secondary/20"] }, { variant: "light", color: "success", class: [J.light.success, "data-[hover=true]:bg-success/20"] }, { variant: "light", color: "warning", class: [J.light.warning, "data-[hover=true]:bg-warning/20"] }, { variant: "light", color: "danger", class: [J.light.danger, "data-[hover=true]:bg-danger/20"] }, { variant: "ghost", color: "default", class: [J.ghost.default, "data-[hover=true]:!bg-default"] }, { variant: "ghost", color: "primary", class: [J.ghost.primary, "data-[hover=true]:!bg-primary data-[hover=true]:!text-primary-foreground"] }, { variant: "ghost", color: "secondary", class: [J.ghost.secondary, "data-[hover=true]:!bg-secondary data-[hover=true]:!text-secondary-foreground"] }, { variant: "ghost", color: "success", class: [J.ghost.success, "data-[hover=true]:!bg-success data-[hover=true]:!text-success-foreground"] }, { variant: "ghost", color: "warning", class: [J.ghost.warning, "data-[hover=true]:!bg-warning data-[hover=true]:!text-warning-foreground"] }, { variant: "ghost", color: "danger", class: [J.ghost.danger, "data-[hover=true]:!bg-danger data-[hover=true]:!text-danger-foreground"] }, { isInGroup: !0, class: "rounded-none first:rounded-s-medium last:rounded-e-medium" }, { isInGroup: !0, size: "sm", class: "rounded-none first:rounded-s-small last:rounded-e-small" }, { isInGroup: !0, size: "md", class: "rounded-none first:rounded-s-medium last:rounded-e-medium" }, { isInGroup: !0, size: "lg", class: "rounded-none first:rounded-s-large last:rounded-e-large" }, { isInGroup: !0, isRounded: !0, class: "rounded-none first:rounded-s-full last:rounded-e-full" }, { isInGroup: !0, radius: "none", class: "rounded-none first:rounded-s-none last:rounded-e-none" }, { isInGroup: !0, radius: "sm", class: "rounded-none first:rounded-s-small last:rounded-e-small" }, { isInGroup: !0, radius: "md", class: "rounded-none first:rounded-s-medium last:rounded-e-medium" }, { isInGroup: !0, radius: "lg", class: "rounded-none first:rounded-s-large last:rounded-e-large" }, { isInGroup: !0, radius: "full", class: "rounded-none first:rounded-s-full last:rounded-e-full" }, { isInGroup: !0, variant: ["ghost", "bordered"], color: "default", className: ls.default }, { isInGroup: !0, variant: ["ghost", "bordered"], color: "primary", className: ls.primary }, { isInGroup: !0, variant: ["ghost", "bordered"], color: "secondary", className: ls.secondary }, { isInGroup: !0, variant: ["ghost", "bordered"], color: "success", className: ls.success }, { isInGroup: !0, variant: ["ghost", "bordered"], color: "warning", className: ls.warning }, { isInGroup: !0, variant: ["ghost", "bordered"], color: "danger", className: ls.danger }, { isIconOnly: !0, size: "sm", class: "min-w-8 w-8 h-8" }, { isIconOnly: !0, size: "md", class: "min-w-10 w-10 h-10" }, { isIconOnly: !0, size: "lg", class: "min-w-12 w-12 h-12" }, { variant: ["solid", "faded", "flat", "bordered", "shadow"], class: "data-[hover=true]:opacity-hover" }] }); In({ base: "inline-flex items-center justify-center h-auto", variants: { fullWidth: { true: "w-full" } }, defaultVariants: { fullWidth: !1 } }); var Cx = In({ slots: { base: ["flex", "flex-col", "relative", "overflow-hidden", "h-auto", "outline-none", "text-foreground", "box-border", "bg-content1", ...Zo], header: ["flex", "p-3", "z-10", "w-full", "justify-start", "items-center", "shrink-0", "overflow-inherit", "color-inherit", "subpixel-antialiased"], body: ["relative", "flex", "flex-1", "w-full", "p-3", "flex-auto", "flex-col", "place-content-inherit", "align-items-inherit", "h-auto", "break-words", "text-left", "overflow-y-auto", "subpixel-antialiased"], footer: ["p-3", "h-auto", "flex", "w-full", "items-center", "overflow-hidden", "color-inherit", "subpixel-antialiased"] }, variants: { shadow: { none: { base: "shadow-none" }, sm: { base: "shadow-small" }, md: { base: "shadow-medium" }, lg: { base: "shadow-large" } }, radius: { none: { base: "rounded-none", header: "rounded-none", footer: "rounded-none" }, sm: { base: "rounded-small", header: "rounded-t-small", footer: "rounded-b-small" }, md: { base: "rounded-medium", header: "rounded-t-medium", footer: "rounded-b-medium" }, lg: { base: "rounded-large", header: "rounded-t-large", footer: "rounded-b-large" } }, fullWidth: { true: { base: "w-full" } }, isHoverable: { true: { base: "data-[hover=true]:bg-content2 dark:data-[hover=true]:bg-content2" } }, isPressable: { true: { base: "cursor-pointer" } }, isBlurred: { true: { base: ["bg-background/80", "dark:bg-background/20", "backdrop-blur-md", "backdrop-saturate-150"] } }, isFooterBlurred: { true: { footer: ["bg-background/10", "backdrop-blur", "backdrop-saturate-150"] } }, isDisabled: { true: { base: "opacity-disabled cursor-not-allowed" } }, disableAnimation: { true: "", false: { base: "transition-transform-background motion-reduce:transition-none" } } }, compoundVariants: [{ isPressable: !0, class: "data-[pressed=true]:scale-[0.97] tap-highlight-transparent" }], defaultVariants: { radius: "lg", shadow: "md", fullWidth: !1, isHoverable: !1, isPressable: !1, isDisabled: !1, isFooterBlurred: !1 } }), Vd = In({ slots: { base: ["relative", "max-w-fit", "min-w-min", "inline-flex", "items-center", "justify-between", "box-border", "whitespace-nowrap"], content: "flex-1 text-inherit font-normal", dot: ["w-2", "h-2", "ml-1", "rounded-full"], avatar: "flex-shrink-0", closeButton: ["z-10", "appearance-none", "outline-none", "select-none", "transition-opacity", "opacity-70", "hover:opacity-100", "cursor-pointer", "active:opacity-disabled", "tap-highlight-transparent"] }, variants: { variant: { solid: {}, bordered: { base: "border-medium bg-transparent" }, light: { base: "bg-transparent" }, flat: {}, faded: { base: "border-medium" }, shadow: {}, dot: { base: "border-medium border-default text-foreground bg-transparent" } }, color: { default: { dot: "bg-default-400" }, primary: { dot: "bg-primary" }, secondary: { dot: "bg-secondary" }, success: { dot: "bg-success" }, warning: { dot: "bg-warning" }, danger: { dot: "bg-danger" } }, size: { sm: { base: "px-1 h-6 text-tiny", content: "px-1", closeButton: "text-medium", avatar: "w-4 h-4" }, md: { base: "px-1 h-7 text-small", content: "px-2", closeButton: "text-large", avatar: "w-5 h-5" }, lg: { base: "px-2 h-8 text-medium", content: "px-2", closeButton: "text-xl", avatar: "w-6 h-6" } }, radius: { none: { base: "rounded-none" }, sm: { base: "rounded-small" }, md: { base: "rounded-medium" }, lg: { base: "rounded-large" }, full: { base: "rounded-full" } }, isOneChar: { true: {}, false: {} }, isCloseable: { true: {}, false: {} }, hasStartContent: { true: {} }, hasEndContent: { true: {} }, isDisabled: { true: { base: "opacity-disabled pointer-events-none" } }, isCloseButtonFocusVisible: { true: { closeButton: [...V4, "ring-1", "rounded-full"] } } }, defaultVariants: { variant: "solid", color: "default", size: "md", radius: "full", isDisabled: !1 }, compoundVariants: [{ variant: "solid", color: "default", class: { base: J.solid.default } }, { variant: "solid", color: "primary", class: { base: J.solid.primary } }, { variant: "solid", color: "secondary", class: { base: J.solid.secondary } }, { variant: "solid", color: "success", class: { base: J.solid.success } }, { variant: "solid", color: "warning", class: { base: J.solid.warning } }, { variant: "solid", color: "danger", class: { base: J.solid.danger } }, { variant: "shadow", color: "default", class: { base: J.shadow.default } }, { variant: "shadow", color: "primary", class: { base: J.shadow.primary } }, { variant: "shadow", color: "secondary", class: { base: J.shadow.secondary } }, { variant: "shadow", color: "success", class: { base: J.shadow.success } }, { variant: "shadow", color: "warning", class: { base: J.shadow.warning } }, { variant: "shadow", color: "danger", class: { base: J.shadow.danger } }, { variant: "bordered", color: "default", class: { base: J.bordered.default } }, { variant: "bordered", color: "primary", class: { base: J.bordered.primary } }, { variant: "bordered", color: "secondary", class: { base: J.bordered.secondary } }, { variant: "bordered", color: "success", class: { base: J.bordered.success } }, { variant: "bordered", color: "warning", class: { base: J.bordered.warning } }, { variant: "bordered", color: "danger", class: { base: J.bordered.danger } }, { variant: "flat", color: "default", class: { base: J.flat.default } }, { variant: "flat", color: "primary", class: { base: J.flat.primary } }, { variant: "flat", color: "secondary", class: { base: J.flat.secondary } }, { variant: "flat", color: "success", class: { base: J.flat.success } }, { variant: "flat", color: "warning", class: { base: J.flat.warning } }, { variant: "flat", color: "danger", class: { base: J.flat.danger } }, { variant: "faded", color: "default", class: { base: J.faded.default } }, { variant: "faded", color: "primary", class: { base: J.faded.primary } }, { variant: "faded", color: "secondary", class: { base: J.faded.secondary } }, { variant: "faded", color: "success", class: { base: J.faded.success } }, { variant: "faded", color: "warning", class: { base: J.faded.warning } }, { variant: "faded", color: "danger", class: { base: J.faded.danger } }, { variant: "light", color: "default", class: { base: J.light.default } }, { variant: "light", color: "primary", class: { base: J.light.primary } }, { variant: "light", color: "secondary", class: { base: J.light.secondary } }, { variant: "light", color: "success", class: { base: J.light.success } }, { variant: "light", color: "warning", class: { base: J.light.warning } }, { variant: "light", color: "danger", class: { base: J.light.danger } }, { isOneChar: !0, hasStartContent: !1, hasEndContent: !1, size: "sm", class: { base: "w-5 h-5 min-w-5 min-h-5" } }, { isOneChar: !0, hasStartContent: !1, hasEndContent: !1, size: "md", class: { base: "w-6 h-6 min-w-6 min-h-6" } }, { isOneChar: !0, hasStartContent: !1, hasEndContent: !1, size: "lg", class: { base: "w-7 h-7 min-w-7 min-h-7" } }, { isOneChar: !0, isCloseable: !1, hasStartContent: !1, hasEndContent: !1, class: { base: "px-0 justify-center", content: "px-0 flex-none" } }, { isOneChar: !0, isCloseable: !0, hasStartContent: !1, hasEndContent: !1, class: { base: "w-auto" } }, { isOneChar: !0, variant: "dot", class: { base: "w-auto h-7 px-1 items-center", content: "px-2" } }, { hasStartContent: !0, size: "sm", class: { content: "pl-0.5" } }, { hasStartContent: !0, size: ["md", "lg"], class: { content: "pl-1" } }, { hasEndContent: !0, size: "sm", class: { content: "pr-0.5" } }, { hasEndContent: !0, size: ["md", "lg"], class: { content: "pr-1" } }] }), J4 = In({ slots: { base: ["flex", "relative", "justify-center", "items-center", "box-border", "overflow-hidden", "align-middle", "text-white", "z-0", ...Zo], img: ["flex", "object-cover", "w-full", "h-full", "transition-opacity", "!duration-500", "opacity-0", "data-[loaded=true]:opacity-100"], fallback: [...Qp, "flex", "items-center", "justify-center"], name: [...Qp, "font-normal", "text-center", "text-inherit"], icon: [...Qp, "flex", "items-center", "justify-center", "text-inherit", "w-full", "h-full"] }, variants: { size: { sm: { base: "w-8 h-8 text-tiny" }, md: { base: "w-10 h-10 text-tiny" }, lg: { base: "w-14 h-14 text-small" } }, color: { default: { base: J.solid.default }, primary: { base: J.solid.primary }, secondary: { base: J.solid.secondary }, success: { base: J.solid.success }, warning: { base: J.solid.warning }, danger: { base: J.solid.danger } }, radius: { none: { base: "rounded-none" }, sm: { base: "rounded-small" }, md: { base: "rounded-medium" }, lg: { base: "rounded-large" }, full: { base: "rounded-full" } }, isBordered: { true: { base: "ring-2 ring-offset-2 ring-offset-background dark:ring-offset-background-dark" } }, isDisabled: { true: { base: "opacity-disabled" } }, isInGroup: { true: { base: ["-ms-2 data-[hover=true]:-translate-x-3 rtl:data-[hover=true]:translate-x-3 transition-transform", "data-[focus-visible=true]:-translate-x-3 rtl:data-[focus-visible=true]:translate-x-3"] } }, isInGridGroup: { true: { base: "m-0 data-[hover=true]:translate-x-0" } }, disableAnimation: { true: { base: "transition-none", img: "transition-none" }, false: {} } }, defaultVariants: { size: "md", color: "default", radius: "full" }, compoundVariants: [{ color: "default", isBordered: !0, class: { base: "ring-default" } }, { color: "primary", isBordered: !0, class: { base: "ring-primary" } }, { color: "secondary", isBordered: !0, class: { base: "ring-secondary" } }, { color: "success", isBordered: !0, class: { base: "ring-success" } }, { color: "warning", isBordered: !0, class: { base: "ring-warning" } }, { color: "danger", isBordered: !0, class: { base: "ring-danger" } }] }); In({ slots: { base: "flex items-center justify-center h-auto w-max", count: "hover:-translate-x-0" }, variants: { isGrid: { true: "inline-grid grid-cols-4 gap-3" } } }); function m$(e) { var t, n, r = ""; if (typeof e == "string" || typeof e == "number") r += e; else if (typeof e == "object") if (Array.isArray(e)) for (t = 0; t < e.length; t++)e[t] && (n = m$(e[t])) && (r && (r += " "), r += n); else for (t in e) e[t] && (r && (r += " "), r += t); return r } function Z4() { for (var e, t, n = 0, r = ""; n < arguments.length;)(e = arguments[n++]) && (t = m$(e)) && (r && (r += " "), r += t); return r } const jy = "-", eD = e => { const t = nD(e), { conflictingClassGroups: n, conflictingClassGroupModifiers: r } = e; return { getClassGroupId: s => { const a = s.split(jy); return a[0] === "" && a.length !== 1 && a.shift(), g$(a, t) || tD(s) }, getConflictingClassGroupIds: (s, a) => { const l = n[s] || []; return a && r[s] ? [...l, ...r[s]] : l } } }, g$ = (e, t) => { var s; if (e.length === 0) return t.classGroupId; const n = e[0], r = t.nextPart.get(n), i = r ? g$(e.slice(1), r) : void 0; if (i) return i; if (t.validators.length === 0) return; const o = e.join(jy); return (s = t.validators.find(({ validator: a }) => a(o))) == null ? void 0 : s.classGroupId }, Px = /^\[(.+)\]$/, tD = e => { if (Px.test(e)) { const t = Px.exec(e)[1], n = t == null ? void 0 : t.substring(0, t.indexOf(":")); if (n) return "arbitrary.." + n } }, nD = e => { const { theme: t, prefix: n } = e, r = { nextPart: new Map, validators: [] }; return iD(Object.entries(e.classGroups), n).forEach(([o, s]) => { cg(s, r, o, t) }), r }, cg = (e, t, n, r) => { e.forEach(i => { if (typeof i == "string") { const o = i === "" ? t : $x(t, i); o.classGroupId = n; return } if (typeof i == "function") { if (rD(i)) { cg(i(r), t, n, r); return } t.validators.push({ validator: i, classGroupId: n }); return } Object.entries(i).forEach(([o, s]) => { cg(s, $x(t, o), n, r) }) }) }, $x = (e, t) => { let n = e; return t.split(jy).forEach(r => { n.nextPart.has(r) || n.nextPart.set(r, { nextPart: new Map, validators: [] }), n = n.nextPart.get(r) }), n }, rD = e => e.isThemeGetter, iD = (e, t) => t ? e.map(([n, r]) => { const i = r.map(o => typeof o == "string" ? t + o : typeof o == "object" ? Object.fromEntries(Object.entries(o).map(([s, a]) => [t + s, a])) : o); return [n, i] }) : e, oD = e => { if (e < 1) return { get: () => { }, set: () => { } }; let t = 0, n = new Map, r = new Map; const i = (o, s) => { n.set(o, s), t++, t > e && (t = 0, r = n, n = new Map) }; return { get(o) { let s = n.get(o); if (s !== void 0) return s; if ((s = r.get(o)) !== void 0) return i(o, s), s }, set(o, s) { n.has(o) ? n.set(o, s) : i(o, s) } } }, v$ = "!", sD = e => { const { separator: t, experimentalParseClassName: n } = e, r = t.length === 1, i = t[0], o = t.length, s = a => { const l = []; let u = 0, c = 0, d; for (let x = 0; x < a.length; x++) { let g = a[x]; if (u === 0) { if (g === i && (r || a.slice(x, x + o) === t)) { l.push(a.slice(c, x)), c = x + o; continue } if (g === "/") { d = x; continue } } g === "[" ? u++ : g === "]" && u-- } const f = l.length === 0 ? a : a.substring(c), p = f.startsWith(v$), m = p ? f.substring(1) : f, v = d && d > c ? d - c : void 0; return { modifiers: l, hasImportantModifier: p, baseClassName: m, maybePostfixModifierPosition: v } }; return n ? a => n({ className: a, parseClassName: s }) : s }, aD = e => { if (e.length <= 1) return e; const t = []; let n = []; return e.forEach(r => { r[0] === "[" ? (t.push(...n.sort(), r), n = []) : n.push(r) }), t.push(...n.sort()), t }, lD = e => ({ cache: oD(e.cacheSize), parseClassName: sD(e), ...eD(e) }), uD = /\s+/, cD = (e, t) => { const { parseClassName: n, getClassGroupId: r, getConflictingClassGroupIds: i } = t, o = [], s = e.trim().split(uD); let a = ""; for (let l = s.length - 1; l >= 0; l -= 1) { const u = s[l], { modifiers: c, hasImportantModifier: d, baseClassName: f, maybePostfixModifierPosition: p } = n(u); let m = !!p, v = r(m ? f.substring(0, p) : f); if (!v) { if (!m) { a = u + (a.length > 0 ? " " + a : a); continue } if (v = r(f), !v) { a = u + (a.length > 0 ? " " + a : a); continue } m = !1 } const x = aD(c).join(":"), g = d ? x + v$ : x, h = g + v; if (o.includes(h)) continue; o.push(h); const y = i(v, m); for (let E = 0; E < y.length; ++E) { const P = y[E]; o.push(g + P) } a = u + (a.length > 0 ? " " + a : a) } return a }; function dD() { let e = 0, t, n, r = ""; for (; e < arguments.length;)(t = arguments[e++]) && (n = y$(t)) && (r && (r += " "), r += n); return r } const y$ = e => { if (typeof e == "string") return e; let t, n = ""; for (let r = 0; r < e.length; r++)e[r] && (t = y$(e[r])) && (n && (n += " "), n += t); return n }; function Ax(e, ...t) { let n, r, i, o = s; function s(l) { const u = t.reduce((c, d) => d(c), e()); return n = lD(u), r = n.cache.get, i = n.cache.set, o = a, a(l) } function a(l) { const u = r(l); if (u) return u; const c = cD(l, n); return i(l, c), c } return function () { return o(dD.apply(null, arguments)) } } const He = e => { const t = n => n[e] || []; return t.isThemeGetter = !0, t }, b$ = /^\[(?:([a-z-]+):)?(.+)\]$/i, fD = /^\d+\/\d+$/, pD = new Set(["px", "full", "screen"]), hD = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, mD = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, gD = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, vD = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, yD = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Ir = e => Hs(e) || pD.has(e) || fD.test(e), hi = e => ma(e, "length", PD), Hs = e => !!e && !Number.isNaN(Number(e)), Xp = e => ma(e, "number", Hs), Da = e => !!e && Number.isInteger(Number(e)), bD = e => e.endsWith("%") && Hs(e.slice(0, -1)), we = e => b$.test(e), mi = e => hD.test(e), wD = new Set(["length", "size", "percentage"]), xD = e => ma(e, wD, w$), SD = e => ma(e, "position", w$), ED = new Set(["image", "url"]), TD = e => ma(e, ED, AD), CD = e => ma(e, "", $D), Fa = () => !0, ma = (e, t, n) => { const r = b$.exec(e); return r ? r[1] ? typeof t == "string" ? r[1] === t : t.has(r[1]) : n(r[2]) : !1 }, PD = e => mD.test(e) && !gD.test(e), w$ = () => !1, $D = e => vD.test(e), AD = e => yD.test(e), Mx = () => { const e = He("colors"), t = He("spacing"), n = He("blur"), r = He("brightness"), i = He("borderColor"), o = He("borderRadius"), s = He("borderSpacing"), a = He("borderWidth"), l = He("contrast"), u = He("grayscale"), c = He("hueRotate"), d = He("invert"), f = He("gap"), p = He("gradientColorStops"), m = He("gradientColorStopPositions"), v = He("inset"), x = He("margin"), g = He("opacity"), h = He("padding"), y = He("saturate"), E = He("scale"), P = He("sepia"), $ = He("skew"), L = He("space"), b = He("translate"), M = () => ["auto", "contain", "none"], R = () => ["auto", "hidden", "clip", "visible", "scroll"], A = () => ["auto", we, t], _ = () => [we, t], C = () => ["", Ir, hi], k = () => ["auto", Hs, we], O = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], U = () => ["solid", "dashed", "dotted", "double", "none"], z = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], D = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], V = () => ["", "0", we], H = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], T = () => [Hs, we]; return { cacheSize: 500, separator: ":", theme: { colors: [Fa], spacing: [Ir, hi], blur: ["none", "", mi, we], brightness: T(), borderColor: [e], borderRadius: ["none", "", "full", mi, we], borderSpacing: _(), borderWidth: C(), contrast: T(), grayscale: V(), hueRotate: T(), invert: V(), gap: _(), gradientColorStops: [e], gradientColorStopPositions: [bD, hi], inset: A(), margin: A(), opacity: T(), padding: _(), saturate: T(), scale: T(), sepia: V(), skew: T(), space: _(), translate: _() }, classGroups: { aspect: [{ aspect: ["auto", "square", "video", we] }], container: ["container"], columns: [{ columns: [mi] }], "break-after": [{ "break-after": H() }], "break-before": [{ "break-before": H() }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], float: [{ float: ["right", "left", "none", "start", "end"] }], clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: [...O(), we] }], overflow: [{ overflow: R() }], "overflow-x": [{ "overflow-x": R() }], "overflow-y": [{ "overflow-y": R() }], overscroll: [{ overscroll: M() }], "overscroll-x": [{ "overscroll-x": M() }], "overscroll-y": [{ "overscroll-y": M() }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: [v] }], "inset-x": [{ "inset-x": [v] }], "inset-y": [{ "inset-y": [v] }], start: [{ start: [v] }], end: [{ end: [v] }], top: [{ top: [v] }], right: [{ right: [v] }], bottom: [{ bottom: [v] }], left: [{ left: [v] }], visibility: ["visible", "invisible", "collapse"], z: [{ z: ["auto", Da, we] }], basis: [{ basis: A() }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["wrap", "wrap-reverse", "nowrap"] }], flex: [{ flex: ["1", "auto", "initial", "none", we] }], grow: [{ grow: V() }], shrink: [{ shrink: V() }], order: [{ order: ["first", "last", "none", Da, we] }], "grid-cols": [{ "grid-cols": [Fa] }], "col-start-end": [{ col: ["auto", { span: ["full", Da, we] }, we] }], "col-start": [{ "col-start": k() }], "col-end": [{ "col-end": k() }], "grid-rows": [{ "grid-rows": [Fa] }], "row-start-end": [{ row: ["auto", { span: [Da, we] }, we] }], "row-start": [{ "row-start": k() }], "row-end": [{ "row-end": k() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": ["auto", "min", "max", "fr", we] }], "auto-rows": [{ "auto-rows": ["auto", "min", "max", "fr", we] }], gap: [{ gap: [f] }], "gap-x": [{ "gap-x": [f] }], "gap-y": [{ "gap-y": [f] }], "justify-content": [{ justify: ["normal", ...D()] }], "justify-items": [{ "justify-items": ["start", "end", "center", "stretch"] }], "justify-self": [{ "justify-self": ["auto", "start", "end", "center", "stretch"] }], "align-content": [{ content: ["normal", ...D(), "baseline"] }], "align-items": [{ items: ["start", "end", "center", "baseline", "stretch"] }], "align-self": [{ self: ["auto", "start", "end", "center", "stretch", "baseline"] }], "place-content": [{ "place-content": [...D(), "baseline"] }], "place-items": [{ "place-items": ["start", "end", "center", "baseline", "stretch"] }], "place-self": [{ "place-self": ["auto", "start", "end", "center", "stretch"] }], p: [{ p: [h] }], px: [{ px: [h] }], py: [{ py: [h] }], ps: [{ ps: [h] }], pe: [{ pe: [h] }], pt: [{ pt: [h] }], pr: [{ pr: [h] }], pb: [{ pb: [h] }], pl: [{ pl: [h] }], m: [{ m: [x] }], mx: [{ mx: [x] }], my: [{ my: [x] }], ms: [{ ms: [x] }], me: [{ me: [x] }], mt: [{ mt: [x] }], mr: [{ mr: [x] }], mb: [{ mb: [x] }], ml: [{ ml: [x] }], "space-x": [{ "space-x": [L] }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": [L] }], "space-y-reverse": ["space-y-reverse"], w: [{ w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", we, t] }], "min-w": [{ "min-w": [we, t, "min", "max", "fit"] }], "max-w": [{ "max-w": [we, t, "none", "full", "min", "max", "fit", "prose", { screen: [mi] }, mi] }], h: [{ h: [we, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"] }], "min-h": [{ "min-h": [we, t, "min", "max", "fit", "svh", "lvh", "dvh"] }], "max-h": [{ "max-h": [we, t, "min", "max", "fit", "svh", "lvh", "dvh"] }], size: [{ size: [we, t, "auto", "min", "max", "fit"] }], "font-size": [{ text: ["base", mi, hi] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Xp] }], "font-family": [{ font: [Fa] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractions"], tracking: [{ tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", we] }], "line-clamp": [{ "line-clamp": ["none", Hs, Xp] }], leading: [{ leading: ["none", "tight", "snug", "normal", "relaxed", "loose", Ir, we] }], "list-image": [{ "list-image": ["none", we] }], "list-style-type": [{ list: ["none", "disc", "decimal", we] }], "list-style-position": [{ list: ["inside", "outside"] }], "placeholder-color": [{ placeholder: [e] }], "placeholder-opacity": [{ "placeholder-opacity": [g] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "text-color": [{ text: [e] }], "text-opacity": [{ "text-opacity": [g] }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: [...U(), "wavy"] }], "text-decoration-thickness": [{ decoration: ["auto", "from-font", Ir, hi] }], "underline-offset": [{ "underline-offset": ["auto", Ir, we] }], "text-decoration-color": [{ decoration: [e] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }], indent: [{ indent: _() }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", we] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", we] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-opacity": [{ "bg-opacity": [g] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: [...O(), SD] }], "bg-repeat": [{ bg: ["no-repeat", { repeat: ["", "x", "y", "round", "space"] }] }], "bg-size": [{ bg: ["auto", "cover", "contain", xD] }], "bg-image": [{ bg: ["none", { "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, TD] }], "bg-color": [{ bg: [e] }], "gradient-from-pos": [{ from: [m] }], "gradient-via-pos": [{ via: [m] }], "gradient-to-pos": [{ to: [m] }], "gradient-from": [{ from: [p] }], "gradient-via": [{ via: [p] }], "gradient-to": [{ to: [p] }], rounded: [{ rounded: [o] }], "rounded-s": [{ "rounded-s": [o] }], "rounded-e": [{ "rounded-e": [o] }], "rounded-t": [{ "rounded-t": [o] }], "rounded-r": [{ "rounded-r": [o] }], "rounded-b": [{ "rounded-b": [o] }], "rounded-l": [{ "rounded-l": [o] }], "rounded-ss": [{ "rounded-ss": [o] }], "rounded-se": [{ "rounded-se": [o] }], "rounded-ee": [{ "rounded-ee": [o] }], "rounded-es": [{ "rounded-es": [o] }], "rounded-tl": [{ "rounded-tl": [o] }], "rounded-tr": [{ "rounded-tr": [o] }], "rounded-br": [{ "rounded-br": [o] }], "rounded-bl": [{ "rounded-bl": [o] }], "border-w": [{ border: [a] }], "border-w-x": [{ "border-x": [a] }], "border-w-y": [{ "border-y": [a] }], "border-w-s": [{ "border-s": [a] }], "border-w-e": [{ "border-e": [a] }], "border-w-t": [{ "border-t": [a] }], "border-w-r": [{ "border-r": [a] }], "border-w-b": [{ "border-b": [a] }], "border-w-l": [{ "border-l": [a] }], "border-opacity": [{ "border-opacity": [g] }], "border-style": [{ border: [...U(), "hidden"] }], "divide-x": [{ "divide-x": [a] }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": [a] }], "divide-y-reverse": ["divide-y-reverse"], "divide-opacity": [{ "divide-opacity": [g] }], "divide-style": [{ divide: U() }], "border-color": [{ border: [i] }], "border-color-x": [{ "border-x": [i] }], "border-color-y": [{ "border-y": [i] }], "border-color-s": [{ "border-s": [i] }], "border-color-e": [{ "border-e": [i] }], "border-color-t": [{ "border-t": [i] }], "border-color-r": [{ "border-r": [i] }], "border-color-b": [{ "border-b": [i] }], "border-color-l": [{ "border-l": [i] }], "divide-color": [{ divide: [i] }], "outline-style": [{ outline: ["", ...U()] }], "outline-offset": [{ "outline-offset": [Ir, we] }], "outline-w": [{ outline: [Ir, hi] }], "outline-color": [{ outline: [e] }], "ring-w": [{ ring: C() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: [e] }], "ring-opacity": [{ "ring-opacity": [g] }], "ring-offset-w": [{ "ring-offset": [Ir, hi] }], "ring-offset-color": [{ "ring-offset": [e] }], shadow: [{ shadow: ["", "inner", "none", mi, CD] }], "shadow-color": [{ shadow: [Fa] }], opacity: [{ opacity: [g] }], "mix-blend": [{ "mix-blend": [...z(), "plus-lighter", "plus-darker"] }], "bg-blend": [{ "bg-blend": z() }], filter: [{ filter: ["", "none"] }], blur: [{ blur: [n] }], brightness: [{ brightness: [r] }], contrast: [{ contrast: [l] }], "drop-shadow": [{ "drop-shadow": ["", "none", mi, we] }], grayscale: [{ grayscale: [u] }], "hue-rotate": [{ "hue-rotate": [c] }], invert: [{ invert: [d] }], saturate: [{ saturate: [y] }], sepia: [{ sepia: [P] }], "backdrop-filter": [{ "backdrop-filter": ["", "none"] }], "backdrop-blur": [{ "backdrop-blur": [n] }], "backdrop-brightness": [{ "backdrop-brightness": [r] }], "backdrop-contrast": [{ "backdrop-contrast": [l] }], "backdrop-grayscale": [{ "backdrop-grayscale": [u] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [c] }], "backdrop-invert": [{ "backdrop-invert": [d] }], "backdrop-opacity": [{ "backdrop-opacity": [g] }], "backdrop-saturate": [{ "backdrop-saturate": [y] }], "backdrop-sepia": [{ "backdrop-sepia": [P] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": [s] }], "border-spacing-x": [{ "border-spacing-x": [s] }], "border-spacing-y": [{ "border-spacing-y": [s] }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", we] }], duration: [{ duration: T() }], ease: [{ ease: ["linear", "in", "out", "in-out", we] }], delay: [{ delay: T() }], animate: [{ animate: ["none", "spin", "ping", "pulse", "bounce", we] }], transform: [{ transform: ["", "gpu", "none"] }], scale: [{ scale: [E] }], "scale-x": [{ "scale-x": [E] }], "scale-y": [{ "scale-y": [E] }], rotate: [{ rotate: [Da, we] }], "translate-x": [{ "translate-x": [b] }], "translate-y": [{ "translate-y": [b] }], "skew-x": [{ "skew-x": [$] }], "skew-y": [{ "skew-y": [$] }], "transform-origin": [{ origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", we] }], accent: [{ accent: ["auto", e] }], appearance: [{ appearance: ["none", "auto"] }], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", we] }], "caret-color": [{ caret: [e] }], "pointer-events": [{ "pointer-events": ["none", "auto"] }], resize: [{ resize: ["none", "y", "x", ""] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": _() }], "scroll-mx": [{ "scroll-mx": _() }], "scroll-my": [{ "scroll-my": _() }], "scroll-ms": [{ "scroll-ms": _() }], "scroll-me": [{ "scroll-me": _() }], "scroll-mt": [{ "scroll-mt": _() }], "scroll-mr": [{ "scroll-mr": _() }], "scroll-mb": [{ "scroll-mb": _() }], "scroll-ml": [{ "scroll-ml": _() }], "scroll-p": [{ "scroll-p": _() }], "scroll-px": [{ "scroll-px": _() }], "scroll-py": [{ "scroll-py": _() }], "scroll-ps": [{ "scroll-ps": _() }], "scroll-pe": [{ "scroll-pe": _() }], "scroll-pt": [{ "scroll-pt": _() }], "scroll-pr": [{ "scroll-pr": _() }], "scroll-pb": [{ "scroll-pb": _() }], "scroll-pl": [{ "scroll-pl": _() }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "manipulation"] }], "touch-x": [{ "touch-pan": ["x", "left", "right"] }], "touch-y": [{ "touch-pan": ["y", "up", "down"] }], "touch-pz": ["touch-pinch-zoom"], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", we] }], fill: [{ fill: [e, "none"] }], "stroke-w": [{ stroke: [Ir, hi, Xp] }], stroke: [{ stroke: [e, "none"] }], sr: ["sr-only", "not-sr-only"], "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], size: ["w", "h"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], "line-clamp": ["display", "overflow"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"], touch: ["touch-x", "touch-y", "touch-pz"], "touch-x": ["touch"], "touch-y": ["touch"], "touch-pz": ["touch"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] } } }, MD = (e, { cacheSize: t, prefix: n, separator: r, experimentalParseClassName: i, extend: o = {}, override: s = {} }) => { sl(e, "cacheSize", t), sl(e, "prefix", n), sl(e, "separator", r), sl(e, "experimentalParseClassName", i); for (const a in s) kD(e[a], s[a]); for (const a in o) _D(e[a], o[a]); return e }, sl = (e, t, n) => { n !== void 0 && (e[t] = n) }, kD = (e, t) => { if (t) for (const n in t) sl(e, n, t[n]) }, _D = (e, t) => { if (t) for (const n in t) { const r = t[n]; r !== void 0 && (e[n] = (e[n] || []).concat(r)) } }, RD = (e, ...t) => typeof e == "function" ? Ax(Mx, e, ...t) : Ax(() => MD(Mx(), e), ...t); var LD = RD({ extend: ig }); function Jp(...e) { return LD(Z4(e)) } const ND = "modulepreload", OD = function (e) { return "/" + e }, kx = {}, ga = function (t, n, r) { let i = Promise.resolve(); if (n && n.length > 0) { document.getElementsByTagName("link"); const s = document.querySelector("meta[property=csp-nonce]"), a = (s == null ? void 0 : s.nonce) || (s == null ? void 0 : s.getAttribute("nonce")); i = Promise.allSettled(n.map(l => { if (l = OD(l), l in kx) return; kx[l] = !0; const u = l.endsWith(".css"), c = u ? '[rel="stylesheet"]' : ""; if (document.querySelector(`link[href="${l}"]${c}`)) return; const d = document.createElement("link"); if (d.rel = u ? "stylesheet" : ND, u || (d.as = "script"), d.crossOrigin = "", d.href = l, a && d.setAttribute("nonce", a), document.head.appendChild(d), u) return new Promise((f, p) => { d.addEventListener("load", f), d.addEventListener("error", () => p(new Error(`Unable to preload CSS for ${l}`))) }) })) } function o(s) { const a = new Event("vite:preloadError", { cancelable: !0 }); if (a.payload = s, window.dispatchEvent(a), !a.defaultPrevented) throw s } return i.then(s => { for (const a of s || []) a.status === "rejected" && o(a.reason); return t().catch(o) }) }; function jD(e, t) { let { elementType: n = "button", isDisabled: r, onPress: i, onPressStart: o, onPressEnd: s, onPressUp: a, onPressChange: l, preventFocusOnPress: u, allowFocusWhenDisabled: c, onClick: d, href: f, target: p, rel: m, type: v = "button" } = e, x; n === "button" ? x = { type: v, disabled: r } : x = { role: "button", tabIndex: r ? void 0 : 0, href: n === "a" && !r ? f : void 0, target: n === "a" ? p : void 0, type: n === "input" ? v : void 0, disabled: n === "input" ? r : void 0, "aria-disabled": !r || n === "input" ? void 0 : r, rel: n === "a" ? m : void 0 }; let { pressProps: g, isPressed: h } = Pu({ onPressStart: o, onPressEnd: s, onPressChange: l, onPress: i, onPressUp: a, isDisabled: r, preventFocusOnPress: u, ref: t }), { focusableProps: y } = Jv(e, t); c && (y.tabIndex = r ? -1 : y.tabIndex); let E = tt(y, g, Hv(e, { labelable: !0 })); return { isPressed: h, buttonProps: tt(x, E, { "aria-haspopup": e["aria-haspopup"], "aria-expanded": e["aria-expanded"], "aria-controls": e["aria-controls"], "aria-pressed": e["aria-pressed"], onClick: P => { d && (d(P), console.warn("onClick is deprecated, please use onPress")) } }) } } function ID(e, t, n) { const { isSelected: r } = t, { isPressed: i, buttonProps: o } = jD({ ...e, onPress: ni(t.toggle, e.onPress) }, n); return { isPressed: i, isSelected: r, isDisabled: e.isDisabled || !1, buttonProps: tt(o, { "aria-pressed": r }) } } var _x = e => w.jsxs("svg", { "aria-hidden": "true", fill: "none", focusable: "false", height: "1em", role: "presentation", shapeRendering: "geometricPrecision", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "1.5", viewBox: "0 0 24 24", width: "1em", ...e, children: [w.jsx("path", { d: "M13 17l5-5-5-5" }), w.jsx("path", { d: "M6 17l5-5-5-5" })] }), bc = e => w.jsx("svg", { "aria-hidden": "true", fill: "none", focusable: "false", height: "1em", role: "presentation", viewBox: "0 0 24 24", width: "1em", ...e, children: w.jsx("path", { d: "M15.5 19l-7-7 7-7", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "1.5" }) }), Iy = e => w.jsx("svg", { "aria-hidden": "true", focusable: "false", height: "1em", role: "presentation", viewBox: "0 0 24 24", width: "1em", ...e, children: w.jsx("path", { d: "M12 2a10 10 0 1010 10A10.016 10.016 0 0012 2zm3.36 12.3a.754.754 0 010 1.06.748.748 0 01-1.06 0l-2.3-2.3-2.3 2.3a.748.748 0 01-1.06 0 .754.754 0 010-1.06l2.3-2.3-2.3-2.3A.75.75 0 019.7 8.64l2.3 2.3 2.3-2.3a.75.75 0 011.06 1.06l-2.3 2.3z", fill: "currentColor" }) }), Rx = e => w.jsxs("svg", { "aria-hidden": "true", fill: "none", height: "1em", shapeRendering: "geometricPrecision", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "1.5", viewBox: "0 0 24 24", width: "1em", ...e, children: [w.jsx("circle", { cx: "12", cy: "12", fill: "currentColor", r: "1" }), w.jsx("circle", { cx: "19", cy: "12", fill: "currentColor", r: "1" }), w.jsx("circle", { cx: "5", cy: "12", fill: "currentColor", r: "1" })] }), Lx = { ease: [.36, .66, .4, 1], easeIn: [.4, 0, 1, 1], easeOut: [0, 0, .2, 1], easeInOut: [.4, 0, .2, 1], spring: [.155, 1.105, .295, 1.12], springOut: [.57, -.15, .62, .07], softSpring: [.16, 1.11, .3, 1.02] }, DD = () => w.jsxs("svg", { "aria-hidden": "true", fill: "none", height: "80%", role: "presentation", viewBox: "0 0 24 24", width: "80%", children: [w.jsx("path", { d: "M12 2C9.38 2 7.25 4.13 7.25 6.75C7.25 9.32 9.26 11.4 11.88 11.49C11.96 11.48 12.04 11.48 12.1 11.49C12.12 11.49 12.13 11.49 12.15 11.49C12.16 11.49 12.16 11.49 12.17 11.49C14.73 11.4 16.74 9.32 16.75 6.75C16.75 4.13 14.62 2 12 2Z", fill: "currentColor" }), w.jsx("path", { d: "M17.0809 14.1489C14.2909 12.2889 9.74094 12.2889 6.93094 14.1489C5.66094 14.9989 4.96094 16.1489 4.96094 17.3789C4.96094 18.6089 5.66094 19.7489 6.92094 20.5889C8.32094 21.5289 10.1609 21.9989 12.0009 21.9989C13.8409 21.9989 15.6809 21.5289 17.0809 20.5889C18.3409 19.7389 19.0409 18.5989 19.0409 17.3589C19.0309 16.1289 18.3409 14.9889 17.0809 14.1489Z", fill: "currentColor" })] }), [iW, FD] = Cu({ name: "AvatarGroupContext", strict: !1 }), x$ = globalThis != null && globalThis.document ? S.useLayoutEffect : S.useEffect; function zD(e = {}) { const { loading: t, src: n, srcSet: r, onLoad: i, onError: o, crossOrigin: s, sizes: a, ignoreFallback: l } = e, [u, c] = S.useState("pending"); S.useEffect(() => { c(n ? "loading" : "pending") }, [n]); const d = S.useRef(), f = S.useCallback(() => { if (!n) return; p(); const m = new Image; m.src = n, s && (m.crossOrigin = s), r && (m.srcset = r), a && (m.sizes = a), t && (m.loading = t), m.onload = v => { p(), c("loaded"), i == null || i(v) }, m.onerror = v => { p(), c("failed"), o == null || o(v) }, d.current = m }, [n, s, r, a, i, o, t]), p = () => { d.current && (d.current.onload = null, d.current.onerror = null, d.current = null) }; return x$(() => { if (!l) return u === "loading" && f(), () => { p() } }, [u, f, l]), l ? "loaded" : u } function VD(e = {}) { var t, n, r, i, o, s; const a = Yo(), l = FD(), u = !!l, { as: c, ref: d, src: f, name: p, icon: m, classNames: v, fallback: x, alt: g = p || "avatar", imgRef: h, color: y = (t = l == null ? void 0 : l.color) != null ? t : "default", radius: E = (n = l == null ? void 0 : l.radius) != null ? n : "full", size: P = (r = l == null ? void 0 : l.size) != null ? r : "md", isBordered: $ = (i = l == null ? void 0 : l.isBordered) != null ? i : !1, isDisabled: L = (o = l == null ? void 0 : l.isDisabled) != null ? o : !1, isFocusable: b = !1, getInitials: M = SR, ignoreFallback: R = !1, showFallback: A = !1, ImgComponent: _ = "img", imgProps: C, className: k, onError: O, disableAnimation: U, ...z } = e, D = c || "span", V = ht(d), H = ht(h), { isFocusVisible: T, isFocused: N, focusProps: W } = ri(), { isHovered: Q, hoverProps: q } = Bo({ isDisabled: L }), te = (s = U ?? (a == null ? void 0 : a.disableAnimation)) != null ? s : !1, le = zD({ src: f, onError: O, ignoreFallback: R }) === "loaded", oe = typeof _ == "string", ge = (!f || !le) && A, Pe = S.useMemo(() => { var lt; return J4({ color: y, radius: E, size: P, isBordered: $, isDisabled: L, isInGroup: u, disableAnimation: te, isInGridGroup: (lt = l == null ? void 0 : l.isGrid) != null ? lt : !1 }) }, [y, E, P, $, L, te, u, l == null ? void 0 : l.isGrid]), Oe = ke(v == null ? void 0 : v.base, k), gt = S.useMemo(() => b || c === "button", [b, c]), Je = S.useCallback((lt = {}) => ({ ref: V, tabIndex: gt ? 0 : -1, "data-hover": fe(Q), "data-focus": fe(N), "data-focus-visible": fe(T), className: Pe.base({ class: ke(Oe, lt == null ? void 0 : lt.className) }), ...tt(z, q, gt ? W : {}) }), [gt, Pe, Oe, W, z]), it = S.useCallback((lt = {}) => ({ ref: H, src: f, "data-loaded": fe(le), className: Pe.img({ class: v == null ? void 0 : v.img }), ...tt(C, lt, Ki({ disableAnimation: te }, { enabled: oe })) }), [Pe, le, C, te, f, H, oe]); return { Component: D, ImgComponent: _, src: f, alt: g, icon: m, name: p, imgRef: H, slots: Pe, classNames: v, fallback: x, isImgLoaded: le, showFallback: ge, ignoreFallback: R, getInitials: M, getAvatarProps: Je, getImageProps: it } } var S$ = _t((e, t) => { const { Component: n, ImgComponent: r, src: i, icon: o = w.jsx(DD, {}), alt: s, classNames: a, slots: l, name: u, showFallback: c, fallback: d, getInitials: f, getAvatarProps: p, getImageProps: m } = VD({ ...e, ref: t }), v = S.useMemo(() => !c && i ? null : d ? w.jsx("div", { "aria-label": s, className: l.fallback({ class: a == null ? void 0 : a.fallback }), role: "img", children: d }) : u ? w.jsx("span", { "aria-label": s, className: l.name({ class: a == null ? void 0 : a.name }), role: "img", children: f(u) }) : w.jsx("span", { "aria-label": s, className: l.icon({ class: a == null ? void 0 : a.icon }), role: "img", children: o }), [c, i, d, u, a]); return w.jsxs(n, { ...p(), children: [i && w.jsx(r, { ...m(), alt: s }), v] }) }); S$.displayName = "NextUI.Avatar"; var BD = S$, [oW, UD] = Cu({ name: "ButtonGroupContext", strict: !1 }); function E$(e, t) { let { elementType: n = "button", isDisabled: r, onPress: i, onPressStart: o, onPressEnd: s, onPressChange: a, preventFocusOnPress: l, allowFocusWhenDisabled: u, onClick: c, href: d, target: f, rel: p, type: m = "button", allowTextSelectionOnPress: v } = e, x; n === "button" ? x = { type: m, disabled: r } : x = { role: "button", tabIndex: r ? void 0 : 0, href: n === "a" && !r ? d : void 0, target: n === "a" ? f : void 0, type: n === "input" ? m : void 0, disabled: n === "input" ? r : void 0, "aria-disabled": !r || n === "input" ? void 0 : r, rel: n === "a" ? p : void 0 }; let g = tC() || bL(); c && typeof c == "function" && TR("onClick is deprecated, please use onPress instead. See: https://github.com/nextui-org/nextui/issues/4292", "useButton"); const h = L => { g && (c == null || c(L)), i == null || i(L) }; let { pressProps: y, isPressed: E } = Pu({ onPressStart: o, onPressEnd: s, onPressChange: a, onPress: h, isDisabled: r, preventFocusOnPress: l, allowTextSelectionOnPress: v, ref: t }), { focusableProps: P } = Jv(e, t); u && (P.tabIndex = r ? -1 : P.tabIndex); let $ = tt(P, y, Hv(e, { labelable: !0 })); return { isPressed: E, buttonProps: tt(x, $, { "aria-haspopup": e["aria-haspopup"], "aria-expanded": e["aria-expanded"], "aria-controls": e["aria-controls"], "aria-pressed": e["aria-pressed"], onClick: L => { m === "button" && g || c == null || c(L) } }) } } var HD = () => ga(() => import("./index-XqZGe4bn.js"), []).then(e => e.default), T$ = e => { const { ripples: t = [], motionProps: n, color: r = "currentColor", style: i, onClear: o } = e; return w.jsx(w.Fragment, { children: t.map(s => { const a = NR(.01 * s.size, .2, s.size > 100 ? .75 : .5); return w.jsx(Ny, { features: HD, children: w.jsx(r$, { mode: "popLayout", children: w.jsx(Ly.span, { animate: { transform: "scale(2)", opacity: 0 }, className: "nextui-ripple", exit: { opacity: 0 }, initial: { transform: "scale(0)", opacity: .35 }, style: { position: "absolute", backgroundColor: r, borderRadius: "100%", transformOrigin: "center", pointerEvents: "none", overflow: "hidden", inset: 0, zIndex: 0, top: s.y, left: s.x, width: `${s.size}px`, height: `${s.size}px`, ...i }, transition: { duration: a }, onAnimationComplete: () => { o(s.key) }, ...n }) }) }, s.key) }) }) }; T$.displayName = "NextUI.Ripple"; var C$ = T$; function P$(e = {}) { const [t, n] = S.useState([]), r = S.useCallback(o => { const s = o.target, a = Math.max(s.clientWidth, s.clientHeight); n(l => [...l, { key: LR(l.length.toString()), size: a, x: o.x - a / 2, y: o.y - a / 2 }]) }, []), i = S.useCallback(o => { n(s => s.filter(a => a.key !== o)) }, []); return { ripples: t, onClear: i, onPress: r, ...e } } function WD(e) { var t, n, r, i, o, s, a, l, u; const c = UD(), d = Yo(), f = !!c, { ref: p, as: m, children: v, startContent: x, endContent: g, autoFocus: h, className: y, spinner: E, isLoading: P = !1, disableRipple: $ = !1, fullWidth: L = (t = c == null ? void 0 : c.fullWidth) != null ? t : !1, radius: b = c == null ? void 0 : c.radius, size: M = (n = c == null ? void 0 : c.size) != null ? n : "md", color: R = (r = c == null ? void 0 : c.color) != null ? r : "default", variant: A = (i = c == null ? void 0 : c.variant) != null ? i : "solid", disableAnimation: _ = (s = (o = c == null ? void 0 : c.disableAnimation) != null ? o : d == null ? void 0 : d.disableAnimation) != null ? s : !1, isDisabled: C = (a = c == null ? void 0 : c.isDisabled) != null ? a : !1, isIconOnly: k = (l = c == null ? void 0 : c.isIconOnly) != null ? l : !1, spinnerPlacement: O = "start", onPress: U, onClick: z, ...D } = e, V = m || "button", H = typeof V == "string", T = ht(p), N = (u = $ || (d == null ? void 0 : d.disableRipple)) != null ? u : _, { isFocusVisible: W, isFocused: Q, focusProps: q } = ri({ autoFocus: h }), te = C || P, ae = S.useMemo(() => X4({ size: M, color: R, variant: A, radius: b, fullWidth: L, isDisabled: te, isInGroup: f, disableAnimation: _, isIconOnly: k, className: y }), [M, R, A, b, L, te, f, k, _, y]), { onPress: le, onClear: oe, ripples: ge } = P$(), Pe = S.useCallback(jt => { N || te || _ || T.current && le(jt) }, [N, te, _, T, le]), { buttonProps: Oe, isPressed: gt } = E$({ elementType: m, isDisabled: te, onPress: ni(U, Pe), onClick: z, ...D }, T), { isHovered: Je, hoverProps: it } = Bo({ isDisabled: te }), lt = S.useCallback((jt = {}) => ({ "data-disabled": fe(te), "data-focus": fe(Q), "data-pressed": fe(gt), "data-focus-visible": fe(W), "data-hover": fe(Je), "data-loading": fe(P), ...tt(Oe, q, it, Ki(D, { enabled: H }), Ki(jt)) }), [P, te, Q, gt, H, W, Je, Oe, q, it, D]), Jt = jt => S.isValidElement(jt) ? S.cloneElement(jt, { "aria-hidden": !0, focusable: !1, tabIndex: -1 }) : null, Zt = Jt(x), ye = Jt(g), Ht = S.useMemo(() => ({ sm: "sm", md: "sm", lg: "md" })[M], [M]), en = S.useCallback(() => ({ ripples: ge, onClear: oe }), [ge, oe]); return { Component: V, children: v, domRef: T, spinner: E, styles: ae, startContent: Zt, endContent: ye, isLoading: P, spinnerPlacement: O, spinnerSize: Ht, disableRipple: N, getButtonProps: lt, getRippleProps: en, isIconOnly: k } } function GD(e) { return S.forwardRef(e) } var KD = (e, t, n = !0) => { if (!t) return [e, {}]; const r = t.reduce((i, o) => o in e ? { ...i, [o]: e[o] } : i, {}); return n ? [Object.keys(e).filter(o => !t.includes(o)).reduce((o, s) => ({ ...o, [s]: e[s] }), {}), r] : [e, r] }; function $$(e) { var t, n, r = ""; if (typeof e == "string" || typeof e == "number") r += e; else if (typeof e == "object") if (Array.isArray(e)) for (t = 0; t < e.length; t++)e[t] && (n = $$(e[t])) && (r && (r += " "), r += n); else for (t in e) e[t] && (r && (r += " "), r += t); return r } function qD(...e) { for (var t = 0, n, r, i = ""; t < e.length;)(n = e[t++]) && (r = $$(n)) && (i && (i += " "), i += r); return i } var YD = Object.create, A$ = Object.defineProperty, QD = Object.getOwnPropertyDescriptor, M$ = Object.getOwnPropertyNames, XD = Object.getPrototypeOf, JD = Object.prototype.hasOwnProperty, k$ = (e, t) => function () { return t || (0, e[M$(e)[0]])((t = { exports: {} }).exports, t), t.exports }, ZD = (e, t, n, r) => { if (t && typeof t == "object" || typeof t == "function") for (let i of M$(t)) !JD.call(e, i) && i !== n && A$(e, i, { get: () => t[i], enumerable: !(r = QD(t, i)) || r.enumerable }); return e }, e5 = (e, t, n) => (n = e != null ? YD(XD(e)) : {}, ZD(!e || !e.__esModule ? A$(n, "default", { value: e, enumerable: !0 }) : n, e)), t5 = k$({ "../../../node_modules/.pnpm/react@18.2.0/node_modules/react/cjs/react.production.min.js"(e) { var t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), f = Symbol.iterator; function p(T) { return T === null || typeof T != "object" ? null : (T = f && T[f] || T["@@iterator"], typeof T == "function" ? T : null) } var m = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, v = Object.assign, x = {}; function g(T, N, W) { this.props = T, this.context = N, this.refs = x, this.updater = W || m } g.prototype.isReactComponent = {}, g.prototype.setState = function (T, N) { if (typeof T != "object" && typeof T != "function" && T != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, T, N, "setState") }, g.prototype.forceUpdate = function (T) { this.updater.enqueueForceUpdate(this, T, "forceUpdate") }; function h() { } h.prototype = g.prototype; function y(T, N, W) { this.props = T, this.context = N, this.refs = x, this.updater = W || m } var E = y.prototype = new h; E.constructor = y, v(E, g.prototype), E.isPureReactComponent = !0; var P = Array.isArray, $ = Object.prototype.hasOwnProperty, L = { current: null }, b = { key: !0, ref: !0, __self: !0, __source: !0 }; function M(T, N, W) { var Q, q = {}, te = null, ae = null; if (N != null) for (Q in N.ref !== void 0 && (ae = N.ref), N.key !== void 0 && (te = "" + N.key), N) $.call(N, Q) && !b.hasOwnProperty(Q) && (q[Q] = N[Q]); var le = arguments.length - 2; if (le === 1) q.children = W; else if (1 < le) { for (var oe = Array(le), ge = 0; ge < le; ge++)oe[ge] = arguments[ge + 2]; q.children = oe } if (T && T.defaultProps) for (Q in le = T.defaultProps, le) q[Q] === void 0 && (q[Q] = le[Q]); return { $$typeof: t, type: T, key: te, ref: ae, props: q, _owner: L.current } } function R(T, N) { return { $$typeof: t, type: T.type, key: N, ref: T.ref, props: T.props, _owner: T._owner } } function A(T) { return typeof T == "object" && T !== null && T.$$typeof === t } function _(T) { var N = { "=": "=0", ":": "=2" }; return "$" + T.replace(/[=:]/g, function (W) { return N[W] }) } var C = /\/+/g; function k(T, N) { return typeof T == "object" && T !== null && T.key != null ? _("" + T.key) : N.toString(36) } function O(T, N, W, Q, q) { var te = typeof T; (te === "undefined" || te === "boolean") && (T = null); var ae = !1; if (T === null) ae = !0; else switch (te) { case "string": case "number": ae = !0; break; case "object": switch (T.$$typeof) { case t: case n: ae = !0 } }if (ae) return ae = T, q = q(ae), T = Q === "" ? "." + k(ae, 0) : Q, P(q) ? (W = "", T != null && (W = T.replace(C, "$&/") + "/"), O(q, N, W, "", function (ge) { return ge })) : q != null && (A(q) && (q = R(q, W + (!q.key || ae && ae.key === q.key ? "" : ("" + q.key).replace(C, "$&/") + "/") + T)), N.push(q)), 1; if (ae = 0, Q = Q === "" ? "." : Q + ":", P(T)) for (var le = 0; le < T.length; le++) { te = T[le]; var oe = Q + k(te, le); ae += O(te, N, W, oe, q) } else if (oe = p(T), typeof oe == "function") for (T = oe.call(T), le = 0; !(te = T.next()).done;)te = te.value, oe = Q + k(te, le++), ae += O(te, N, W, oe, q); else if (te === "object") throw N = String(T), Error("Objects are not valid as a React child (found: " + (N === "[object Object]" ? "object with keys {" + Object.keys(T).join(", ") + "}" : N) + "). If you meant to render a collection of children, use an array instead."); return ae } function U(T, N, W) { if (T == null) return T; var Q = [], q = 0; return O(T, Q, "", "", function (te) { return N.call(W, te, q++) }), Q } function z(T) { if (T._status === -1) { var N = T._result; N = N(), N.then(function (W) { (T._status === 0 || T._status === -1) && (T._status = 1, T._result = W) }, function (W) { (T._status === 0 || T._status === -1) && (T._status = 2, T._result = W) }), T._status === -1 && (T._status = 0, T._result = N) } if (T._status === 1) return T._result.default; throw T._result } var D = { current: null }, V = { transition: null }, H = { ReactCurrentDispatcher: D, ReactCurrentBatchConfig: V, ReactCurrentOwner: L }; e.Children = { map: U, forEach: function (T, N, W) { U(T, function () { N.apply(this, arguments) }, W) }, count: function (T) { var N = 0; return U(T, function () { N++ }), N }, toArray: function (T) { return U(T, function (N) { return N }) || [] }, only: function (T) { if (!A(T)) throw Error("React.Children.only expected to receive a single React element child."); return T } }, e.Component = g, e.Fragment = r, e.Profiler = o, e.PureComponent = y, e.StrictMode = i, e.Suspense = u, e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = H, e.cloneElement = function (T, N, W) { if (T == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + T + "."); var Q = v({}, T.props), q = T.key, te = T.ref, ae = T._owner; if (N != null) { if (N.ref !== void 0 && (te = N.ref, ae = L.current), N.key !== void 0 && (q = "" + N.key), T.type && T.type.defaultProps) var le = T.type.defaultProps; for (oe in N) $.call(N, oe) && !b.hasOwnProperty(oe) && (Q[oe] = N[oe] === void 0 && le !== void 0 ? le[oe] : N[oe]) } var oe = arguments.length - 2; if (oe === 1) Q.children = W; else if (1 < oe) { le = Array(oe); for (var ge = 0; ge < oe; ge++)le[ge] = arguments[ge + 2]; Q.children = le } return { $$typeof: t, type: T.type, key: q, ref: te, props: Q, _owner: ae } }, e.createContext = function (T) { return T = { $$typeof: a, _currentValue: T, _currentValue2: T, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, T.Provider = { $$typeof: s, _context: T }, T.Consumer = T }, e.createElement = M, e.createFactory = function (T) { var N = M.bind(null, T); return N.type = T, N }, e.createRef = function () { return { current: null } }, e.forwardRef = function (T) { return { $$typeof: l, render: T } }, e.isValidElement = A, e.lazy = function (T) { return { $$typeof: d, _payload: { _status: -1, _result: T }, _init: z } }, e.memo = function (T, N) { return { $$typeof: c, type: T, compare: N === void 0 ? null : N } }, e.startTransition = function (T) { var N = V.transition; V.transition = {}; try { T() } finally { V.transition = N } }, e.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }, e.useCallback = function (T, N) { return D.current.useCallback(T, N) }, e.useContext = function (T) { return D.current.useContext(T) }, e.useDebugValue = function () { }, e.useDeferredValue = function (T) { return D.current.useDeferredValue(T) }, e.useEffect = function (T, N) { return D.current.useEffect(T, N) }, e.useId = function () { return D.current.useId() }, e.useImperativeHandle = function (T, N, W) { return D.current.useImperativeHandle(T, N, W) }, e.useInsertionEffect = function (T, N) { return D.current.useInsertionEffect(T, N) }, e.useLayoutEffect = function (T, N) { return D.current.useLayoutEffect(T, N) }, e.useMemo = function (T, N) { return D.current.useMemo(T, N) }, e.useReducer = function (T, N, W) { return D.current.useReducer(T, N, W) }, e.useRef = function (T) { return D.current.useRef(T) }, e.useState = function (T) { return D.current.useState(T) }, e.useSyncExternalStore = function (T, N, W) { return D.current.useSyncExternalStore(T, N, W) }, e.useTransition = function () { return D.current.useTransition() }, e.version = "18.2.0" } }), n5 = k$({ "../../../node_modules/.pnpm/react@18.2.0/node_modules/react/index.js"(e, t) { t.exports = t5() } }); e5(n5()); function r5(e) { if (!e || typeof e != "object") return ""; try { return JSON.stringify(e) } catch { return "" } }/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *//**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */function i5(e) { const [t, n] = KD(e, wx.variantKeys), { children: r, className: i, classNames: o, label: s, ...a } = t, l = S.useMemo(() => wx({ ...n }), [r5(n)]), u = qD(o == null ? void 0 : o.base, i), c = s || r, d = S.useMemo(() => c && typeof c == "string" ? c : a["aria-label"] ? "" : "Loading", [r, c, a["aria-label"]]), f = S.useCallback(() => ({ "aria-label": d, className: l.base({ class: u }), ...a }), [d, l, u, a]); return { label: c, slots: l, classNames: o, getSpinnerProps: f } } var _$ = GD((e, t) => { const { slots: n, classNames: r, label: i, getSpinnerProps: o } = i5({ ...e }); return w.jsxs("div", { ref: t, ...o(), children: [w.jsxs("div", { className: n.wrapper({ class: r == null ? void 0 : r.wrapper }), children: [w.jsx("i", { className: n.circle1({ class: r == null ? void 0 : r.circle1 }) }), w.jsx("i", { className: n.circle2({ class: r == null ? void 0 : r.circle2 }) })] }), i && w.jsx("span", { className: n.label({ class: r == null ? void 0 : r.label }), children: i })] }) }); _$.displayName = "NextUI.Spinner"; var o5 = _$, R$ = _t((e, t) => { const { Component: n, domRef: r, children: i, styles: o, spinnerSize: s, spinner: a = w.jsx(o5, { color: "current", size: s }), spinnerPlacement: l, startContent: u, endContent: c, isLoading: d, disableRipple: f, getButtonProps: p, getRippleProps: m, isIconOnly: v } = WD({ ...e, ref: t }); return w.jsxs(n, { ref: r, className: o, ...p(), children: [u, d && l === "start" && a, d && v ? null : i, d && l === "end" && a, c, !f && w.jsx(C$, { ...m() })] }) }); R$.displayName = "NextUI.Button"; var Dy = R$, [s5, L$] = Cu({ name: "CardContext", strict: !0, errorMessage: "useCardContext: `context` is undefined. Seems you forgot to wrap component within <Card />" }), N$ = _t((e, t) => { var n; const { as: r, className: i, children: o, ...s } = e, a = r || "div", l = ht(t), { slots: u, classNames: c } = L$(), d = ke(c == null ? void 0 : c.body, i); return w.jsx(a, { ref: l, className: (n = u.body) == null ? void 0 : n.call(u, { class: d }), ...s, children: o }) }); N$.displayName = "NextUI.CardBody"; var dg = N$, O$ = _t((e, t) => { var n; const { as: r, className: i, children: o, ...s } = e, a = r || "div", l = ht(t), { slots: u, classNames: c } = L$(), d = ke(c == null ? void 0 : c.header, i); return w.jsx(a, { ref: l, className: (n = u.header) == null ? void 0 : n.call(u, { class: d }), ...s, children: o }) }); O$.displayName = "NextUI.CardHeader"; var j$ = O$; function a5(e) { var t, n, r, i; const o = Yo(), [s, a] = ha(e, Cx.variantKeys), { ref: l, as: u, children: c, onClick: d, onPress: f, autoFocus: p, className: m, classNames: v, allowTextSelectionOnPress: x = !0, ...g } = s, h = ht(l), y = u || (e.isPressable ? "button" : "div"), E = typeof y == "string", P = (n = (t = e.disableAnimation) != null ? t : o == null ? void 0 : o.disableAnimation) != null ? n : !1, $ = (i = (r = e.disableRipple) != null ? r : o == null ? void 0 : o.disableRipple) != null ? i : !1, L = ke(v == null ? void 0 : v.base, m), { onClear: b, onPress: M, ripples: R } = P$(), A = S.useCallback(W => { $ || P || h.current && M(W) }, [$, P, h, M]), { buttonProps: _, isPressed: C } = E$({ onPress: ni(f, A), elementType: u, isDisabled: !e.isPressable, onClick: d, allowTextSelectionOnPress: x, ...g }, h), { hoverProps: k, isHovered: O } = Bo({ isDisabled: !e.isHoverable, ...g }), { isFocusVisible: U, isFocused: z, focusProps: D } = ri({ autoFocus: p }), V = S.useMemo(() => Cx({ ...a, disableAnimation: P }), [fa(a), P]), H = S.useMemo(() => ({ slots: V, classNames: v, disableAnimation: P, isDisabled: e.isDisabled, isFooterBlurred: e.isFooterBlurred, fullWidth: e.fullWidth }), [V, v, e.isDisabled, e.isFooterBlurred, P, e.fullWidth]), T = S.useCallback((W = {}) => ({ ref: h, className: V.base({ class: L }), tabIndex: e.isPressable ? 0 : -1, "data-hover": fe(O), "data-pressed": fe(C), "data-focus": fe(z), "data-focus-visible": fe(U), "data-disabled": fe(e.isDisabled), ...tt(e.isPressable ? { ..._, ...D, role: "button" } : {}, e.isHoverable ? k : {}, Ki(g, { enabled: E }), Ki(W)) }), [h, V, L, E, e.isPressable, e.isHoverable, e.isDisabled, O, C, U, _, D, k, g]), N = S.useCallback(() => ({ ripples: R, onClear: b }), [R, b]); return { context: H, domRef: h, Component: y, classNames: v, children: c, isHovered: O, isPressed: C, disableAnimation: P, isPressable: e.isPressable, isHoverable: e.isHoverable, disableRipple: $, handlePress: A, isFocusVisible: U, getCardProps: T, getRippleProps: N } } var I$ = _t((e, t) => { const { children: n, context: r, Component: i, isPressable: o, disableAnimation: s, disableRipple: a, getCardProps: l, getRippleProps: u } = a5({ ...e, ref: t }); return w.jsxs(i, { ...l(), children: [w.jsx(s5, { value: r, children: n }), o && !s && !a && w.jsx(C$, { ...u() })] }) }); I$.displayName = "NextUI.Card"; var Fy = I$; function l5(e) { const [t, n] = ha(e, Vd.variantKeys), { ref: r, as: i, children: o, avatar: s, startContent: a, endContent: l, onClose: u, classNames: c, className: d, ...f } = t, p = i || "div", m = ht(r), v = ke(c == null ? void 0 : c.base, d), x = !!u, g = e.variant === "dot", { focusProps: h, isFocusVisible: y } = ri(), E = S.useMemo(() => typeof o == "string" && (o == null ? void 0 : o.length) === 1, [o]), P = S.useMemo(() => !!s || !!a, [s, a]), $ = S.useMemo(() => !!l || x, [l, x]), L = S.useMemo(() => Vd({ ...n, hasStartContent: P, hasEndContent: $, isOneChar: E, isCloseable: x, isCloseButtonFocusVisible: y }), [fa(n), y, P, $, E, x]), { pressProps: b } = Pu({ isDisabled: !!(e != null && e.isDisabled), onPress: u }), M = () => ({ ref: m, className: L.base({ class: v }), ...f }), R = () => ({ role: "button", tabIndex: 0, className: L.closeButton({ class: c == null ? void 0 : c.closeButton }), "aria-label": "close chip", ...tt(b, h) }), A = C => S.isValidElement(C) ? S.cloneElement(C, { className: L.avatar({ class: c == null ? void 0 : c.avatar }) }) : null, _ = C => S.isValidElement(C) ? S.cloneElement(C, { className: ke("max-h-[80%]", C.props.className) }) : null; return { Component: p, children: o, slots: L, classNames: c, isDot: g, isCloseable: x, startContent: A(s) || _(a), endContent: _(l), getCloseButtonProps: R, getChipProps: M } } var D$ = _t((e, t) => { const { Component: n, children: r, slots: i, classNames: o, isDot: s, isCloseable: a, startContent: l, endContent: u, getCloseButtonProps: c, getChipProps: d } = l5({ ...e, ref: t }), f = S.useMemo(() => s && !l ? w.jsx("span", { className: i.dot({ class: o == null ? void 0 : o.dot }) }) : l, [i, l, s]), p = S.useMemo(() => a ? w.jsx("span", { ...c(), children: u || w.jsx(Iy, {}) }) : u, [u, a, c]); return w.jsxs(n, { ...d(), children: [f, w.jsx("span", { className: i.content({ class: o == null ? void 0 : o.content }), children: r }), p] }) }); D$.displayName = "NextUI.Chip"; var u5 = D$; const F$ = { badInput: !1, customError: !1, patternMismatch: !1, rangeOverflow: !1, rangeUnderflow: !1, stepMismatch: !1, tooLong: !1, tooShort: !1, typeMismatch: !1, valueMissing: !1, valid: !0 }, z$ = { ...F$, customError: !0, valid: !1 }, za = { isInvalid: !1, validationDetails: F$, validationErrors: [] }, V$ = S.createContext({}), Nx = "__formValidationState" + Date.now(); function c5(e) { if (e[Nx]) { let { realtimeValidation: t, displayValidation: n, updateValidation: r, resetValidation: i, commitValidation: o } = e[Nx]; return { realtimeValidation: t, displayValidation: n, updateValidation: r, resetValidation: i, commitValidation: o } } return d5(e) } function d5(e) { let { isInvalid: t, validationState: n, name: r, value: i, builtinValidation: o, validate: s, validationBehavior: a = "aria" } = e; n && (t || (t = n === "invalid")); let l = t !== void 0 ? { isInvalid: t, validationErrors: [], validationDetails: z$ } : null, u = S.useMemo(() => { if (!s || i == null) return null; let R = f5(s, i); return Ox(R) }, [s, i]); o != null && o.validationDetails.valid && (o = void 0); let c = S.useContext(V$), d = S.useMemo(() => r ? Array.isArray(r) ? r.flatMap(R => fg(c[R])) : fg(c[r]) : [], [c, r]), [f, p] = S.useState(c), [m, v] = S.useState(!1); c !== f && (p(c), v(!1)); let x = S.useMemo(() => Ox(m ? [] : d), [m, d]), g = S.useRef(za), [h, y] = S.useState(za), E = S.useRef(za), P = () => { if (!$) return; L(!1); let R = u || o || g.current; Zp(R, E.current) || (E.current = R, y(R)) }, [$, L] = S.useState(!1); return S.useEffect(P), { realtimeValidation: l || x || u || o || za, displayValidation: a === "native" ? l || x || h : l || x || u || o || h, updateValidation(R) { a === "aria" && !Zp(h, R) ? y(R) : g.current = R }, resetValidation() { let R = za; Zp(R, E.current) || (E.current = R, y(R)), a === "native" && L(!1), v(!0) }, commitValidation() { a === "native" && L(!0), v(!0) } } } function fg(e) { return e ? Array.isArray(e) ? e : [e] : [] } function f5(e, t) { if (typeof e == "function") { let n = e(t); if (n && typeof n != "boolean") return fg(n) } return [] } function Ox(e) { return e.length ? { isInvalid: !0, validationErrors: e, validationDetails: z$ } : null } function Zp(e, t) { return e === t ? !0 : !!e && !!t && e.isInvalid === t.isInvalid && e.validationErrors.length === t.validationErrors.length && e.validationErrors.every((n, r) => n === t.validationErrors[r]) && Object.entries(e.validationDetails).every(([n, r]) => t.validationDetails[n] === r) } const B$ = typeof document < "u" ? se.useLayoutEffect : () => { }; function eh(e) { const t = S.useRef(null); return B$(() => { t.current = e }, [e]), S.useCallback((...n) => { const r = t.current; return r == null ? void 0 : r(...n) }, []) } function p5(e, t, n) { let { validationBehavior: r, focus: i } = e; B$(() => { if (r === "native" && (n != null && n.current)) { let l = t.realtimeValidation.isInvalid ? t.realtimeValidation.validationErrors.join(" ") || "Invalid value." : ""; n.current.setCustomValidity(l), n.current.hasAttribute("title") || (n.current.title = ""), t.realtimeValidation.isInvalid || t.updateValidation(m5(n.current)) } }); let o = eh(() => { t.resetValidation() }), s = eh(l => { var u; t.displayValidation.isInvalid || t.commitValidation(); let c = n == null || (u = n.current) === null || u === void 0 ? void 0 : u.form; if (!l.defaultPrevented && n && c && g5(c) === n.current) { var d; i ? i() : (d = n.current) === null || d === void 0 || d.focus(), lN("keyboard") } l.preventDefault() }), a = eh(() => { t.commitValidation() }); S.useEffect(() => { let l = n == null ? void 0 : n.current; if (!l) return; let u = l.form; return l.addEventListener("invalid", s), l.addEventListener("change", a), u == null || u.addEventListener("reset", o), () => { l.removeEventListener("invalid", s), l.removeEventListener("change", a), u == null || u.removeEventListener("reset", o) } }, [n, s, a, o, r]) } function h5(e) { let t = e.validity; return { badInput: t.badInput, customError: t.customError, patternMismatch: t.patternMismatch, rangeOverflow: t.rangeOverflow, rangeUnderflow: t.rangeUnderflow, stepMismatch: t.stepMismatch, tooLong: t.tooLong, tooShort: t.tooShort, typeMismatch: t.typeMismatch, valueMissing: t.valueMissing, valid: t.valid } } function m5(e) { return { isInvalid: !e.validity.valid, validationDetails: h5(e), validationErrors: e.validationMessage ? [e.validationMessage] : [] } } function g5(e) { for (let t = 0; t < e.elements.length; t++) { let n = e.elements[t]; if (!n.validity.valid) return n } return null } const zf = typeof document < "u" ? se.useLayoutEffect : () => { }; function jx(e) { const t = S.useRef(null); return zf(() => { t.current = e }, [e]), S.useCallback((...n) => { const r = t.current; return r == null ? void 0 : r(...n) }, []) } function v5(e) { let [t, n] = S.useState(e), r = S.useRef(null), i = jx(() => { if (!r.current) return; let s = r.current.next(); if (s.done) { r.current = null; return } t === s.value ? i() : n(s.value) }); zf(() => { r.current && i() }); let o = jx(s => { r.current = s(t), i() }); return [t, o] } let y5 = !!(typeof window < "u" && window.document && window.document.createElement), xi = new Map; function Bd(e) { let [t, n] = S.useState(e), r = S.useRef(null), i = KR(t), o = S.useCallback(s => { r.current = s }, []); return y5 && (xi.has(i) && !xi.get(i).includes(o) ? xi.set(i, [...xi.get(i), o]) : xi.set(i, [o])), zf(() => { let s = i; return () => { xi.delete(s) } }, [i]), S.useEffect(() => { let s = r.current; s && (r.current = null, n(s)) }), i } function b5(e, t) { if (e === t) return e; let n = xi.get(e); if (n) return n.forEach(i => i(t)), t; let r = xi.get(t); return r ? (r.forEach(i => i(e)), e) : t } function Ix(e = []) { let t = Bd(), [n, r] = v5(t), i = S.useCallback(() => { r(function* () { yield t, yield document.getElementById(t) ? t : void 0 }) }, [t, r]); return zf(i, [t, i, ...e]), n } function w5(...e) { return (...t) => { for (let n of e) typeof n == "function" && n(...t) } } function U$(e) { var t, n, r = ""; if (typeof e == "string" || typeof e == "number") r += e; else if (typeof e == "object") if (Array.isArray(e)) { var i = e.length; for (t = 0; t < i; t++)e[t] && (n = U$(e[t])) && (r && (r += " "), r += n) } else for (n in e) e[n] && (r && (r += " "), r += n); return r } function x5() { for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++)(e = arguments[n]) && (t = U$(e)) && (r && (r += " "), r += t); return r } function S5(...e) { let t = { ...e[0] }; for (let n = 1; n < e.length; n++) { let r = e[n]; for (let i in r) { let o = t[i], s = r[i]; typeof o == "function" && typeof s == "function" && i[0] === "o" && i[1] === "n" && i.charCodeAt(2) >= 65 && i.charCodeAt(2) <= 90 ? t[i] = w5(o, s) : (i === "className" || i === "UNSAFE_className") && typeof o == "string" && typeof s == "string" ? t[i] = x5(o, s) : i === "id" && o && s ? t.id = b5(o, s) : t[i] = s !== void 0 ? s : o } } return t } function E5(e, t) { let { id: n, "aria-label": r, "aria-labelledby": i } = e; return n = Bd(n), i && r ? i = [...new Set([n, ...i.trim().split(/\s+/)])].join(" ") : i && (i = i.trim().split(/\s+/).join(" ")), !r && !i && t && (r = t), { id: n, "aria-label": r, "aria-labelledby": i } } function T5(e) { let { id: t, label: n, "aria-labelledby": r, "aria-label": i, labelElementType: o = "label" } = e; t = Bd(t); let s = Bd(), a = {}; n ? (r = r ? `${s} ${r}` : s, a = { id: s, htmlFor: o === "label" ? t : void 0 }) : !r && !i && console.warn("If you do not provide a visible label, you must specify an aria-label or aria-labelledby attribute for accessibility"); let l = E5({ id: t, "aria-label": i, "aria-labelledby": r }); return { labelProps: a, fieldProps: l } } function C5(e) { let { description: t, errorMessage: n, isInvalid: r, validationState: i } = e, { labelProps: o, fieldProps: s } = T5(e), a = Ix([!!t, !!n, r, i]), l = Ix([!!t, !!n, r, i]); return s = S5(s, { "aria-describedby": [a, l, e["aria-describedby"]].filter(Boolean).join(" ") || void 0 }), { labelProps: o, fieldProps: s, descriptionProps: { id: a }, errorMessageProps: { id: l } } } let Dx = new Map; function P5(e, t) { if (e === t) return e; let n = Dx.get(e); if (n) return n.forEach(i => i(t)), t; let r = Dx.get(t); return r ? (r.forEach(i => i(e)), e) : t } function $5(...e) { return (...t) => { for (let n of e) typeof n == "function" && n(...t) } } function H$(e) { var t, n, r = ""; if (typeof e == "string" || typeof e == "number") r += e; else if (typeof e == "object") if (Array.isArray(e)) { var i = e.length; for (t = 0; t < i; t++)e[t] && (n = H$(e[t])) && (r && (r += " "), r += n) } else for (n in e) e[n] && (r && (r += " "), r += n); return r } function A5() { for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++)(e = arguments[n]) && (t = H$(e)) && (r && (r += " "), r += t); return r } function M5(...e) { let t = { ...e[0] }; for (let n = 1; n < e.length; n++) { let r = e[n]; for (let i in r) { let o = t[i], s = r[i]; typeof o == "function" && typeof s == "function" && i[0] === "o" && i[1] === "n" && i.charCodeAt(2) >= 65 && i.charCodeAt(2) <= 90 ? t[i] = $5(o, s) : (i === "className" || i === "UNSAFE_className") && typeof o == "string" && typeof s == "string" ? t[i] = A5(o, s) : i === "id" && o && s ? t.id = P5(o, s) : t[i] = s !== void 0 ? s : o } } return t } function k5(...e) { return e.length === 1 && e[0] ? e[0] : t => { for (let n of e) typeof n == "function" ? n(t) : n != null && (n.current = t) } } function _5(e) { const t = S.useRef(null); return S.useMemo(() => ({ get current() { return t.current }, set current(n) { t.current = n, typeof e == "function" ? e(n) : e && (e.current = n) } }), [e]) } var Fx = Symbol("default"); function W$(e, t) { let n = S.useContext(e); if (t === null) return null; if (n && typeof n == "object" && "slots" in n && n.slots) { let r = new Intl.ListFormat().format(Object.keys(n.slots).map(o => `"${o}"`)); if (!t && !n.slots[Fx]) throw new Error(`A slot prop is required. Valid slot names are ${r}.`); let i = t || Fx; if (!n.slots[i]) throw new Error(`Invalid slot "${t}". Valid slot names are ${r}.`); return n.slots[i] } return n } function R5(e, t, n) { let r = W$(n, e.slot) || {}, { ref: i, ...o } = r, s = _5(S.useMemo(() => k5(t, i), [t, i])), a = M5(o, e); return "style" in o && o.style && "style" in e && e.style && (typeof o.style == "function" || typeof e.style == "function" ? a.style = l => { let u = typeof o.style == "function" ? o.style(l) : o.style, c = { ...l.defaultStyle, ...u }, d = typeof e.style == "function" ? e.style({ ...l, defaultStyle: c }) : e.style; return { ...c, ...d } } : a.style = { ...o.style, ...e.style }), [a, s] } var pg = S.createContext(null); S.forwardRef(function (t, n) { [t, n] = R5(t, n, pg); let { validationErrors: r, validationBehavior: i = "native", children: o, className: s, ...a } = t; const l = S.useMemo(() => Q4({ className: s }), [s]); return w.jsx("form", { noValidate: i !== "native", ...a, ref: n, className: l, children: w.jsx(pg.Provider, { value: { ...t, validationBehavior: i }, children: w.jsx(V$.Provider, { value: r ?? {}, children: o }) }) }) }); function L5(e = {}) { let { isReadOnly: t } = e, [n, r] = kf(e.isSelected, e.defaultSelected || !1, e.onChange); function i(s) { t || r(s) } function o() { t || r(!n) } return { isSelected: n, setSelected: i, toggle: o } } var G$ = _t((e, t) => { const { as: n, activePage: r, ...i } = e, o = n || "span", s = ht(t); return w.jsx(o, { ref: s, "aria-hidden": !0, ...i, children: r }) }); G$.displayName = "NextUI.PaginationCursor"; var N5 = G$; function O5(e) { const { as: t, ref: n, value: r, children: i, isActive: o, isDisabled: s, onPress: a, onClick: l, getAriaLabel: u, className: c, ...d } = e, f = !!(e != null && e.href), p = t || f ? "a" : "li", m = typeof p == "string", v = ht(n), x = SL(), g = S.useMemo(() => o ? `${u == null ? void 0 : u(r)} active` : u == null ? void 0 : u(r), [r, o]), { isPressed: h, pressProps: y } = Pu({ isDisabled: s, onPress: a }), { focusProps: E, isFocused: P, isFocusVisible: $ } = ri({}), { isHovered: L, hoverProps: b } = Bo({ isDisabled: s }); return { Component: p, children: i, ariaLabel: g, isFocused: P, isFocusVisible: $, getItemProps: (R = {}) => ({ ref: v, role: "button", tabIndex: s ? -1 : 0, "aria-label": g, "aria-current": fe(o), "aria-disabled": fe(s), "data-disabled": fe(s), "data-active": fe(o), "data-focus": fe(P), "data-hover": fe(L), "data-pressed": fe(h), "data-focus-visible": fe($), ...tt(R, y, E, b, Ki(d, { enabled: m })), className: ke(c, R.className), onClick: A => { ni(y == null ? void 0 : y.onClick, l)(A), !x.isNative && A.currentTarget instanceof HTMLAnchorElement && A.currentTarget.href && !A.isDefaultPrevented() && rC(A.currentTarget, A) && R.href && (A.preventDefault(), x.open(A.currentTarget, A, R.href, R.routerOptions)) } }) } } var K$ = _t((e, t) => { const { Component: n, children: r, getItemProps: i } = O5({ ...e, ref: t }); return w.jsx(n, { ...i(), children: r }) }); K$.displayName = "NextUI.PaginationItem"; var wc = K$, $t = (e => (e.DOTS = "dots", e.PREV = "prev", e.NEXT = "next", e))($t || {}); function j5(e) { const { page: t, total: n, siblings: r = 1, boundaries: i = 1, initialPage: o = 1, showControls: s = !1, onChange: a } = e, [l, u] = S.useState(t || o), { direction: c } = Bv(), d = c === "rtl", f = E => { u(E), a && a(E) }; S.useEffect(() => { t && t !== l && u(t) }, [t]); const p = S.useCallback(E => { E <= 0 ? f(1) : E > n ? f(n) : f(E) }, [n, l, f]), m = () => p(d ? l - 1 : l + 1), v = () => p(d ? l + 1 : l - 1), x = () => p(d ? n : 1), g = () => p(d ? 1 : n), h = S.useCallback(E => s ? d ? ["next", ...E, "prev"] : ["prev", ...E, "next"] : E, [d, s]); return { range: S.useMemo(() => { if (r * 2 + 3 + i * 2 >= n) return h(di(1, n)); const P = Math.max(l - r, i), $ = Math.min(l + r, n - i), L = P > i + 2, b = $ < n - (i + 1); if (!L && b) { const M = r * 2 + i + 2; return h([...di(1, M), "dots", ...di(n - (i - 1), n)]) } if (L && !b) { const M = i + 1 + 2 * r; return h([...di(1, i), "dots", ...di(n - M, n)]) } return h([...di(1, i), "dots", ...di(P, $), "dots", ...di(n - i + 1, n)]) }, [n, l, r, i, h]), activePage: l, setPage: p, next: m, previous: v, first: x, last: g } } const zx = e => typeof e == "object" && e != null && e.nodeType === 1, Vx = (e, t) => (!t || e !== "hidden") && e !== "visible" && e !== "clip", th = (e, t) => { if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) { const n = getComputedStyle(e, null); return Vx(n.overflowY, t) || Vx(n.overflowX, t) || (r => { const i = (o => { if (!o.ownerDocument || !o.ownerDocument.defaultView) return null; try { return o.ownerDocument.defaultView.frameElement } catch { return null } })(r); return !!i && (i.clientHeight < r.scrollHeight || i.clientWidth < r.scrollWidth) })(e) } return !1 }, xc = (e, t, n, r, i, o, s, a) => o < e && s > t || o > e && s < t ? 0 : o <= e && a <= n || s >= t && a >= n ? o - e - r : s > t && a < n || o < e && a > n ? s - t + i : 0, I5 = e => { const t = e.parentElement; return t ?? (e.getRootNode().host || null) }, Bx = (e, t) => { var n, r, i, o; if (typeof document > "u") return []; const { scrollMode: s, block: a, inline: l, boundary: u, skipOverflowHiddenElements: c } = t, d = typeof u == "function" ? u : U => U !== u; if (!zx(e)) throw new TypeError("Invalid target"); const f = document.scrollingElement || document.documentElement, p = []; let m = e; for (; zx(m) && d(m);) { if (m = I5(m), m === f) { p.push(m); break } m != null && m === document.body && th(m) && !th(document.documentElement) || m != null && th(m, c) && p.push(m) } const v = (r = (n = window.visualViewport) == null ? void 0 : n.width) != null ? r : innerWidth, x = (o = (i = window.visualViewport) == null ? void 0 : i.height) != null ? o : innerHeight, { scrollX: g, scrollY: h } = window, { height: y, width: E, top: P, right: $, bottom: L, left: b } = e.getBoundingClientRect(), { top: M, right: R, bottom: A, left: _ } = (U => { const z = window.getComputedStyle(U); return { top: parseFloat(z.scrollMarginTop) || 0, right: parseFloat(z.scrollMarginRight) || 0, bottom: parseFloat(z.scrollMarginBottom) || 0, left: parseFloat(z.scrollMarginLeft) || 0 } })(e); let C = a === "start" || a === "nearest" ? P - M : a === "end" ? L + A : P + y / 2 - M + A, k = l === "center" ? b + E / 2 - _ + R : l === "end" ? $ + R : b - _; const O = []; for (let U = 0; U < p.length; U++) { const z = p[U], { height: D, width: V, top: H, right: T, bottom: N, left: W } = z.getBoundingClientRect(); if (s === "if-needed" && P >= 0 && b >= 0 && L <= x && $ <= v && P >= H && L <= N && b >= W && $ <= T) return O; const Q = getComputedStyle(z), q = parseInt(Q.borderLeftWidth, 10), te = parseInt(Q.borderTopWidth, 10), ae = parseInt(Q.borderRightWidth, 10), le = parseInt(Q.borderBottomWidth, 10); let oe = 0, ge = 0; const Pe = "offsetWidth" in z ? z.offsetWidth - z.clientWidth - q - ae : 0, Oe = "offsetHeight" in z ? z.offsetHeight - z.clientHeight - te - le : 0, gt = "offsetWidth" in z ? z.offsetWidth === 0 ? 0 : V / z.offsetWidth : 0, Je = "offsetHeight" in z ? z.offsetHeight === 0 ? 0 : D / z.offsetHeight : 0; if (f === z) oe = a === "start" ? C : a === "end" ? C - x : a === "nearest" ? xc(h, h + x, x, te, le, h + C, h + C + y, y) : C - x / 2, ge = l === "start" ? k : l === "center" ? k - v / 2 : l === "end" ? k - v : xc(g, g + v, v, q, ae, g + k, g + k + E, E), oe = Math.max(0, oe + h), ge = Math.max(0, ge + g); else { oe = a === "start" ? C - H - te : a === "end" ? C - N + le + Oe : a === "nearest" ? xc(H, N, D, te, le + Oe, C, C + y, y) : C - (H + D / 2) + Oe / 2, ge = l === "start" ? k - W - q : l === "center" ? k - (W + V / 2) + Pe / 2 : l === "end" ? k - T + ae + Pe : xc(W, T, V, q, ae + Pe, k, k + E, E); const { scrollLeft: it, scrollTop: lt } = z; oe = Je === 0 ? 0 : Math.max(0, Math.min(lt + oe / Je, z.scrollHeight - D / Je + Oe)), ge = gt === 0 ? 0 : Math.max(0, Math.min(it + ge / gt, z.scrollWidth - V / gt + Pe)), C += lt - oe, k += it - ge } O.push({ el: z, top: oe, left: ge }) } return O }, D5 = e => e === !1 ? { block: "end", inline: "nearest" } : (t => t === Object(t) && Object.keys(t).length !== 0)(e) ? e : { block: "start", inline: "nearest" }; function F5(e, t) { if (!e.isConnected || !(r => { let i = r; for (; i && i.parentNode;) { if (i.parentNode === document) return !0; i = i.parentNode instanceof ShadowRoot ? i.parentNode.host : i.parentNode } return !1 })(e)) return; if ((r => typeof r == "object" && typeof r.behavior == "function")(t)) return t.behavior(Bx(e, t)); const n = typeof t == "boolean" || t == null ? void 0 : t.behavior; for (const { el: r, top: i, left: o } of Bx(e, D5(t))) r.scroll({ top: i, left: o, behavior: n }) } function z5({ threshold: e = 0, root: t = null, rootMargin: n = "0%", isEnabled: r = !0, freezeOnceVisible: i = !1, initialIsIntersecting: o = !1, onChange: s } = {}) { var a; const [l, u] = S.useState(null), [c, d] = S.useState(() => ({ isIntersecting: o, entry: void 0 })), f = S.useRef(); f.current = s; const p = ((a = c.entry) == null ? void 0 : a.isIntersecting) && i; S.useEffect(() => { if (!r || !l || !("IntersectionObserver" in window) || p) return; let x; const g = new IntersectionObserver(h => { const y = Array.isArray(g.thresholds) ? g.thresholds : [g.thresholds]; h.forEach(E => { const P = E.isIntersecting && y.some($ => E.intersectionRatio >= $); d({ isIntersecting: P, entry: E }), f.current && f.current(P, E), P && i && x && (x(), x = void 0) }) }, { threshold: e, root: t, rootMargin: n }); return g.observe(l), () => { g.disconnect() } }, [l, r, JSON.stringify(e), t, n, p, i]); const m = S.useRef(null); S.useEffect(() => { var x; !l && ((x = c.entry) != null && x.target) && !i && !p && m.current !== c.entry.target && (m.current = c.entry.target, d({ isIntersecting: o, entry: void 0 })) }, [l, c.entry, i, p, o]); const v = [u, !!c.isIntersecting, c.entry]; return v.ref = v[0], v.isIntersecting = v[1], v.entry = v[2], v } var Ux = 300; function V5(e) { var t, n, r, i; const o = Yo(), [s, a] = ha(e, Tx.variantKeys), { as: l, ref: u, classNames: c, dotsJump: d = 5, loop: f = !1, showControls: p = !1, total: m = 1, initialPage: v = 1, page: x, siblings: g, boundaries: h, onChange: y, className: E, renderItem: P, getItemAriaLabel: $, ...L } = s, b = l || "nav", M = ht(u), R = S.useRef(null), A = S.useRef(), _ = S.useRef(), { direction: C } = Bv(), k = C === "rtl", O = (n = (t = e == null ? void 0 : e.disableAnimation) != null ? t : o == null ? void 0 : o.disableAnimation) != null ? n : !1, U = (i = (r = e == null ? void 0 : e.disableCursorAnimation) != null ? r : O) != null ? i : !1; function z() { return A.current || (A.current = new Map), A.current } function D(ye, Ht) { const en = z(); ye ? en.set(Ht, ye) : en.delete(Ht) } function V(ye, Ht) { const jt = z().get(ye); if (!jt || !R.current) return; _.current && clearTimeout(_.current), F5(jt, { scrollMode: "always", behavior: "smooth", block: "start", inline: "start", boundary: M.current }); const { offsetLeft: ut } = jt; if (Ht) { R.current.setAttribute("data-moving", "false"), R.current.style.transform = `translateX(${ut}px) scale(1)`; return } R.current.setAttribute("data-moving", "true"), R.current.style.transform = `translateX(${ut}px) scale(1.1)`, _.current = setTimeout(() => { R.current && (R.current.style.transform = `translateX(${ut}px) scale(1)`), _.current = setTimeout(() => { var Wt; (Wt = R.current) == null || Wt.setAttribute("data-moving", "false"), _.current && clearTimeout(_.current) }, Ux) }, Ux) } const { range: H, activePage: T, setPage: N, previous: W, next: Q, first: q, last: te } = j5({ page: x, total: m, initialPage: v, siblings: g, boundaries: h, showControls: p, onChange: y }), [ae, le] = z5(); S.useEffect(() => { M.current && ae(M.current) }, [M.current]); const oe = S.useRef(T); S.useEffect(() => { T && !O && le && V(T, T === oe.current), oe.current = T }, [T, O, U, le, e.dotsJump, e.isCompact, e.showControls]); const ge = S.useMemo(() => Tx({ ...a, disableAnimation: O, disableCursorAnimation: U }), [fa(a), U, O]), Pe = ke(c == null ? void 0 : c.base, E); return { Component: b, showControls: p, dotsJump: d, slots: ge, classNames: c, loop: f, total: m, range: H, activePage: T, getItemRef: D, disableAnimation: O, disableCursorAnimation: U, setPage: N, onPrevious: () => f && T === (k ? m : 1) ? te() : W(), onNext: () => f && T === (k ? 1 : m) ? q() : Q(), renderItem: P, getBaseProps: (ye = {}) => ({ ...ye, ref: M, role: "navigation", "aria-label": ye["aria-label"] || "pagination navigation", "data-slot": "base", "data-controls": fe(p), "data-loop": fe(f), "data-dots-jump": d, "data-total": m, "data-active-page": T, className: ge.base({ class: ke(Pe, ye == null ? void 0 : ye.className) }), ...L }), getWrapperProps: (ye = {}) => ({ ...ye, "data-slot": "wrapper", className: ge.wrapper({ class: ke(c == null ? void 0 : c.wrapper, ye == null ? void 0 : ye.className) }) }), getItemProps: (ye = {}) => ({ ...ye, ref: Ht => D(Ht, ye.value), "data-slot": "item", isActive: ye.value === T, className: ge.item({ class: ke(c == null ? void 0 : c.item, ye == null ? void 0 : ye.className) }), onPress: () => { ye.value !== T && N(ye.value) } }), getCursorProps: (ye = {}) => ({ ...ye, ref: R, activePage: T, "data-slot": "cursor", className: ge.cursor({ class: ke(c == null ? void 0 : c.cursor, ye == null ? void 0 : ye.className) }) }), getItemAriaLabel: ye => { if (ye) { if ($) return $(ye); switch (ye) { case $t.DOTS: return "dots element"; case $t.PREV: return "previous page button"; case $t.NEXT: return "next page button"; case "first": return "first page button"; case "last": return "last page button"; default: return `pagination item ${ye}` } } } } } var q$ = _t((e, t) => { const { Component: n, dotsJump: r, slots: i, classNames: o, total: s, range: a, loop: l, activePage: u, disableCursorAnimation: c, disableAnimation: d, renderItem: f, onNext: p, onPrevious: m, setPage: v, getItemAriaLabel: x, getItemRef: g, getBaseProps: h, getWrapperProps: y, getItemProps: E, getCursorProps: P } = V5({ ...e, ref: t }), { direction: $ } = Bv(), L = $ === "rtl", b = S.useCallback((M, R) => { const A = R < a.indexOf(u); if (f && typeof f == "function") { let _ = typeof M == "number" ? M : R; M === $t.NEXT && (_ = u + 1), M === $t.PREV && (_ = u - 1), M === $t.DOTS && (_ = A ? u - r >= 1 ? u - r : 1 : u + r <= s ? u + r : s); const C = { [$t.PREV]: w.jsx(bc, {}), [$t.NEXT]: w.jsx(bc, { className: i.chevronNext({ class: o == null ? void 0 : o.chevronNext }) }), [$t.DOTS]: w.jsxs(w.Fragment, { children: [w.jsx(Rx, { className: i == null ? void 0 : i.ellipsis({ class: o == null ? void 0 : o.ellipsis }) }), w.jsx(_x, { className: i == null ? void 0 : i.forwardIcon({ class: o == null ? void 0 : o.forwardIcon }), "data-before": fe(A) })] }) }; return f({ value: M, index: R, key: `${M}-${R}`, page: _, total: s, children: typeof M == "number" ? M : C[M], activePage: u, dotsJump: r, isBefore: A, isActive: M === u, isPrevious: M === u - 1, isNext: M === u + 1, isFirst: M === 1, isLast: M === s, onNext: p, onPrevious: m, setPage: v, onPress: () => v(_), ref: typeof M == "number" ? k => g(k, M) : void 0, className: i.item({ class: o == null ? void 0 : o.item }), getAriaLabel: x }) } return M === $t.PREV ? w.jsx(wc, { className: i.prev({ class: o == null ? void 0 : o.prev }), "data-slot": "prev", getAriaLabel: x, isDisabled: !l && u === (L ? s : 1), value: M, onPress: m, children: w.jsx(bc, {}) }, $t.PREV) : M === $t.NEXT ? w.jsx(wc, { className: i.next({ class: ke(o == null ? void 0 : o.next) }), "data-slot": "next", getAriaLabel: x, isDisabled: !l && u === (L ? 1 : s), value: M, onPress: p, children: w.jsx(bc, { className: i.chevronNext({ class: o == null ? void 0 : o.chevronNext }) }) }, $t.NEXT) : M === $t.DOTS ? w.jsxs(wc, { className: i.item({ class: ke(o == null ? void 0 : o.item, "group") }), "data-slot": "item", getAriaLabel: x, value: M, onPress: () => v(A ? u - r >= 1 ? u - r : 1 : u + r <= s ? u + r : s), children: [w.jsx(Rx, { className: i == null ? void 0 : i.ellipsis({ class: o == null ? void 0 : o.ellipsis }) }), w.jsx(_x, { className: i == null ? void 0 : i.forwardIcon({ class: o == null ? void 0 : o.forwardIcon }), "data-before": fe(L ? !A : A) })] }, $t.DOTS + A) : S.createElement(wc, { ...E({ value: M }), key: M, getAriaLabel: x }, M) }, [L, u, r, E, l, a, f, i, o, s]); return w.jsx(n, { ...h(), children: w.jsxs("ul", { ...y(), children: [!c && !d && w.jsx(N5, { ...P() }), a.map(b)] }) }) }); q$.displayName = "NextUI.Pagination"; var B5 = q$; function U5(e) { const { as: t, ref: n, name: r, description: i, className: o, classNames: s, isFocusable: a = !1, avatarProps: l = {}, ...u } = e, c = { isFocusable: !1, ...l }, d = t || "div", f = typeof d == "string", p = ht(n), { isFocusVisible: m, isFocused: v, focusProps: x } = ri({}), g = S.useMemo(() => a || t === "button", [a, t]), h = S.useMemo(() => Y4(), []), y = ke(s == null ? void 0 : s.base, o), E = S.useCallback(() => ({ ref: p, tabIndex: g ? 0 : -1, "data-focus-visible": fe(m), "data-focus": fe(v), className: h.base({ class: y }), ...tt(Ki(u, { enabled: f }), g ? x : {}) }), [g, h, y, x, u]); return { Component: d, className: o, slots: h, name: r, description: i, classNames: s, baseStyles: y, avatarProps: c, getUserProps: E } } var Y$ = _t((e, t) => { const { Component: n, name: r, slots: i, classNames: o, description: s, avatarProps: a, getUserProps: l } = U5({ ...e, ref: t }); return w.jsxs(n, { ...l(), children: [w.jsx(BD, { ...a }), w.jsxs("div", { className: i.wrapper({ class: o == null ? void 0 : o.wrapper }), children: [w.jsx("span", { className: i.name({ class: o == null ? void 0 : o.name }), children: r }), w.jsx("span", { className: i.description({ class: o == null ? void 0 : o.description }), children: s })] })] }) }); Y$.displayName = "NextUI.User"; var Q$ = Y$; function H5(e, t) { let { inputElementType: n = "input", isDisabled: r = !1, isRequired: i = !1, isReadOnly: o = !1, type: s = "text", validationBehavior: a = "aria" } = e, [l, u] = kf(e.value, e.defaultValue || "", e.onChange), { focusableProps: c } = Jv(e, t), d = c5({ ...e, value: l }), { isInvalid: f, validationErrors: p, validationDetails: m } = d.displayValidation, { labelProps: v, fieldProps: x, descriptionProps: g, errorMessageProps: h } = C5({ ...e, isInvalid: f, errorMessage: e.errorMessage || p }), y = Hv(e, { labelable: !0 }); const E = { type: s, pattern: e.pattern }; return PL(t, l, u), p5(e, d, t), S.useEffect(() => { if (t.current instanceof sL(t.current).HTMLTextAreaElement) { let P = t.current; Object.defineProperty(P, "defaultValue", { get: () => P.value, set: () => { }, configurable: !0 }) } }, [t]), { labelProps: v, inputProps: tt(y, n === "input" ? E : void 0, { disabled: r, readOnly: o, required: i && a === "native", "aria-required": i && a === "aria" || void 0, "aria-invalid": f || void 0, "aria-errormessage": e["aria-errormessage"], "aria-activedescendant": e["aria-activedescendant"], "aria-autocomplete": e["aria-autocomplete"], "aria-haspopup": e["aria-haspopup"], value: l, onChange: P => u(P.target.value), autoComplete: e.autoComplete, autoCapitalize: e.autoCapitalize, maxLength: e.maxLength, minLength: e.minLength, name: e.name, placeholder: e.placeholder, inputMode: e.inputMode, onCopy: e.onCopy, onCut: e.onCut, onPaste: e.onPaste, onCompositionEnd: e.onCompositionEnd, onCompositionStart: e.onCompositionStart, onCompositionUpdate: e.onCompositionUpdate, onSelect: e.onSelect, onBeforeInput: e.onBeforeInput, onInput: e.onInput, ...c, ...x }), descriptionProps: g, errorMessageProps: h, isInvalid: f, validationErrors: p, validationDetails: m } } function X$(e) { var t, n, r, i; const o = Yo(), { validationBehavior: s } = W$(pg) || {}, [a, l] = ha(e, Sx.variantKeys), { ref: u, as: c, type: d, label: f, baseRef: p, wrapperRef: m, description: v, className: x, classNames: g, autoFocus: h, startContent: y, endContent: E, onClear: P, onChange: $, validationState: L, validationBehavior: b = (t = s ?? (o == null ? void 0 : o.validationBehavior)) != null ? t : "native", innerWrapperRef: M, onValueChange: R = () => { }, ...A } = a, _ = S.useCallback(X => { R(X ?? "") }, [R]), [C, k] = S.useState(!1), O = c || "div", U = (r = (n = e.disableAnimation) != null ? n : o == null ? void 0 : o.disableAnimation) != null ? r : !1, z = ht(u), D = ht(p), V = ht(m), H = ht(M), [T, N] = kf(a.value, (i = a.defaultValue) != null ? i : "", _), W = ["date", "time", "month", "week", "range"].includes(d), Q = !xR(T) || W, q = Q || C, te = d === "hidden", ae = e.isMultiline, le = d === "file", oe = ke(g == null ? void 0 : g.base, x, Q ? "is-filled" : ""), ge = S.useCallback(() => { var X; N(""), P == null || P(), (X = z.current) == null || X.focus() }, [N, P]); x$(() => { z.current && N(z.current.value) }, [z.current]); const { labelProps: Pe, inputProps: Oe, isInvalid: gt, validationErrors: Je, validationDetails: it, descriptionProps: lt, errorMessageProps: Jt } = H5({ ...e, validationBehavior: b, autoCapitalize: e.autoCapitalize, value: T, "aria-label": ER(e["aria-label"], e.label, e.placeholder), inputElementType: ae ? "textarea" : "input", onChange: N }, z); le && (delete Oe.value, delete Oe.onChange); const { isFocusVisible: Zt, isFocused: ye, focusProps: Ht } = ri({ autoFocus: h, isTextInput: !0 }), { isHovered: en, hoverProps: jt } = Bo({ isDisabled: !!(e != null && e.isDisabled) }), { isHovered: ut, hoverProps: Wt } = Bo({ isDisabled: !!(e != null && e.isDisabled) }), { focusProps: Fn, isFocusVisible: wn } = ri(), { focusWithinProps: fn } = TC({ onFocusWithinChange: k }), { pressProps: tn } = Pu({ isDisabled: !!(e != null && e.isDisabled) || !!(e != null && e.isReadOnly), onPress: ge }), zn = L === "invalid" || gt, Pt = S.useMemo(() => { var X; return (!e.labelPlacement || e.labelPlacement === "inside") && !f ? "outside" : (X = e.labelPlacement) != null ? X : "inside" }, [e.labelPlacement, f]), li = typeof a.errorMessage == "function" ? a.errorMessage({ isInvalid: zn, validationErrors: Je, validationDetails: it }) : a.errorMessage || (Je == null ? void 0 : Je.join(" ")), It = !!P || e.isClearable, br = !!f || !!v || !!li, vt = !!a.placeholder, Vn = !!f, Lr = !!v || !!li, Nr = Pt === "outside" || Pt === "outside-left", ui = Pt === "inside", xn = z.current ? (!z.current.value || z.current.value === "" || !T || T === "") && vt : !1, io = Pt === "outside-left", nn = !!y, ot = Nr ? Pt === "outside-left" || vt || Pt === "outside" && nn : !1, rr = Pt === "outside" && !vt && !nn, Ye = S.useMemo(() => Sx({ ...l, isInvalid: zn, labelPlacement: Pt, isClearable: It, disableAnimation: U }), [fa(l), zn, Pt, It, nn, U]), oo = S.useCallback((X = {}) => ({ ref: D, className: Ye.base({ class: oe }), "data-slot": "base", "data-filled": fe(Q || vt || nn || xn || le), "data-filled-within": fe(q || vt || nn || xn || le), "data-focus-within": fe(C), "data-focus-visible": fe(Zt), "data-readonly": fe(e.isReadOnly), "data-focus": fe(ye), "data-hover": fe(en || ut), "data-required": fe(e.isRequired), "data-invalid": fe(zn), "data-disabled": fe(e.isDisabled), "data-has-elements": fe(br), "data-has-helper": fe(Lr), "data-has-label": fe(Vn), "data-has-value": fe(!xn), "data-hidden": fe(te), ...fn, ...X }), [Ye, oe, Q, ye, en, ut, zn, Lr, Vn, br, xn, nn, C, Zt, q, vt, fn, te, e.isReadOnly, e.isRequired, e.isDisabled]), wr = S.useCallback((X = {}) => ({ "data-slot": "label", className: Ye.label({ class: g == null ? void 0 : g.label }), ...tt(Pe, Wt, X) }), [Ye, ut, Pe, g == null ? void 0 : g.label]), Or = S.useCallback((X = {}) => ({ "data-slot": "input", "data-filled": fe(Q), "data-filled-within": fe(q), "data-has-start-content": fe(nn), "data-has-end-content": fe(!!E), className: Ye.input({ class: ke(g == null ? void 0 : g.input, Q ? "is-filled" : "", ae ? "pe-0" : "") }), ...tt(Ht, Oe, Ki(A, { enabled: !0, labelable: !0, omitEventNames: new Set(Object.keys(Oe)) }), X), "aria-readonly": fe(e.isReadOnly), onChange: ni(Oe.onChange, $), ref: z }), [Ye, T, Ht, Oe, A, Q, q, nn, E, g == null ? void 0 : g.input, e.isReadOnly, e.isRequired, $]), rs = S.useCallback((X = {}) => ({ ref: V, "data-slot": "input-wrapper", "data-hover": fe(en || ut), "data-focus-visible": fe(Zt), "data-focus": fe(ye), className: Ye.inputWrapper({ class: ke(g == null ? void 0 : g.inputWrapper, Q ? "is-filled" : "") }), ...tt(X, jt), onClick: me => { z.current && me.currentTarget === me.target && z.current.focus() }, style: { cursor: "text", ...X.style } }), [Ye, en, ut, Zt, ye, T, g == null ? void 0 : g.inputWrapper]), Ea = S.useCallback((X = {}) => ({ ...X, ref: H, "data-slot": "inner-wrapper", onClick: me => { z.current && me.currentTarget === me.target && z.current.focus() }, className: Ye.innerWrapper({ class: ke(g == null ? void 0 : g.innerWrapper, X == null ? void 0 : X.className) }) }), [Ye, g == null ? void 0 : g.innerWrapper]), j = S.useCallback((X = {}) => ({ ...X, "data-slot": "main-wrapper", className: Ye.mainWrapper({ class: ke(g == null ? void 0 : g.mainWrapper, X == null ? void 0 : X.className) }) }), [Ye, g == null ? void 0 : g.mainWrapper]), F = S.useCallback((X = {}) => ({ ...X, "data-slot": "helper-wrapper", className: Ye.helperWrapper({ class: ke(g == null ? void 0 : g.helperWrapper, X == null ? void 0 : X.className) }) }), [Ye, g == null ? void 0 : g.helperWrapper]), B = S.useCallback((X = {}) => ({ ...X, ...lt, "data-slot": "description", className: Ye.description({ class: ke(g == null ? void 0 : g.description, X == null ? void 0 : X.className) }) }), [Ye, g == null ? void 0 : g.description]), K = S.useCallback((X = {}) => ({ ...X, ...Jt, "data-slot": "error-message", className: Ye.errorMessage({ class: ke(g == null ? void 0 : g.errorMessage, X == null ? void 0 : X.className) }) }), [Ye, Jt, g == null ? void 0 : g.errorMessage]), ie = S.useCallback((X = {}) => ({ ...X, type: "button", tabIndex: -1, disabled: e.isDisabled, "aria-label": "clear input", "data-slot": "clear-button", "data-focus-visible": fe(wn), className: Ye.clearButton({ class: ke(g == null ? void 0 : g.clearButton, X == null ? void 0 : X.className) }), ...tt(tn, Fn) }), [Ye, wn, tn, Fn, g == null ? void 0 : g.clearButton]); return { Component: O, classNames: g, domRef: z, label: f, description: v, startContent: y, endContent: E, labelPlacement: Pt, isClearable: It, hasHelper: Lr, hasStartContent: nn, isLabelOutside: ot, isOutsideLeft: io, isLabelOutsideAsPlaceholder: rr, shouldLabelBeOutside: Nr, shouldLabelBeInside: ui, hasPlaceholder: vt, isInvalid: zn, errorMessage: li, getBaseProps: oo, getLabelProps: wr, getInputProps: Or, getMainWrapperProps: j, getInputWrapperProps: rs, getInnerWrapperProps: Ea, getHelperWrapperProps: F, getDescriptionProps: B, getErrorMessageProps: K, getClearButtonProps: ie } } var J$ = _t((e, t) => { const { Component: n, label: r, description: i, isClearable: o, startContent: s, endContent: a, labelPlacement: l, hasHelper: u, isOutsideLeft: c, shouldLabelBeOutside: d, errorMessage: f, isInvalid: p, getBaseProps: m, getLabelProps: v, getInputProps: x, getInnerWrapperProps: g, getInputWrapperProps: h, getMainWrapperProps: y, getHelperWrapperProps: E, getDescriptionProps: P, getErrorMessageProps: $, getClearButtonProps: L } = X$({ ...e, ref: t }), b = r ? w.jsx("label", { ...v(), children: r }) : null, M = S.useMemo(() => o ? w.jsx("button", { ...L(), children: a || w.jsx(Iy, {}) }) : a, [o, L]), R = S.useMemo(() => { const C = p && f; return !u || !(C || i) ? null : w.jsx("div", { ...E(), children: C ? w.jsx("div", { ...$(), children: f }) : w.jsx("div", { ...P(), children: i }) }) }, [u, p, f, i, E, $, P]), A = S.useMemo(() => w.jsxs("div", { ...g(), children: [s, w.jsx("input", { ...x() }), M] }), [s, M, x, g]), _ = S.useMemo(() => d ? w.jsxs("div", { ...y(), children: [w.jsxs("div", { ...h(), children: [c ? null : b, A] }), R] }) : w.jsxs(w.Fragment, { children: [w.jsxs("div", { ...h(), children: [b, A] }), R] }), [l, R, d, b, A, f, i, y, h, $, P]); return w.jsxs(n, { ...m(), children: [c ? b : null, _] }) }); J$.displayName = "NextUI.Input"; var Hx = J$; function je() { return je = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, je.apply(null, arguments) } function W5(e, t) { if (e == null) return {}; var n = {}; for (var r in e) if ({}.hasOwnProperty.call(e, r)) { if (t.includes(r)) continue; n[r] = e[r] } return n } var G5 = S.useLayoutEffect, K5 = function (t) { var n = S.useRef(t); return G5(function () { n.current = t }), n }, Wx = function (t, n) { if (typeof t == "function") { t(n); return } t.current = n }, q5 = function (t, n) { var r = S.useRef(); return S.useCallback(function (i) { t.current = i, r.current && Wx(r.current, null), r.current = n, n && Wx(n, i) }, [n]) }, Gx = { "min-height": "0", "max-height": "none", height: "0", visibility: "hidden", overflow: "hidden", position: "absolute", "z-index": "-1000", top: "0", right: "0" }, Y5 = function (t) { Object.keys(Gx).forEach(function (n) { t.style.setProperty(n, Gx[n], "important") }) }, Kx = Y5, rn = null, qx = function (t, n) { var r = t.scrollHeight; return n.sizingStyle.boxSizing === "border-box" ? r + n.borderSize : r - n.paddingSize }; function Q5(e, t, n, r) { n === void 0 && (n = 1), r === void 0 && (r = 1 / 0), rn || (rn = document.createElement("textarea"), rn.setAttribute("tabindex", "-1"), rn.setAttribute("aria-hidden", "true"), Kx(rn)), rn.parentNode === null && document.body.appendChild(rn); var i = e.paddingSize, o = e.borderSize, s = e.sizingStyle, a = s.boxSizing; Object.keys(s).forEach(function (f) { var p = f; rn.style[p] = s[p] }), Kx(rn), rn.value = t; var l = qx(rn, e); rn.value = t, l = qx(rn, e), rn.value = "x"; var u = rn.scrollHeight - i, c = u * n; a === "border-box" && (c = c + i + o), l = Math.max(c, l); var d = u * r; return a === "border-box" && (d = d + i + o), l = Math.min(d, l), [l, u] } var Yx = function () { }, X5 = function (t, n) { return t.reduce(function (r, i) { return r[i] = n[i], r }, {}) }, J5 = ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "boxSizing", "fontFamily", "fontSize", "fontStyle", "fontWeight", "letterSpacing", "lineHeight", "paddingBottom", "paddingLeft", "paddingRight", "paddingTop", "tabSize", "textIndent", "textRendering", "textTransform", "width", "wordBreak"], Z5 = !!document.documentElement.currentStyle, e6 = function (t) { var n = window.getComputedStyle(t); if (n === null) return null; var r = X5(J5, n), i = r.boxSizing; if (i === "") return null; Z5 && i === "border-box" && (r.width = parseFloat(r.width) + parseFloat(r.borderRightWidth) + parseFloat(r.borderLeftWidth) + parseFloat(r.paddingRight) + parseFloat(r.paddingLeft) + "px"); var o = parseFloat(r.paddingBottom) + parseFloat(r.paddingTop), s = parseFloat(r.borderBottomWidth) + parseFloat(r.borderTopWidth); return { sizingStyle: r, paddingSize: o, borderSize: s } }, t6 = e6; function Z$(e, t, n) { var r = K5(n); S.useLayoutEffect(function () { var i = function (s) { return r.current(s) }; if (e) return e.addEventListener(t, i), function () { return e.removeEventListener(t, i) } }, []) } var n6 = function (t) { Z$(window, "resize", t) }, r6 = function (t) { Z$(document.fonts, "loadingdone", t) }, i6 = ["cacheMeasurements", "maxRows", "minRows", "onChange", "onHeightChange"], o6 = function (t, n) { var r = t.cacheMeasurements, i = t.maxRows, o = t.minRows, s = t.onChange, a = s === void 0 ? Yx : s, l = t.onHeightChange, u = l === void 0 ? Yx : l, c = W5(t, i6), d = c.value !== void 0, f = S.useRef(null), p = q5(f, n), m = S.useRef(0), v = S.useRef(), x = function () { var y = f.current, E = r && v.current ? v.current : t6(y); if (E) { v.current = E; var P = Q5(E, y.value || y.placeholder || "x", o, i), $ = P[0], L = P[1]; m.current !== $ && (m.current = $, y.style.setProperty("height", $ + "px", "important"), u($, { rowHeight: L })) } }, g = function (y) { d || x(), a(y) }; return S.useLayoutEffect(x), n6(x), r6(x), S.createElement("textarea", je({}, c, { onChange: g, ref: p })) }, s6 = S.forwardRef(o6), e2 = _t(({ style: e, minRows: t = 3, maxRows: n = 8, cacheMeasurements: r = !1, disableAutosize: i = !1, onHeightChange: o, ...s }, a) => { const { Component: l, label: u, description: c, startContent: d, endContent: f, hasHelper: p, shouldLabelBeOutside: m, shouldLabelBeInside: v, isInvalid: x, errorMessage: g, getBaseProps: h, getLabelProps: y, getInputProps: E, getInnerWrapperProps: P, getInputWrapperProps: $, getHelperWrapperProps: L, getDescriptionProps: b, getErrorMessageProps: M, isClearable: R, getClearButtonProps: A } = X$({ ...s, ref: a, isMultiline: !0 }), [_, C] = S.useState(t > 1), [k, O] = S.useState(!1), U = u ? w.jsx("label", { ...y(), children: u }) : null, z = E(), D = (Q, q) => { if (t === 1 && C(Q >= q.rowHeight * 2), n > t) { const te = Q >= n * q.rowHeight; O(te) } o == null || o(Q, q) }, V = i ? w.jsx("textarea", { ...z, style: tt(z.style, e ?? {}) }) : w.jsx(s6, { ...z, cacheMeasurements: r, "data-hide-scroll": fe(!k), maxRows: n, minRows: t, style: tt(z.style, e ?? {}), onHeightChange: D }), H = S.useMemo(() => R ? w.jsx("button", { ...A(), children: w.jsx(Iy, {}) }) : null, [R, A]), T = S.useMemo(() => d || f ? w.jsxs("div", { ...P(), children: [d, V, f] }) : w.jsx("div", { ...P(), children: V }), [d, z, f, P]), N = x && g, W = N || c; return w.jsxs(l, { ...h(), children: [m ? U : null, w.jsxs("div", { ...$(), "data-has-multiple-rows": fe(_), children: [v ? U : null, T, H] }), p && W ? w.jsx("div", { ...L(), children: N ? w.jsx("div", { ...M(), children: g }) : w.jsx("div", { ...b(), children: c }) }) : null] }) }); e2.displayName = "NextUI.Textarea"; var a6 = e2, [l6, Ru] = Cu({ name: "NavbarContext", strict: !0, errorMessage: "useNavbarContext: `context` is undefined. Seems you forgot to wrap component within <Navbar />" }), u6 = { enter: { height: "calc(100vh - var(--navbar-height))", transition: { duration: .3, easings: "easeOut" } }, exit: { height: 0, transition: { duration: .25, easings: "easeIn" } } }, c6 = () => ga(() => import("./index-XqZGe4bn.js"), []).then(e => e.default), t2 = _t((e, t) => { var n, r; const { className: i, children: o, portalContainer: s, motionProps: a, style: l, ...u } = e, c = ht(t), { slots: d, isMenuOpen: f, height: p, disableAnimation: m, classNames: v } = Ru(), x = ke(v == null ? void 0 : v.menu, i), g = m ? w.jsx("ul", { ref: c, className: (n = d.menu) == null ? void 0 : n.call(d, { class: x }), "data-open": fe(f), style: { "--navbar-height": typeof p == "number" ? `${p}px` : p }, ...u, children: o }) : w.jsx(r$, { mode: "wait", children: f ? w.jsx(Ny, { features: c6, children: w.jsx(Ly.ul, { ref: c, layoutScroll: !0, animate: "enter", className: (r = d.menu) == null ? void 0 : r.call(d, { class: x }), "data-open": fe(f), exit: "exit", initial: "exit", style: { "--navbar-height": typeof p == "number" ? `${p}px` : p, ...l }, variants: u6, ...tt(a, u), children: o }) }) : null }); return w.jsx(IN, { portalContainer: s, children: g }) }); t2.displayName = "NextUI.NavbarMenu"; var d6 = t2, f6 = { visible: { y: 0, transition: { ease: Lx.easeOut } }, hidden: { y: "-100%", transition: { ease: Lx.easeIn } } }, p6 = typeof window < "u"; function Qx(e) { return p6 ? e ? { x: e.scrollLeft, y: e.scrollTop } : { x: window.scrollX, y: window.scrollY } : { x: 0, y: 0 } } var h6 = e => { const { elementRef: t, delay: n = 30, callback: r, isEnabled: i } = e, o = S.useRef(i ? Qx(t == null ? void 0 : t.current) : { x: 0, y: 0 }), s = S.useRef(null), a = S.useCallback(() => { const l = Qx(t == null ? void 0 : t.current); typeof r == "function" && r({ prevPos: o.current, currPos: l }), o.current = l, s.current = null }, [r, t]); return S.useEffect(() => { if (!i) return; const l = () => { n ? (s.current && clearTimeout(s.current), s.current = setTimeout(a, n)) : a() }, u = (t == null ? void 0 : t.current) || window; return u.addEventListener("scroll", l), () => { u.removeEventListener("scroll", l), s.current && (clearTimeout(s.current), s.current = null) } }, [t == null ? void 0 : t.current, n, a, i]), o.current }; function m6(e) { var t, n; const r = Yo(), [i, o] = ha(e, Ex.variantKeys), { ref: s, as: a, parentRef: l, height: u = "4rem", shouldHideOnScroll: c = !1, disableScrollHandler: d = !1, shouldBlockScroll: f = !0, onScrollPositionChange: p, isMenuOpen: m, isMenuDefaultOpen: v, onMenuOpenChange: x = () => { }, motionProps: g, className: h, classNames: y, ...E } = i, P = a || "nav", $ = (n = (t = e.disableAnimation) != null ? t : r == null ? void 0 : r.disableAnimation) != null ? n : !1, L = ht(s), b = S.useRef(0), M = S.useRef(0), [R, A] = S.useState(!1), _ = S.useCallback(H => { x(H || !1) }, [x]), [C, k] = kf(m, v ?? !1, _), O = () => { if (L.current) { const H = L.current.offsetWidth; H !== b.current && (b.current = H) } }; $N({ isDisabled: !(f && C) }), CL({ ref: L, onResize: () => { var H; const T = (H = L.current) == null ? void 0 : H.offsetWidth, N = window.innerWidth - document.documentElement.clientWidth; T && T + N == b.current || T !== b.current && (O(), k(!1)) } }), S.useEffect(() => { var H; O(), M.current = ((H = L.current) == null ? void 0 : H.offsetHeight) || 0 }, []); const U = S.useMemo(() => Ex({ ...o, disableAnimation: $, hideOnScroll: c }), [fa(o), $, c]), z = ke(y == null ? void 0 : y.base, h); return h6({ elementRef: l, isEnabled: c || !d, callback: ({ prevPos: H, currPos: T }) => { p == null || p(T.y), c && A(N => { const W = T.y > H.y && T.y > M.current; return W !== N ? W : N }) } }), { Component: P, slots: U, domRef: L, height: u, isHidden: R, disableAnimation: $, shouldHideOnScroll: c, isMenuOpen: C, classNames: y, setIsMenuOpen: k, motionProps: g, getBaseProps: (H = {}) => ({ ...tt(E, H), "data-hidden": fe(R), "data-menu-open": fe(C), ref: L, className: U.base({ class: ke(z, H == null ? void 0 : H.className) }), style: { "--navbar-height": typeof u == "number" ? `${u}px` : u, ...E == null ? void 0 : E.style, ...H == null ? void 0 : H.style } }), getWrapperProps: (H = {}) => ({ ...H, "data-menu-open": fe(C), className: U.wrapper({ class: ke(y == null ? void 0 : y.wrapper, H == null ? void 0 : H.className) }) }) } } var g6 = () => ga(() => import("./index-XqZGe4bn.js"), []).then(e => e.default), n2 = _t((e, t) => { const { children: n, ...r } = e, i = m6({ ...r, ref: t }), o = i.Component, [s, a] = OR(n, d6), l = w.jsxs(w.Fragment, { children: [w.jsx("header", { ...i.getWrapperProps(), children: s }), a] }); return w.jsx(l6, { value: i, children: i.shouldHideOnScroll ? w.jsx(Ny, { features: g6, children: w.jsx(Ly.nav, { animate: i.isHidden ? "hidden" : "visible", initial: !1, variants: f6, ...tt(i.getBaseProps(), i.motionProps), children: l }) }) : w.jsx(o, { ...i.getBaseProps(), children: l }) }) }); n2.displayName = "NextUI.Navbar"; var v6 = n2, r2 = _t((e, t) => { var n; const { as: r, className: i, children: o, ...s } = e, a = r || "div", l = ht(t), { slots: u, classNames: c } = Ru(), d = ke(c == null ? void 0 : c.brand, i); return w.jsx(a, { ref: l, className: (n = u.brand) == null ? void 0 : n.call(u, { class: d }), ...s, children: o }) }); r2.displayName = "NextUI.NavbarBrand"; var y6 = r2, i2 = _t((e, t) => { var n; const { as: r, className: i, children: o, justify: s = "start", ...a } = e, l = r || "ul", u = ht(t), { slots: c, classNames: d } = Ru(), f = ke(d == null ? void 0 : d.content, i); return w.jsx(l, { ref: u, className: (n = c.content) == null ? void 0 : n.call(c, { class: f }), "data-justify": s, ...a, children: o }) }); i2.displayName = "NextUI.NavbarContent"; var nh = i2, o2 = _t((e, t) => { var n; const { as: r, className: i, children: o, isActive: s, ...a } = e, l = r || "li", u = ht(t), { slots: c, classNames: d } = Ru(), f = ke(d == null ? void 0 : d.item, i); return w.jsx(l, { ref: u, className: (n = c.item) == null ? void 0 : n.call(c, { class: f }), "data-active": fe(s), ...a, children: o }) }); o2.displayName = "NextUI.NavbarItem"; var b6 = o2, s2 = _t((e, t) => { var n; const { as: r, icon: i, className: o, onChange: s, autoFocus: a, srOnlyText: l, ...u } = e, c = r || "button", d = ht(t), { slots: f, classNames: p, isMenuOpen: m, setIsMenuOpen: v } = Ru(), g = L5({ ...u, isSelected: m, onChange: A => { s == null || s(A), v(A) } }), { buttonProps: h, isPressed: y } = ID(e, g, d), { isFocusVisible: E, focusProps: P } = ri({ autoFocus: a }), { isHovered: $, hoverProps: L } = Bo({}), b = ke(p == null ? void 0 : p.toggle, o), M = S.useMemo(() => typeof i == "function" ? i(m ?? !1) : i || w.jsx("span", { className: f.toggleIcon({ class: p == null ? void 0 : p.toggleIcon }) }), [i, m, f.toggleIcon, p == null ? void 0 : p.toggleIcon]), R = S.useMemo(() => l || (g.isSelected ? "close navigation menu" : "open navigation menu"), [l, m]); return w.jsxs(c, { ref: d, className: (n = f.toggle) == null ? void 0 : n.call(f, { class: b }), "data-focus-visible": fe(E), "data-hover": fe($), "data-open": fe(m), "data-pressed": fe(y), ...tt(h, P, L, u), children: [w.jsx("span", { className: f.srOnly(), children: R }), M] }) }); s2.displayName = "NextUI.NavbarMenuToggle"; var w6 = s2; function x6(e) { var t, n; const r = Yo(), [i, o] = ha(e, xx.variantKeys), { as: s, children: a, isLoaded: l = !1, className: u, classNames: c, ...d } = i, f = s || "div", p = (n = (t = e.disableAnimation) != null ? t : r == null ? void 0 : r.disableAnimation) != null ? n : !1, m = S.useMemo(() => xx({ ...o, disableAnimation: p }), [fa(o), p, a]), v = ke(c == null ? void 0 : c.base, u); return { Component: f, children: a, slots: m, classNames: c, getSkeletonProps: (h = {}) => ({ "data-loaded": fe(l), className: m.base({ class: ke(v, h == null ? void 0 : h.className) }), ...d }), getContentProps: (h = {}) => ({ className: m.content({ class: ke(c == null ? void 0 : c.content, h == null ? void 0 : h.className) }) }) } } var a2 = _t((e, t) => { const { Component: n, children: r, getSkeletonProps: i, getContentProps: o } = x6({ ...e }); return w.jsx(n, { ref: t, ...i(), children: w.jsx("div", { ...o(), children: r }) }) }); a2.displayName = "NextUI.Skeleton"; var Sc = a2; function hg(e, t) { return hg = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (n, r) { return n.__proto__ = r, n }, hg(e, t) } function Vf(e, t) { e.prototype = Object.create(t.prototype), e.prototype.constructor = e, hg(e, t) } var Bf = function () { function e() { this.listeners = [] } var t = e.prototype; return t.subscribe = function (r) { var i = this, o = r || function () { }; return this.listeners.push(o), this.onSubscribe(), function () { i.listeners = i.listeners.filter(function (s) { return s !== o }), i.onUnsubscribe() } }, t.hasListeners = function () { return this.listeners.length > 0 }, t.onSubscribe = function () { }, t.onUnsubscribe = function () { }, e }(), l2 = typeof window > "u"; function sn() { } function S6(e, t) { return typeof e == "function" ? e(t) : e } function E6(e) { return typeof e == "number" && e >= 0 && e !== 1 / 0 } function Ud(e) { return Array.isArray(e) ? e : [e] } function T6(e, t) { return Math.max(e + (t || 0) - Date.now(), 0) } function rh(e, t, n) { return Uf(e) ? typeof t == "function" ? je({}, n, { queryKey: e, queryFn: t }) : je({}, t, { queryKey: e }) : e } function Si(e, t, n) { return Uf(e) ? [je({}, t, { queryKey: e }), n] : [e || {}, t] } function C6(e, t) { if (e === !0 && t === !0 || e == null && t == null) return "all"; if (e === !1 && t === !1) return "none"; var n = e ?? !t; return n ? "active" : "inactive" } function Xx(e, t) { var n = e.active, r = e.exact, i = e.fetching, o = e.inactive, s = e.predicate, a = e.queryKey, l = e.stale; if (Uf(a)) { if (r) { if (t.queryHash !== zy(a, t.options)) return !1 } else if (!Hd(t.queryKey, a)) return !1 } var u = C6(n, o); if (u === "none") return !1; if (u !== "all") { var c = t.isActive(); if (u === "active" && !c || u === "inactive" && c) return !1 } return !(typeof l == "boolean" && t.isStale() !== l || typeof i == "boolean" && t.isFetching() !== i || s && !s(t)) } function Jx(e, t) { var n = e.exact, r = e.fetching, i = e.predicate, o = e.mutationKey; if (Uf(o)) { if (!t.options.mutationKey) return !1; if (n) { if (So(t.options.mutationKey) !== So(o)) return !1 } else if (!Hd(t.options.mutationKey, o)) return !1 } return !(typeof r == "boolean" && t.state.status === "loading" !== r || i && !i(t)) } function zy(e, t) { var n = (t == null ? void 0 : t.queryKeyHashFn) || So; return n(e) } function So(e) { var t = Ud(e); return P6(t) } function P6(e) { return JSON.stringify(e, function (t, n) { return mg(n) ? Object.keys(n).sort().reduce(function (r, i) { return r[i] = n[i], r }, {}) : n }) } function Hd(e, t) { return u2(Ud(e), Ud(t)) } function u2(e, t) { return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? !Object.keys(t).some(function (n) { return !u2(e[n], t[n]) }) : !1 } function c2(e, t) { if (e === t) return e; var n = Array.isArray(e) && Array.isArray(t); if (n || mg(e) && mg(t)) { for (var r = n ? e.length : Object.keys(e).length, i = n ? t : Object.keys(t), o = i.length, s = n ? [] : {}, a = 0, l = 0; l < o; l++) { var u = n ? l : i[l]; s[u] = c2(e[u], t[u]), s[u] === e[u] && a++ } return r === o && a === r ? e : s } return t } function mg(e) { if (!Zx(e)) return !1; var t = e.constructor; if (typeof t > "u") return !0; var n = t.prototype; return !(!Zx(n) || !n.hasOwnProperty("isPrototypeOf")) } function Zx(e) { return Object.prototype.toString.call(e) === "[object Object]" } function Uf(e) { return typeof e == "string" || Array.isArray(e) } function $6(e) { return new Promise(function (t) { setTimeout(t, e) }) } function e1(e) { Promise.resolve().then(e).catch(function (t) { return setTimeout(function () { throw t }) }) } function d2() { if (typeof AbortController == "function") return new AbortController } var A6 = function (e) { Vf(t, e); function t() { var r; return r = e.call(this) || this, r.setup = function (i) { var o; if (!l2 && ((o = window) != null && o.addEventListener)) { var s = function () { return i() }; return window.addEventListener("visibilitychange", s, !1), window.addEventListener("focus", s, !1), function () { window.removeEventListener("visibilitychange", s), window.removeEventListener("focus", s) } } }, r } var n = t.prototype; return n.onSubscribe = function () { this.cleanup || this.setEventListener(this.setup) }, n.onUnsubscribe = function () { if (!this.hasListeners()) { var i; (i = this.cleanup) == null || i.call(this), this.cleanup = void 0 } }, n.setEventListener = function (i) { var o, s = this; this.setup = i, (o = this.cleanup) == null || o.call(this), this.cleanup = i(function (a) { typeof a == "boolean" ? s.setFocused(a) : s.onFocus() }) }, n.setFocused = function (i) { this.focused = i, i && this.onFocus() }, n.onFocus = function () { this.listeners.forEach(function (i) { i() }) }, n.isFocused = function () { return typeof this.focused == "boolean" ? this.focused : typeof document > "u" ? !0 : [void 0, "visible", "prerender"].includes(document.visibilityState) }, t }(Bf), Qc = new A6, M6 = function (e) { Vf(t, e); function t() { var r; return r = e.call(this) || this, r.setup = function (i) { var o; if (!l2 && ((o = window) != null && o.addEventListener)) { var s = function () { return i() }; return window.addEventListener("online", s, !1), window.addEventListener("offline", s, !1), function () { window.removeEventListener("online", s), window.removeEventListener("offline", s) } } }, r } var n = t.prototype; return n.onSubscribe = function () { this.cleanup || this.setEventListener(this.setup) }, n.onUnsubscribe = function () { if (!this.hasListeners()) { var i; (i = this.cleanup) == null || i.call(this), this.cleanup = void 0 } }, n.setEventListener = function (i) { var o, s = this; this.setup = i, (o = this.cleanup) == null || o.call(this), this.cleanup = i(function (a) { typeof a == "boolean" ? s.setOnline(a) : s.onOnline() }) }, n.setOnline = function (i) { this.online = i, i && this.onOnline() }, n.onOnline = function () { this.listeners.forEach(function (i) { i() }) }, n.isOnline = function () { return typeof this.online == "boolean" ? this.online : typeof navigator > "u" || typeof navigator.onLine > "u" ? !0 : navigator.onLine }, t }(Bf), Xc = new M6; function k6(e) { return Math.min(1e3 * Math.pow(2, e), 3e4) } function Wd(e) { return typeof (e == null ? void 0 : e.cancel) == "function" } var f2 = function (t) { this.revert = t == null ? void 0 : t.revert, this.silent = t == null ? void 0 : t.silent }; function ih(e) { return e instanceof f2 } var p2 = function (t) { var n = this, r = !1, i, o, s, a; this.abort = t.abort, this.cancel = function (f) { return i == null ? void 0 : i(f) }, this.cancelRetry = function () { r = !0 }, this.continueRetry = function () { r = !1 }, this.continue = function () { return o == null ? void 0 : o() }, this.failureCount = 0, this.isPaused = !1, this.isResolved = !1, this.isTransportCancelable = !1, this.promise = new Promise(function (f, p) { s = f, a = p }); var l = function (p) { n.isResolved || (n.isResolved = !0, t.onSuccess == null || t.onSuccess(p), o == null || o(), s(p)) }, u = function (p) { n.isResolved || (n.isResolved = !0, t.onError == null || t.onError(p), o == null || o(), a(p)) }, c = function () { return new Promise(function (p) { o = p, n.isPaused = !0, t.onPause == null || t.onPause() }).then(function () { o = void 0, n.isPaused = !1, t.onContinue == null || t.onContinue() }) }, d = function f() { if (!n.isResolved) { var p; try { p = t.fn() } catch (m) { p = Promise.reject(m) } i = function (v) { if (!n.isResolved && (u(new f2(v)), n.abort == null || n.abort(), Wd(p))) try { p.cancel() } catch { } }, n.isTransportCancelable = Wd(p), Promise.resolve(p).then(l).catch(function (m) { var v, x; if (!n.isResolved) { var g = (v = t.retry) != null ? v : 3, h = (x = t.retryDelay) != null ? x : k6, y = typeof h == "function" ? h(n.failureCount, m) : h, E = g === !0 || typeof g == "number" && n.failureCount < g || typeof g == "function" && g(n.failureCount, m); if (r || !E) { u(m); return } n.failureCount++, t.onFail == null || t.onFail(n.failureCount, m), $6(y).then(function () { if (!Qc.isFocused() || !Xc.isOnline()) return c() }).then(function () { r ? u(m) : f() }) } }) } }; d() }, _6 = function () { function e() { this.queue = [], this.transactions = 0, this.notifyFn = function (n) { n() }, this.batchNotifyFn = function (n) { n() } } var t = e.prototype; return t.batch = function (r) { var i; this.transactions++; try { i = r() } finally { this.transactions--, this.transactions || this.flush() } return i }, t.schedule = function (r) { var i = this; this.transactions ? this.queue.push(r) : e1(function () { i.notifyFn(r) }) }, t.batchCalls = function (r) { var i = this; return function () { for (var o = arguments.length, s = new Array(o), a = 0; a < o; a++)s[a] = arguments[a]; i.schedule(function () { r.apply(void 0, s) }) } }, t.flush = function () { var r = this, i = this.queue; this.queue = [], i.length && e1(function () { r.batchNotifyFn(function () { i.forEach(function (o) { r.notifyFn(o) }) }) }) }, t.setNotifyFunction = function (r) { this.notifyFn = r }, t.setBatchNotifyFunction = function (r) { this.batchNotifyFn = r }, e }(), zt = new _6, h2 = console; function m2() { return h2 } function R6(e) { h2 = e } var L6 = function () { function e(n) { this.abortSignalConsumed = !1, this.hadObservers = !1, this.defaultOptions = n.defaultOptions, this.setOptions(n.options), this.observers = [], this.cache = n.cache, this.queryKey = n.queryKey, this.queryHash = n.queryHash, this.initialState = n.state || this.getDefaultState(this.options), this.state = this.initialState, this.meta = n.meta, this.scheduleGc() } var t = e.prototype; return t.setOptions = function (r) { var i; this.options = je({}, this.defaultOptions, r), this.meta = r == null ? void 0 : r.meta, this.cacheTime = Math.max(this.cacheTime || 0, (i = this.options.cacheTime) != null ? i : 5 * 60 * 1e3) }, t.setDefaultOptions = function (r) { this.defaultOptions = r }, t.scheduleGc = function () { var r = this; this.clearGcTimeout(), E6(this.cacheTime) && (this.gcTimeout = setTimeout(function () { r.optionalRemove() }, this.cacheTime)) }, t.clearGcTimeout = function () { this.gcTimeout && (clearTimeout(this.gcTimeout), this.gcTimeout = void 0) }, t.optionalRemove = function () { this.observers.length || (this.state.isFetching ? this.hadObservers && this.scheduleGc() : this.cache.remove(this)) }, t.setData = function (r, i) { var o, s, a = this.state.data, l = S6(r, a); return (o = (s = this.options).isDataEqual) != null && o.call(s, a, l) ? l = a : this.options.structuralSharing !== !1 && (l = c2(a, l)), this.dispatch({ data: l, type: "success", dataUpdatedAt: i == null ? void 0 : i.updatedAt }), l }, t.setState = function (r, i) { this.dispatch({ type: "setState", state: r, setStateOptions: i }) }, t.cancel = function (r) { var i, o = this.promise; return (i = this.retryer) == null || i.cancel(r), o ? o.then(sn).catch(sn) : Promise.resolve() }, t.destroy = function () { this.clearGcTimeout(), this.cancel({ silent: !0 }) }, t.reset = function () { this.destroy(), this.setState(this.initialState) }, t.isActive = function () { return this.observers.some(function (r) { return r.options.enabled !== !1 }) }, t.isFetching = function () { return this.state.isFetching }, t.isStale = function () { return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(function (r) { return r.getCurrentResult().isStale }) }, t.isStaleByTime = function (r) { return r === void 0 && (r = 0), this.state.isInvalidated || !this.state.dataUpdatedAt || !T6(this.state.dataUpdatedAt, r) }, t.onFocus = function () { var r, i = this.observers.find(function (o) { return o.shouldFetchOnWindowFocus() }); i && i.refetch(), (r = this.retryer) == null || r.continue() }, t.onOnline = function () { var r, i = this.observers.find(function (o) { return o.shouldFetchOnReconnect() }); i && i.refetch(), (r = this.retryer) == null || r.continue() }, t.addObserver = function (r) { this.observers.indexOf(r) === -1 && (this.observers.push(r), this.hadObservers = !0, this.clearGcTimeout(), this.cache.notify({ type: "observerAdded", query: this, observer: r })) }, t.removeObserver = function (r) { this.observers.indexOf(r) !== -1 && (this.observers = this.observers.filter(function (i) { return i !== r }), this.observers.length || (this.retryer && (this.retryer.isTransportCancelable || this.abortSignalConsumed ? this.retryer.cancel({ revert: !0 }) : this.retryer.cancelRetry()), this.cacheTime ? this.scheduleGc() : this.cache.remove(this)), this.cache.notify({ type: "observerRemoved", query: this, observer: r })) }, t.getObserversCount = function () { return this.observers.length }, t.invalidate = function () { this.state.isInvalidated || this.dispatch({ type: "invalidate" }) }, t.fetch = function (r, i) { var o = this, s, a, l; if (this.state.isFetching) { if (this.state.dataUpdatedAt && (i != null && i.cancelRefetch)) this.cancel({ silent: !0 }); else if (this.promise) { var u; return (u = this.retryer) == null || u.continueRetry(), this.promise } } if (r && this.setOptions(r), !this.options.queryFn) { var c = this.observers.find(function (h) { return h.options.queryFn }); c && this.setOptions(c.options) } var d = Ud(this.queryKey), f = d2(), p = { queryKey: d, pageParam: void 0, meta: this.meta }; Object.defineProperty(p, "signal", { enumerable: !0, get: function () { if (f) return o.abortSignalConsumed = !0, f.signal } }); var m = function () { return o.options.queryFn ? (o.abortSignalConsumed = !1, o.options.queryFn(p)) : Promise.reject("Missing queryFn") }, v = { fetchOptions: i, options: this.options, queryKey: d, state: this.state, fetchFn: m, meta: this.meta }; if ((s = this.options.behavior) != null && s.onFetch) { var x; (x = this.options.behavior) == null || x.onFetch(v) } if (this.revertState = this.state, !this.state.isFetching || this.state.fetchMeta !== ((a = v.fetchOptions) == null ? void 0 : a.meta)) { var g; this.dispatch({ type: "fetch", meta: (g = v.fetchOptions) == null ? void 0 : g.meta }) } return this.retryer = new p2({ fn: v.fetchFn, abort: f == null || (l = f.abort) == null ? void 0 : l.bind(f), onSuccess: function (y) { o.setData(y), o.cache.config.onSuccess == null || o.cache.config.onSuccess(y, o), o.cacheTime === 0 && o.optionalRemove() }, onError: function (y) { ih(y) && y.silent || o.dispatch({ type: "error", error: y }), ih(y) || (o.cache.config.onError == null || o.cache.config.onError(y, o), m2().error(y)), o.cacheTime === 0 && o.optionalRemove() }, onFail: function () { o.dispatch({ type: "failed" }) }, onPause: function () { o.dispatch({ type: "pause" }) }, onContinue: function () { o.dispatch({ type: "continue" }) }, retry: v.options.retry, retryDelay: v.options.retryDelay }), this.promise = this.retryer.promise, this.promise }, t.dispatch = function (r) { var i = this; this.state = this.reducer(this.state, r), zt.batch(function () { i.observers.forEach(function (o) { o.onQueryUpdate(r) }), i.cache.notify({ query: i, type: "queryUpdated", action: r }) }) }, t.getDefaultState = function (r) { var i = typeof r.initialData == "function" ? r.initialData() : r.initialData, o = typeof r.initialData < "u", s = o ? typeof r.initialDataUpdatedAt == "function" ? r.initialDataUpdatedAt() : r.initialDataUpdatedAt : 0, a = typeof i < "u"; return { data: i, dataUpdateCount: 0, dataUpdatedAt: a ? s ?? Date.now() : 0, error: null, errorUpdateCount: 0, errorUpdatedAt: 0, fetchFailureCount: 0, fetchMeta: null, isFetching: !1, isInvalidated: !1, isPaused: !1, status: a ? "success" : "idle" } }, t.reducer = function (r, i) { var o, s; switch (i.type) { case "failed": return je({}, r, { fetchFailureCount: r.fetchFailureCount + 1 }); case "pause": return je({}, r, { isPaused: !0 }); case "continue": return je({}, r, { isPaused: !1 }); case "fetch": return je({}, r, { fetchFailureCount: 0, fetchMeta: (o = i.meta) != null ? o : null, isFetching: !0, isPaused: !1 }, !r.dataUpdatedAt && { error: null, status: "loading" }); case "success": return je({}, r, { data: i.data, dataUpdateCount: r.dataUpdateCount + 1, dataUpdatedAt: (s = i.dataUpdatedAt) != null ? s : Date.now(), error: null, fetchFailureCount: 0, isFetching: !1, isInvalidated: !1, isPaused: !1, status: "success" }); case "error": var a = i.error; return ih(a) && a.revert && this.revertState ? je({}, this.revertState) : je({}, r, { error: a, errorUpdateCount: r.errorUpdateCount + 1, errorUpdatedAt: Date.now(), fetchFailureCount: r.fetchFailureCount + 1, isFetching: !1, isPaused: !1, status: "error" }); case "invalidate": return je({}, r, { isInvalidated: !0 }); case "setState": return je({}, r, i.state); default: return r } }, e }(), N6 = function (e) { Vf(t, e); function t(r) { var i; return i = e.call(this) || this, i.config = r || {}, i.queries = [], i.queriesMap = {}, i } var n = t.prototype; return n.build = function (i, o, s) { var a, l = o.queryKey, u = (a = o.queryHash) != null ? a : zy(l, o), c = this.get(u); return c || (c = new L6({ cache: this, queryKey: l, queryHash: u, options: i.defaultQueryOptions(o), state: s, defaultOptions: i.getQueryDefaults(l), meta: o.meta }), this.add(c)), c }, n.add = function (i) { this.queriesMap[i.queryHash] || (this.queriesMap[i.queryHash] = i, this.queries.push(i), this.notify({ type: "queryAdded", query: i })) }, n.remove = function (i) { var o = this.queriesMap[i.queryHash]; o && (i.destroy(), this.queries = this.queries.filter(function (s) { return s !== i }), o === i && delete this.queriesMap[i.queryHash], this.notify({ type: "queryRemoved", query: i })) }, n.clear = function () { var i = this; zt.batch(function () { i.queries.forEach(function (o) { i.remove(o) }) }) }, n.get = function (i) { return this.queriesMap[i] }, n.getAll = function () { return this.queries }, n.find = function (i, o) { var s = Si(i, o), a = s[0]; return typeof a.exact > "u" && (a.exact = !0), this.queries.find(function (l) { return Xx(a, l) }) }, n.findAll = function (i, o) { var s = Si(i, o), a = s[0]; return Object.keys(a).length > 0 ? this.queries.filter(function (l) { return Xx(a, l) }) : this.queries }, n.notify = function (i) { var o = this; zt.batch(function () { o.listeners.forEach(function (s) { s(i) }) }) }, n.onFocus = function () { var i = this; zt.batch(function () { i.queries.forEach(function (o) { o.onFocus() }) }) }, n.onOnline = function () { var i = this; zt.batch(function () { i.queries.forEach(function (o) { o.onOnline() }) }) }, t }(Bf), O6 = function () { function e(n) { this.options = je({}, n.defaultOptions, n.options), this.mutationId = n.mutationId, this.mutationCache = n.mutationCache, this.observers = [], this.state = n.state || j6(), this.meta = n.meta } var t = e.prototype; return t.setState = function (r) { this.dispatch({ type: "setState", state: r }) }, t.addObserver = function (r) { this.observers.indexOf(r) === -1 && this.observers.push(r) }, t.removeObserver = function (r) { this.observers = this.observers.filter(function (i) { return i !== r }) }, t.cancel = function () { return this.retryer ? (this.retryer.cancel(), this.retryer.promise.then(sn).catch(sn)) : Promise.resolve() }, t.continue = function () { return this.retryer ? (this.retryer.continue(), this.retryer.promise) : this.execute() }, t.execute = function () { var r = this, i, o = this.state.status === "loading", s = Promise.resolve(); return o || (this.dispatch({ type: "loading", variables: this.options.variables }), s = s.then(function () { r.mutationCache.config.onMutate == null || r.mutationCache.config.onMutate(r.state.variables, r) }).then(function () { return r.options.onMutate == null ? void 0 : r.options.onMutate(r.state.variables) }).then(function (a) { a !== r.state.context && r.dispatch({ type: "loading", context: a, variables: r.state.variables }) })), s.then(function () { return r.executeMutation() }).then(function (a) { i = a, r.mutationCache.config.onSuccess == null || r.mutationCache.config.onSuccess(i, r.state.variables, r.state.context, r) }).then(function () { return r.options.onSuccess == null ? void 0 : r.options.onSuccess(i, r.state.variables, r.state.context) }).then(function () { return r.options.onSettled == null ? void 0 : r.options.onSettled(i, null, r.state.variables, r.state.context) }).then(function () { return r.dispatch({ type: "success", data: i }), i }).catch(function (a) { return r.mutationCache.config.onError == null || r.mutationCache.config.onError(a, r.state.variables, r.state.context, r), m2().error(a), Promise.resolve().then(function () { return r.options.onError == null ? void 0 : r.options.onError(a, r.state.variables, r.state.context) }).then(function () { return r.options.onSettled == null ? void 0 : r.options.onSettled(void 0, a, r.state.variables, r.state.context) }).then(function () { throw r.dispatch({ type: "error", error: a }), a }) }) }, t.executeMutation = function () { var r = this, i; return this.retryer = new p2({ fn: function () { return r.options.mutationFn ? r.options.mutationFn(r.state.variables) : Promise.reject("No mutationFn found") }, onFail: function () { r.dispatch({ type: "failed" }) }, onPause: function () { r.dispatch({ type: "pause" }) }, onContinue: function () { r.dispatch({ type: "continue" }) }, retry: (i = this.options.retry) != null ? i : 0, retryDelay: this.options.retryDelay }), this.retryer.promise }, t.dispatch = function (r) { var i = this; this.state = I6(this.state, r), zt.batch(function () { i.observers.forEach(function (o) { o.onMutationUpdate(r) }), i.mutationCache.notify(i) }) }, e }(); function j6() { return { context: void 0, data: void 0, error: null, failureCount: 0, isPaused: !1, status: "idle", variables: void 0 } } function I6(e, t) { switch (t.type) { case "failed": return je({}, e, { failureCount: e.failureCount + 1 }); case "pause": return je({}, e, { isPaused: !0 }); case "continue": return je({}, e, { isPaused: !1 }); case "loading": return je({}, e, { context: t.context, data: void 0, error: null, isPaused: !1, status: "loading", variables: t.variables }); case "success": return je({}, e, { data: t.data, error: null, status: "success", isPaused: !1 }); case "error": return je({}, e, { data: void 0, error: t.error, failureCount: e.failureCount + 1, isPaused: !1, status: "error" }); case "setState": return je({}, e, t.state); default: return e } } var D6 = function (e) { Vf(t, e); function t(r) { var i; return i = e.call(this) || this, i.config = r || {}, i.mutations = [], i.mutationId = 0, i } var n = t.prototype; return n.build = function (i, o, s) { var a = new O6({ mutationCache: this, mutationId: ++this.mutationId, options: i.defaultMutationOptions(o), state: s, defaultOptions: o.mutationKey ? i.getMutationDefaults(o.mutationKey) : void 0, meta: o.meta }); return this.add(a), a }, n.add = function (i) { this.mutations.push(i), this.notify(i) }, n.remove = function (i) { this.mutations = this.mutations.filter(function (o) { return o !== i }), i.cancel(), this.notify(i) }, n.clear = function () { var i = this; zt.batch(function () { i.mutations.forEach(function (o) { i.remove(o) }) }) }, n.getAll = function () { return this.mutations }, n.find = function (i) { return typeof i.exact > "u" && (i.exact = !0), this.mutations.find(function (o) { return Jx(i, o) }) }, n.findAll = function (i) { return this.mutations.filter(function (o) { return Jx(i, o) }) }, n.notify = function (i) { var o = this; zt.batch(function () { o.listeners.forEach(function (s) { s(i) }) }) }, n.onFocus = function () { this.resumePausedMutations() }, n.onOnline = function () { this.resumePausedMutations() }, n.resumePausedMutations = function () { var i = this.mutations.filter(function (o) { return o.state.isPaused }); return zt.batch(function () { return i.reduce(function (o, s) { return o.then(function () { return s.continue().catch(sn) }) }, Promise.resolve()) }) }, t }(Bf); function F6() { return { onFetch: function (t) { t.fetchFn = function () { var n, r, i, o, s, a, l = (n = t.fetchOptions) == null || (r = n.meta) == null ? void 0 : r.refetchPage, u = (i = t.fetchOptions) == null || (o = i.meta) == null ? void 0 : o.fetchMore, c = u == null ? void 0 : u.pageParam, d = (u == null ? void 0 : u.direction) === "forward", f = (u == null ? void 0 : u.direction) === "backward", p = ((s = t.state.data) == null ? void 0 : s.pages) || [], m = ((a = t.state.data) == null ? void 0 : a.pageParams) || [], v = d2(), x = v == null ? void 0 : v.signal, g = m, h = !1, y = t.options.queryFn || function () { return Promise.reject("Missing queryFn") }, E = function (k, O, U, z) { return g = z ? [O].concat(g) : [].concat(g, [O]), z ? [U].concat(k) : [].concat(k, [U]) }, P = function (k, O, U, z) { if (h) return Promise.reject("Cancelled"); if (typeof U > "u" && !O && k.length) return Promise.resolve(k); var D = { queryKey: t.queryKey, signal: x, pageParam: U, meta: t.meta }, V = y(D), H = Promise.resolve(V).then(function (N) { return E(k, U, N, z) }); if (Wd(V)) { var T = H; T.cancel = V.cancel } return H }, $; if (!p.length) $ = P([]); else if (d) { var L = typeof c < "u", b = L ? c : t1(t.options, p); $ = P(p, L, b) } else if (f) { var M = typeof c < "u", R = M ? c : z6(t.options, p); $ = P(p, M, R, !0) } else (function () { g = []; var C = typeof t.options.getNextPageParam > "u", k = l && p[0] ? l(p[0], 0, p) : !0; $ = k ? P([], C, m[0]) : Promise.resolve(E([], m[0], p[0])); for (var O = function (D) { $ = $.then(function (V) { var H = l && p[D] ? l(p[D], D, p) : !0; if (H) { var T = C ? m[D] : t1(t.options, V); return P(V, C, T) } return Promise.resolve(E(V, m[D], p[D])) }) }, U = 1; U < p.length; U++)O(U) })(); var A = $.then(function (C) { return { pages: C, pageParams: g } }), _ = A; return _.cancel = function () { h = !0, v == null || v.abort(), Wd($) && $.cancel() }, A } } } } function t1(e, t) { return e.getNextPageParam == null ? void 0 : e.getNextPageParam(t[t.length - 1], t) } function z6(e, t) { return e.getPreviousPageParam == null ? void 0 : e.getPreviousPageParam(t[0], t) } var g2 = function () { function e(n) { n === void 0 && (n = {}), this.queryCache = n.queryCache || new N6, this.mutationCache = n.mutationCache || new D6, this.defaultOptions = n.defaultOptions || {}, this.queryDefaults = [], this.mutationDefaults = [] } var t = e.prototype; return t.mount = function () { var r = this; this.unsubscribeFocus = Qc.subscribe(function () { Qc.isFocused() && Xc.isOnline() && (r.mutationCache.onFocus(), r.queryCache.onFocus()) }), this.unsubscribeOnline = Xc.subscribe(function () { Qc.isFocused() && Xc.isOnline() && (r.mutationCache.onOnline(), r.queryCache.onOnline()) }) }, t.unmount = function () { var r, i; (r = this.unsubscribeFocus) == null || r.call(this), (i = this.unsubscribeOnline) == null || i.call(this) }, t.isFetching = function (r, i) { var o = Si(r, i), s = o[0]; return s.fetching = !0, this.queryCache.findAll(s).length }, t.isMutating = function (r) { return this.mutationCache.findAll(je({}, r, { fetching: !0 })).length }, t.getQueryData = function (r, i) { var o; return (o = this.queryCache.find(r, i)) == null ? void 0 : o.state.data }, t.getQueriesData = function (r) { return this.getQueryCache().findAll(r).map(function (i) { var o = i.queryKey, s = i.state, a = s.data; return [o, a] }) }, t.setQueryData = function (r, i, o) { var s = rh(r), a = this.defaultQueryOptions(s); return this.queryCache.build(this, a).setData(i, o) }, t.setQueriesData = function (r, i, o) { var s = this; return zt.batch(function () { return s.getQueryCache().findAll(r).map(function (a) { var l = a.queryKey; return [l, s.setQueryData(l, i, o)] }) }) }, t.getQueryState = function (r, i) { var o; return (o = this.queryCache.find(r, i)) == null ? void 0 : o.state }, t.removeQueries = function (r, i) { var o = Si(r, i), s = o[0], a = this.queryCache; zt.batch(function () { a.findAll(s).forEach(function (l) { a.remove(l) }) }) }, t.resetQueries = function (r, i, o) { var s = this, a = Si(r, i, o), l = a[0], u = a[1], c = this.queryCache, d = je({}, l, { active: !0 }); return zt.batch(function () { return c.findAll(l).forEach(function (f) { f.reset() }), s.refetchQueries(d, u) }) }, t.cancelQueries = function (r, i, o) { var s = this, a = Si(r, i, o), l = a[0], u = a[1], c = u === void 0 ? {} : u; typeof c.revert > "u" && (c.revert = !0); var d = zt.batch(function () { return s.queryCache.findAll(l).map(function (f) { return f.cancel(c) }) }); return Promise.all(d).then(sn).catch(sn) }, t.invalidateQueries = function (r, i, o) { var s, a, l, u = this, c = Si(r, i, o), d = c[0], f = c[1], p = je({}, d, { active: (s = (a = d.refetchActive) != null ? a : d.active) != null ? s : !0, inactive: (l = d.refetchInactive) != null ? l : !1 }); return zt.batch(function () { return u.queryCache.findAll(d).forEach(function (m) { m.invalidate() }), u.refetchQueries(p, f) }) }, t.refetchQueries = function (r, i, o) { var s = this, a = Si(r, i, o), l = a[0], u = a[1], c = zt.batch(function () { return s.queryCache.findAll(l).map(function (f) { return f.fetch(void 0, je({}, u, { meta: { refetchPage: l == null ? void 0 : l.refetchPage } })) }) }), d = Promise.all(c).then(sn); return u != null && u.throwOnError || (d = d.catch(sn)), d }, t.fetchQuery = function (r, i, o) { var s = rh(r, i, o), a = this.defaultQueryOptions(s); typeof a.retry > "u" && (a.retry = !1); var l = this.queryCache.build(this, a); return l.isStaleByTime(a.staleTime) ? l.fetch(a) : Promise.resolve(l.state.data) }, t.prefetchQuery = function (r, i, o) { return this.fetchQuery(r, i, o).then(sn).catch(sn) }, t.fetchInfiniteQuery = function (r, i, o) { var s = rh(r, i, o); return s.behavior = F6(), this.fetchQuery(s) }, t.prefetchInfiniteQuery = function (r, i, o) { return this.fetchInfiniteQuery(r, i, o).then(sn).catch(sn) }, t.cancelMutations = function () { var r = this, i = zt.batch(function () { return r.mutationCache.getAll().map(function (o) { return o.cancel() }) }); return Promise.all(i).then(sn).catch(sn) }, t.resumePausedMutations = function () { return this.getMutationCache().resumePausedMutations() }, t.executeMutation = function (r) { return this.mutationCache.build(this, r).execute() }, t.getQueryCache = function () { return this.queryCache }, t.getMutationCache = function () { return this.mutationCache }, t.getDefaultOptions = function () { return this.defaultOptions }, t.setDefaultOptions = function (r) { this.defaultOptions = r }, t.setQueryDefaults = function (r, i) { var o = this.queryDefaults.find(function (s) { return So(r) === So(s.queryKey) }); o ? o.defaultOptions = i : this.queryDefaults.push({ queryKey: r, defaultOptions: i }) }, t.getQueryDefaults = function (r) { var i; return r ? (i = this.queryDefaults.find(function (o) { return Hd(r, o.queryKey) })) == null ? void 0 : i.defaultOptions : void 0 }, t.setMutationDefaults = function (r, i) { var o = this.mutationDefaults.find(function (s) { return So(r) === So(s.mutationKey) }); o ? o.defaultOptions = i : this.mutationDefaults.push({ mutationKey: r, defaultOptions: i }) }, t.getMutationDefaults = function (r) { var i; return r ? (i = this.mutationDefaults.find(function (o) { return Hd(r, o.mutationKey) })) == null ? void 0 : i.defaultOptions : void 0 }, t.defaultQueryOptions = function (r) { if (r != null && r._defaulted) return r; var i = je({}, this.defaultOptions.queries, this.getQueryDefaults(r == null ? void 0 : r.queryKey), r, { _defaulted: !0 }); return !i.queryHash && i.queryKey && (i.queryHash = zy(i.queryKey, i)), i }, t.defaultQueryObserverOptions = function (r) { return this.defaultQueryOptions(r) }, t.defaultMutationOptions = function (r) { return r != null && r._defaulted ? r : je({}, this.defaultOptions.mutations, this.getMutationDefaults(r == null ? void 0 : r.mutationKey), r, { _defaulted: !0 }) }, t.clear = function () { this.queryCache.clear(), this.mutationCache.clear() }, e }(), V6 = FT.unstable_batchedUpdates; zt.setBatchNotifyFunction(V6); var B6 = console; R6(B6); var n1 = se.createContext(void 0), U6 = se.createContext(!1); function H6(e) { return e && typeof window < "u" ? (window.ReactQueryClientContext || (window.ReactQueryClientContext = n1), window.ReactQueryClientContext) : n1 } var v2 = function (t) { var n = t.client, r = t.contextSharing, i = r === void 0 ? !1 : r, o = t.children; se.useEffect(function () { return n.mount(), function () { n.unmount() } }, [n]); var s = H6(i); return se.createElement(U6.Provider, { value: i }, se.createElement(s.Provider, { value: n }, o)) };/**
 * @remix-run/router v1.21.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Qe() { return Qe = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, Qe.apply(this, arguments) } var Et; (function (e) { e.Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE" })(Et || (Et = {})); const r1 = "popstate"; function W6(e) { e === void 0 && (e = {}); function t(r, i) { let { pathname: o, search: s, hash: a } = r.location; return nu("", { pathname: o, search: s, hash: a }, i.state && i.state.usr || null, i.state && i.state.key || "default") } function n(r, i) { return typeof i == "string" ? i : Uo(i) } return K6(t, n, null, e) } function Te(e, t) { if (e === !1 || e === null || typeof e > "u") throw new Error(t) } function la(e, t) { if (!e) { typeof console < "u" && console.warn(t); try { throw new Error(t) } catch { } } } function G6() { return Math.random().toString(36).substr(2, 8) } function i1(e, t) { return { usr: e.state, key: e.key, idx: t } } function nu(e, t, n, r) { return n === void 0 && (n = null), Qe({ pathname: typeof e == "string" ? e : e.pathname, search: "", hash: "" }, typeof t == "string" ? no(t) : t, { state: n, key: t && t.key || r || G6() }) } function Uo(e) { let { pathname: t = "/", search: n = "", hash: r = "" } = e; return n && n !== "?" && (t += n.charAt(0) === "?" ? n : "?" + n), r && r !== "#" && (t += r.charAt(0) === "#" ? r : "#" + r), t } function no(e) { let t = {}; if (e) { let n = e.indexOf("#"); n >= 0 && (t.hash = e.substr(n), e = e.substr(0, n)); let r = e.indexOf("?"); r >= 0 && (t.search = e.substr(r), e = e.substr(0, r)), e && (t.pathname = e) } return t } function K6(e, t, n, r) { r === void 0 && (r = {}); let { window: i = document.defaultView, v5Compat: o = !1 } = r, s = i.history, a = Et.Pop, l = null, u = c(); u == null && (u = 0, s.replaceState(Qe({}, s.state, { idx: u }), "")); function c() { return (s.state || { idx: null }).idx } function d() { a = Et.Pop; let x = c(), g = x == null ? null : x - u; u = x, l && l({ action: a, location: v.location, delta: g }) } function f(x, g) { a = Et.Push; let h = nu(v.location, x, g); u = c() + 1; let y = i1(h, u), E = v.createHref(h); try { s.pushState(y, "", E) } catch (P) { if (P instanceof DOMException && P.name === "DataCloneError") throw P; i.location.assign(E) } o && l && l({ action: a, location: v.location, delta: 1 }) } function p(x, g) { a = Et.Replace; let h = nu(v.location, x, g); u = c(); let y = i1(h, u), E = v.createHref(h); s.replaceState(y, "", E), o && l && l({ action: a, location: v.location, delta: 0 }) } function m(x) { let g = i.location.origin !== "null" ? i.location.origin : i.location.href, h = typeof x == "string" ? x : Uo(x); return h = h.replace(/ $/, "%20"), Te(g, "No window.location.(origin|href) available to create URL for href: " + h), new URL(h, g) } let v = { get action() { return a }, get location() { return e(i, s) }, listen(x) { if (l) throw new Error("A history only accepts one active listener"); return i.addEventListener(r1, d), l = x, () => { i.removeEventListener(r1, d), l = null } }, createHref(x) { return t(i, x) }, createURL: m, encodeLocation(x) { let g = m(x); return { pathname: g.pathname, search: g.search, hash: g.hash } }, push: f, replace: p, go(x) { return s.go(x) } }; return v } var Fe; (function (e) { e.data = "data", e.deferred = "deferred", e.redirect = "redirect", e.error = "error" })(Fe || (Fe = {})); const q6 = new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]); function Y6(e) { return e.index === !0 } function Gd(e, t, n, r) { return n === void 0 && (n = []), r === void 0 && (r = {}), e.map((i, o) => { let s = [...n, String(o)], a = typeof i.id == "string" ? i.id : s.join("-"); if (Te(i.index !== !0 || !i.children, "Cannot specify children on an index route"), Te(!r[a], 'Found a route id collision on id "' + a + `".  Route id's must be globally unique within Data Router usages`), Y6(i)) { let l = Qe({}, i, t(i), { id: a }); return r[a] = l, l } else { let l = Qe({}, i, t(i), { id: a, children: void 0 }); return r[a] = l, i.children && (l.children = Gd(i.children, t, s, r)), l } }) } function po(e, t, n) { return n === void 0 && (n = "/"), Jc(e, t, n, !1) } function Jc(e, t, n, r) { let i = typeof t == "string" ? no(t) : t, o = va(i.pathname || "/", n); if (o == null) return null; let s = y2(e); X6(s); let a = null; for (let l = 0; a == null && l < s.length; ++l) { let u = lF(o); a = sF(s[l], u, r) } return a } function Q6(e, t) { let { route: n, pathname: r, params: i } = e; return { id: n.id, pathname: r, params: i, data: t[n.id], handle: n.handle } } function y2(e, t, n, r) { t === void 0 && (t = []), n === void 0 && (n = []), r === void 0 && (r = ""); let i = (o, s, a) => { let l = { relativePath: a === void 0 ? o.path || "" : a, caseSensitive: o.caseSensitive === !0, childrenIndex: s, route: o }; l.relativePath.startsWith("/") && (Te(l.relativePath.startsWith(r), 'Absolute route path "' + l.relativePath + '" nested under path ' + ('"' + r + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), l.relativePath = l.relativePath.slice(r.length)); let u = Xr([r, l.relativePath]), c = n.concat(l); o.children && o.children.length > 0 && (Te(o.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + u + '".')), y2(o.children, t, c, u)), !(o.path == null && !o.index) && t.push({ path: u, score: iF(u, o.index), routesMeta: c }) }; return e.forEach((o, s) => { var a; if (o.path === "" || !((a = o.path) != null && a.includes("?"))) i(o, s); else for (let l of b2(o.path)) i(o, s, l) }), t } function b2(e) { let t = e.split("/"); if (t.length === 0) return []; let [n, ...r] = t, i = n.endsWith("?"), o = n.replace(/\?$/, ""); if (r.length === 0) return i ? [o, ""] : [o]; let s = b2(r.join("/")), a = []; return a.push(...s.map(l => l === "" ? o : [o, l].join("/"))), i && a.push(...s), a.map(l => e.startsWith("/") && l === "" ? "/" : l) } function X6(e) { e.sort((t, n) => t.score !== n.score ? n.score - t.score : oF(t.routesMeta.map(r => r.childrenIndex), n.routesMeta.map(r => r.childrenIndex))) } const J6 = /^:[\w-]+$/, Z6 = 3, eF = 2, tF = 1, nF = 10, rF = -2, o1 = e => e === "*"; function iF(e, t) { let n = e.split("/"), r = n.length; return n.some(o1) && (r += rF), t && (r += eF), n.filter(i => !o1(i)).reduce((i, o) => i + (J6.test(o) ? Z6 : o === "" ? tF : nF), r) } function oF(e, t) { return e.length === t.length && e.slice(0, -1).every((r, i) => r === t[i]) ? e[e.length - 1] - t[t.length - 1] : 0 } function sF(e, t, n) { n === void 0 && (n = !1); let { routesMeta: r } = e, i = {}, o = "/", s = []; for (let a = 0; a < r.length; ++a) { let l = r[a], u = a === r.length - 1, c = o === "/" ? t : t.slice(o.length) || "/", d = s1({ path: l.relativePath, caseSensitive: l.caseSensitive, end: u }, c), f = l.route; if (!d && u && n && !r[r.length - 1].route.index && (d = s1({ path: l.relativePath, caseSensitive: l.caseSensitive, end: !1 }, c)), !d) return null; Object.assign(i, d.params), s.push({ params: i, pathname: Xr([o, d.pathname]), pathnameBase: dF(Xr([o, d.pathnameBase])), route: f }), d.pathnameBase !== "/" && (o = Xr([o, d.pathnameBase])) } return s } function s1(e, t) { typeof e == "string" && (e = { path: e, caseSensitive: !1, end: !0 }); let [n, r] = aF(e.path, e.caseSensitive, e.end), i = t.match(n); if (!i) return null; let o = i[0], s = o.replace(/(.)\/+$/, "$1"), a = i.slice(1); return { params: r.reduce((u, c, d) => { let { paramName: f, isOptional: p } = c; if (f === "*") { let v = a[d] || ""; s = o.slice(0, o.length - v.length).replace(/(.)\/+$/, "$1") } const m = a[d]; return p && !m ? u[f] = void 0 : u[f] = (m || "").replace(/%2F/g, "/"), u }, {}), pathname: o, pathnameBase: s, pattern: e } } function aF(e, t, n) { t === void 0 && (t = !1), n === void 0 && (n = !0), la(e === "*" || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were ' + ('"' + e.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + e.replace(/\*$/, "/*") + '".')); let r = [], i = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (s, a, l) => (r.push({ paramName: a, isOptional: l != null }), l ? "/?([^\\/]+)?" : "/([^\\/]+)")); return e.endsWith("*") ? (r.push({ paramName: "*" }), i += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : e !== "" && e !== "/" && (i += "(?:(?=\\/|$))"), [new RegExp(i, t ? void 0 : "i"), r] } function lF(e) { try { return e.split("/").map(t => decodeURIComponent(t).replace(/\//g, "%2F")).join("/") } catch (t) { return la(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + t + ").")), e } } function va(e, t) { if (t === "/") return e; if (!e.toLowerCase().startsWith(t.toLowerCase())) return null; let n = t.endsWith("/") ? t.length - 1 : t.length, r = e.charAt(n); return r && r !== "/" ? null : e.slice(n) || "/" } function uF(e, t) { t === void 0 && (t = "/"); let { pathname: n, search: r = "", hash: i = "" } = typeof e == "string" ? no(e) : e; return { pathname: n ? n.startsWith("/") ? n : cF(n, t) : t, search: fF(r), hash: pF(i) } } function cF(e, t) { let n = t.replace(/\/+$/, "").split("/"); return e.split("/").forEach(i => { i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i) }), n.length > 1 ? n.join("/") : "/" } function oh(e, t, n, r) { return "Cannot include a '" + e + "' character in a manually specified " + ("`to." + t + "` field [" + JSON.stringify(r) + "].  Please separate it out to the ") + ("`to." + n + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.' } function w2(e) { return e.filter((t, n) => n === 0 || t.route.path && t.route.path.length > 0) } function Hf(e, t) { let n = w2(e); return t ? n.map((r, i) => i === n.length - 1 ? r.pathname : r.pathnameBase) : n.map(r => r.pathnameBase) } function Wf(e, t, n, r) { r === void 0 && (r = !1); let i; typeof e == "string" ? i = no(e) : (i = Qe({}, e), Te(!i.pathname || !i.pathname.includes("?"), oh("?", "pathname", "search", i)), Te(!i.pathname || !i.pathname.includes("#"), oh("#", "pathname", "hash", i)), Te(!i.search || !i.search.includes("#"), oh("#", "search", "hash", i))); let o = e === "" || i.pathname === "", s = o ? "/" : i.pathname, a; if (s == null) a = n; else { let d = t.length - 1; if (!r && s.startsWith("..")) { let f = s.split("/"); for (; f[0] === "..";)f.shift(), d -= 1; i.pathname = f.join("/") } a = d >= 0 ? t[d] : "/" } let l = uF(i, a), u = s && s !== "/" && s.endsWith("/"), c = (o || s === ".") && n.endsWith("/"); return !l.pathname.endsWith("/") && (u || c) && (l.pathname += "/"), l } const Xr = e => e.join("/").replace(/\/\/+/g, "/"), dF = e => e.replace(/\/+$/, "").replace(/^\/*/, "/"), fF = e => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e, pF = e => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e; class Kd { constructor(t, n, r, i) { i === void 0 && (i = !1), this.status = t, this.statusText = n || "", this.internal = i, r instanceof Error ? (this.data = r.toString(), this.error = r) : this.data = r } } function Gf(e) { return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data" in e } const x2 = ["post", "put", "patch", "delete"], hF = new Set(x2), mF = ["get", ...x2], gF = new Set(mF), vF = new Set([301, 302, 303, 307, 308]), yF = new Set([307, 308]), sh = { state: "idle", location: void 0, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, json: void 0, text: void 0 }, bF = { state: "idle", data: void 0, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, json: void 0, text: void 0 }, Va = { state: "unblocked", proceed: void 0, reset: void 0, location: void 0 }, Vy = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, wF = e => ({ hasErrorBoundary: !!e.hasErrorBoundary }), S2 = "remix-router-transitions"; function xF(e) { const t = e.window ? e.window : typeof window < "u" ? window : void 0, n = typeof t < "u" && typeof t.document < "u" && typeof t.document.createElement < "u", r = !n; Te(e.routes.length > 0, "You must provide a non-empty routes array to createRouter"); let i; if (e.mapRouteProperties) i = e.mapRouteProperties; else if (e.detectErrorBoundary) { let j = e.detectErrorBoundary; i = F => ({ hasErrorBoundary: j(F) }) } else i = wF; let o = {}, s = Gd(e.routes, i, void 0, o), a, l = e.basename || "/", u = e.dataStrategy || CF, c = e.patchRoutesOnNavigation, d = Qe({ v7_fetcherPersist: !1, v7_normalizeFormMethod: !1, v7_partialHydration: !1, v7_prependBasename: !1, v7_relativeSplatPath: !1, v7_skipActionErrorRevalidation: !1 }, e.future), f = null, p = new Set, m = null, v = null, x = null, g = e.hydrationData != null, h = po(s, e.history.location, l), y = null; if (h == null && !c) { let j = pn(404, { pathname: e.history.location.pathname }), { matches: F, route: B } = v1(s); h = F, y = { [B.id]: j } } h && !e.hydrationData && wr(h, s, e.history.location.pathname).active && (h = null); let E; if (h) if (h.some(j => j.route.lazy)) E = !1; else if (!h.some(j => j.route.loader)) E = !0; else if (d.v7_partialHydration) { let j = e.hydrationData ? e.hydrationData.loaderData : null, F = e.hydrationData ? e.hydrationData.errors : null; if (F) { let B = h.findIndex(K => F[K.route.id] !== void 0); E = h.slice(0, B + 1).every(K => !vg(K.route, j, F)) } else E = h.every(B => !vg(B.route, j, F)) } else E = e.hydrationData != null; else if (E = !1, h = [], d.v7_partialHydration) { let j = wr(null, s, e.history.location.pathname); j.active && j.matches && (h = j.matches) } let P, $ = { historyAction: e.history.action, location: e.history.location, matches: h, initialized: E, navigation: sh, restoreScrollPosition: e.hydrationData != null ? !1 : null, preventScrollReset: !1, revalidation: "idle", loaderData: e.hydrationData && e.hydrationData.loaderData || {}, actionData: e.hydrationData && e.hydrationData.actionData || null, errors: e.hydrationData && e.hydrationData.errors || y, fetchers: new Map, blockers: new Map }, L = Et.Pop, b = !1, M, R = !1, A = new Map, _ = null, C = !1, k = !1, O = [], U = new Set, z = new Map, D = 0, V = -1, H = new Map, T = new Set, N = new Map, W = new Map, Q = new Set, q = new Map, te = new Map, ae; function le() { if (f = e.history.listen(j => { let { action: F, location: B, delta: K } = j; if (ae) { ae(), ae = void 0; return } la(te.size === 0 || K != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL."); let ie = xn({ currentLocation: $.location, nextLocation: B, historyAction: F }); if (ie && K != null) { let X = new Promise(me => { ae = me }); e.history.go(K * -1), ui(ie, { state: "blocked", location: B, proceed() { ui(ie, { state: "proceeding", proceed: void 0, reset: void 0, location: B }), X.then(() => e.history.go(K)) }, reset() { let me = new Map($.blockers); me.set(ie, Va), Pe({ blockers: me }) } }); return } return it(F, B) }), n) { FF(t, A); let j = () => zF(t, A); t.addEventListener("pagehide", j), _ = () => t.removeEventListener("pagehide", j) } return $.initialized || it(Et.Pop, $.location, { initialHydration: !0 }), P } function oe() { f && f(), _ && _(), p.clear(), M && M.abort(), $.fetchers.forEach((j, F) => Pt(F)), $.blockers.forEach((j, F) => Nr(F)) } function ge(j) { return p.add(j), () => p.delete(j) } function Pe(j, F) { F === void 0 && (F = {}), $ = Qe({}, $, j); let B = [], K = []; d.v7_fetcherPersist && $.fetchers.forEach((ie, X) => { ie.state === "idle" && (Q.has(X) ? K.push(X) : B.push(X)) }), [...p].forEach(ie => ie($, { deletedFetchers: K, viewTransitionOpts: F.viewTransitionOpts, flushSync: F.flushSync === !0 })), d.v7_fetcherPersist && (B.forEach(ie => $.fetchers.delete(ie)), K.forEach(ie => Pt(ie))) } function Oe(j, F, B) { var K, ie; let { flushSync: X } = B === void 0 ? {} : B, me = $.actionData != null && $.navigation.formMethod != null && cr($.navigation.formMethod) && $.navigation.state === "loading" && ((K = j.state) == null ? void 0 : K._isRedirect) !== !0, ue; F.actionData ? Object.keys(F.actionData).length > 0 ? ue = F.actionData : ue = null : me ? ue = $.actionData : ue = null; let pe = F.loaderData ? m1($.loaderData, F.loaderData, F.matches || [], F.errors) : $.loaderData, re = $.blockers; re.size > 0 && (re = new Map(re), re.forEach(($e, yt) => re.set(yt, Va))); let he = b === !0 || $.navigation.formMethod != null && cr($.navigation.formMethod) && ((ie = j.state) == null ? void 0 : ie._isRedirect) !== !0; a && (s = a, a = void 0), C || L === Et.Pop || (L === Et.Push ? e.history.push(j, j.state) : L === Et.Replace && e.history.replace(j, j.state)); let xe; if (L === Et.Pop) { let $e = A.get($.location.pathname); $e && $e.has(j.pathname) ? xe = { currentLocation: $.location, nextLocation: j } : A.has(j.pathname) && (xe = { currentLocation: j, nextLocation: $.location }) } else if (R) { let $e = A.get($.location.pathname); $e ? $e.add(j.pathname) : ($e = new Set([j.pathname]), A.set($.location.pathname, $e)), xe = { currentLocation: $.location, nextLocation: j } } Pe(Qe({}, F, { actionData: ue, loaderData: pe, historyAction: L, location: j, initialized: !0, navigation: sh, revalidation: "idle", restoreScrollPosition: oo(j, F.matches || $.matches), preventScrollReset: he, blockers: re }), { viewTransitionOpts: xe, flushSync: X === !0 }), L = Et.Pop, b = !1, R = !1, C = !1, k = !1, O = [] } async function gt(j, F) { if (typeof j == "number") { e.history.go(j); return } let B = gg($.location, $.matches, l, d.v7_prependBasename, j, d.v7_relativeSplatPath, F == null ? void 0 : F.fromRouteId, F == null ? void 0 : F.relative), { path: K, submission: ie, error: X } = a1(d.v7_normalizeFormMethod, !1, B, F), me = $.location, ue = nu($.location, K, F && F.state); ue = Qe({}, ue, e.history.encodeLocation(ue)); let pe = F && F.replace != null ? F.replace : void 0, re = Et.Push; pe === !0 ? re = Et.Replace : pe === !1 || ie != null && cr(ie.formMethod) && ie.formAction === $.location.pathname + $.location.search && (re = Et.Replace); let he = F && "preventScrollReset" in F ? F.preventScrollReset === !0 : void 0, xe = (F && F.flushSync) === !0, $e = xn({ currentLocation: me, nextLocation: ue, historyAction: re }); if ($e) { ui($e, { state: "blocked", location: ue, proceed() { ui($e, { state: "proceeding", proceed: void 0, reset: void 0, location: ue }), gt(j, F) }, reset() { let yt = new Map($.blockers); yt.set($e, Va), Pe({ blockers: yt }) } }); return } return await it(re, ue, { submission: ie, pendingError: X, preventScrollReset: he, replace: F && F.replace, enableViewTransition: F && F.viewTransition, flushSync: xe }) } function Je() { if (wn(), Pe({ revalidation: "loading" }), $.navigation.state !== "submitting") { if ($.navigation.state === "idle") { it($.historyAction, $.location, { startUninterruptedRevalidation: !0 }); return } it(L || $.historyAction, $.navigation.location, { overrideNavigation: $.navigation, enableViewTransition: R === !0 }) } } async function it(j, F, B) { M && M.abort(), M = null, L = j, C = (B && B.startUninterruptedRevalidation) === !0, Ye($.location, $.matches), b = (B && B.preventScrollReset) === !0, R = (B && B.enableViewTransition) === !0; let K = a || s, ie = B && B.overrideNavigation, X = po(K, F, l), me = (B && B.flushSync) === !0, ue = wr(X, K, F.pathname); if (ue.active && ue.matches && (X = ue.matches), !X) { let { error: De, notFoundMatches: ne, route: I } = io(F.pathname); Oe(F, { matches: ne, loaderData: {}, errors: { [I.id]: De } }, { flushSync: me }); return } if ($.initialized && !k && _F($.location, F) && !(B && B.submission && cr(B.submission.formMethod))) { Oe(F, { matches: X }, { flushSync: me }); return } M = new AbortController; let pe = us(e.history, F, M.signal, B && B.submission), re; if (B && B.pendingError) re = [ho(X).route.id, { type: Fe.error, error: B.pendingError }]; else if (B && B.submission && cr(B.submission.formMethod)) { let De = await lt(pe, F, B.submission, X, ue.active, { replace: B.replace, flushSync: me }); if (De.shortCircuited) return; if (De.pendingActionResult) { let [ne, I] = De.pendingActionResult; if (Tn(I) && Gf(I.error) && I.error.status === 404) { M = null, Oe(F, { matches: De.matches, loaderData: {}, errors: { [ne]: I.error } }); return } } X = De.matches || X, re = De.pendingActionResult, ie = ah(F, B.submission), me = !1, ue.active = !1, pe = us(e.history, pe.url, pe.signal) } let { shortCircuited: he, matches: xe, loaderData: $e, errors: yt } = await Jt(pe, F, X, ue.active, ie, B && B.submission, B && B.fetcherSubmission, B && B.replace, B && B.initialHydration === !0, me, re); he || (M = null, Oe(F, Qe({ matches: xe || X }, g1(re), { loaderData: $e, errors: yt }))) } async function lt(j, F, B, K, ie, X) { X === void 0 && (X = {}), wn(); let me = IF(F, B); if (Pe({ navigation: me }, { flushSync: X.flushSync === !0 }), ie) { let re = await Or(K, F.pathname, j.signal); if (re.type === "aborted") return { shortCircuited: !0 }; if (re.type === "error") { let he = ho(re.partialMatches).route.id; return { matches: re.partialMatches, pendingActionResult: [he, { type: Fe.error, error: re.error }] } } else if (re.matches) K = re.matches; else { let { notFoundMatches: he, error: xe, route: $e } = io(F.pathname); return { matches: he, pendingActionResult: [$e.id, { type: Fe.error, error: xe }] } } } let ue, pe = al(K, F); if (!pe.route.action && !pe.route.lazy) ue = { type: Fe.error, error: pn(405, { method: j.method, pathname: F.pathname, routeId: pe.route.id }) }; else if (ue = (await Wt("action", $, j, [pe], K, null))[pe.route.id], j.signal.aborted) return { shortCircuited: !0 }; if (Eo(ue)) { let re; return X && X.replace != null ? re = X.replace : re = f1(ue.response.headers.get("Location"), new URL(j.url), l) === $.location.pathname + $.location.search, await ut(j, ue, !0, { submission: B, replace: re }), { shortCircuited: !0 } } if (Ni(ue)) throw pn(400, { type: "defer-action" }); if (Tn(ue)) { let re = ho(K, pe.route.id); return (X && X.replace) !== !0 && (L = Et.Push), { matches: K, pendingActionResult: [re.route.id, ue] } } return { matches: K, pendingActionResult: [pe.route.id, ue] } } async function Jt(j, F, B, K, ie, X, me, ue, pe, re, he) { let xe = ie || ah(F, X), $e = X || me || b1(xe), yt = !C && (!d.v7_partialHydration || !pe); if (K) { if (yt) { let Be = Zt(he); Pe(Qe({ navigation: xe }, Be !== void 0 ? { actionData: Be } : {}), { flushSync: re }) } let _e = await Or(B, F.pathname, j.signal); if (_e.type === "aborted") return { shortCircuited: !0 }; if (_e.type === "error") { let Be = ho(_e.partialMatches).route.id; return { matches: _e.partialMatches, loaderData: {}, errors: { [Be]: _e.error } } } else if (_e.matches) B = _e.matches; else { let { error: Be, notFoundMatches: is, route: Ta } = io(F.pathname); return { matches: is, loaderData: {}, errors: { [Ta.id]: Be } } } } let De = a || s, [ne, I] = u1(e.history, $, B, $e, F, d.v7_partialHydration && pe === !0, d.v7_skipActionErrorRevalidation, k, O, U, Q, N, T, De, l, he); if (nn(_e => !(B && B.some(Be => Be.route.id === _e)) || ne && ne.some(Be => Be.route.id === _e)), V = ++D, ne.length === 0 && I.length === 0) { let _e = vt(); return Oe(F, Qe({ matches: B, loaderData: {}, errors: he && Tn(he[1]) ? { [he[0]]: he[1].error } : null }, g1(he), _e ? { fetchers: new Map($.fetchers) } : {}), { flushSync: re }), { shortCircuited: !0 } } if (yt) { let _e = {}; if (!K) { _e.navigation = xe; let Be = Zt(he); Be !== void 0 && (_e.actionData = Be) } I.length > 0 && (_e.fetchers = ye(I)), Pe(_e, { flushSync: re }) } I.forEach(_e => { It(_e.key), _e.controller && z.set(_e.key, _e.controller) }); let Z = () => I.forEach(_e => It(_e.key)); M && M.signal.addEventListener("abort", Z); let { loaderResults: ce, fetcherResults: Ae } = await Fn($, B, ne, I, j); if (j.signal.aborted) return { shortCircuited: !0 }; M && M.signal.removeEventListener("abort", Z), I.forEach(_e => z.delete(_e.key)); let ze = Ec(ce); if (ze) return await ut(j, ze.result, !0, { replace: ue }), { shortCircuited: !0 }; if (ze = Ec(Ae), ze) return T.add(ze.key), await ut(j, ze.result, !0, { replace: ue }), { shortCircuited: !0 }; let { loaderData: ct, errors: bt } = h1($, B, ce, he, I, Ae, q); q.forEach((_e, Be) => { _e.subscribe(is => { (is || _e.done) && q.delete(Be) }) }), d.v7_partialHydration && pe && $.errors && (bt = Qe({}, $.errors, bt)); let Rt = vt(), xr = Vn(V), wt = Rt || xr || I.length > 0; return Qe({ matches: B, loaderData: ct, errors: bt }, wt ? { fetchers: new Map($.fetchers) } : {}) } function Zt(j) { if (j && !Tn(j[1])) return { [j[0]]: j[1].data }; if ($.actionData) return Object.keys($.actionData).length === 0 ? null : $.actionData } function ye(j) { return j.forEach(F => { let B = $.fetchers.get(F.key), K = Ba(void 0, B ? B.data : void 0); $.fetchers.set(F.key, K) }), new Map($.fetchers) } function Ht(j, F, B, K) { if (r) throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback."); It(j); let ie = (K && K.flushSync) === !0, X = a || s, me = gg($.location, $.matches, l, d.v7_prependBasename, B, d.v7_relativeSplatPath, F, K == null ? void 0 : K.relative), ue = po(X, me, l), pe = wr(ue, X, me); if (pe.active && pe.matches && (ue = pe.matches), !ue) { tn(j, F, pn(404, { pathname: me }), { flushSync: ie }); return } let { path: re, submission: he, error: xe } = a1(d.v7_normalizeFormMethod, !0, me, K); if (xe) { tn(j, F, xe, { flushSync: ie }); return } let $e = al(ue, re), yt = (K && K.preventScrollReset) === !0; if (he && cr(he.formMethod)) { en(j, F, re, $e, ue, pe.active, ie, yt, he); return } N.set(j, { routeId: F, path: re }), jt(j, F, re, $e, ue, pe.active, ie, yt, he) } async function en(j, F, B, K, ie, X, me, ue, pe) { wn(), N.delete(j); function re(xt) { if (!xt.route.action && !xt.route.lazy) { let os = pn(405, { method: pe.formMethod, pathname: B, routeId: F }); return tn(j, F, os, { flushSync: me }), !0 } return !1 } if (!X && re(K)) return; let he = $.fetchers.get(j); fn(j, DF(pe, he), { flushSync: me }); let xe = new AbortController, $e = us(e.history, B, xe.signal, pe); if (X) { let xt = await Or(ie, B, $e.signal); if (xt.type === "aborted") return; if (xt.type === "error") { tn(j, F, xt.error, { flushSync: me }); return } else if (xt.matches) { if (ie = xt.matches, K = al(ie, B), re(K)) return } else { tn(j, F, pn(404, { pathname: B }), { flushSync: me }); return } } z.set(j, xe); let yt = D, ne = (await Wt("action", $, $e, [K], ie, j))[K.route.id]; if ($e.signal.aborted) { z.get(j) === xe && z.delete(j); return } if (d.v7_fetcherPersist && Q.has(j)) { if (Eo(ne) || Tn(ne)) { fn(j, yi(void 0)); return } } else { if (Eo(ne)) if (z.delete(j), V > yt) { fn(j, yi(void 0)); return } else return T.add(j), fn(j, Ba(pe)), ut($e, ne, !1, { fetcherSubmission: pe, preventScrollReset: ue }); if (Tn(ne)) { tn(j, F, ne.error); return } } if (Ni(ne)) throw pn(400, { type: "defer-action" }); let I = $.navigation.location || $.location, Z = us(e.history, I, xe.signal), ce = a || s, Ae = $.navigation.state !== "idle" ? po(ce, $.navigation.location, l) : $.matches; Te(Ae, "Didn't find any matches after fetcher action"); let ze = ++D; H.set(j, ze); let ct = Ba(pe, ne.data); $.fetchers.set(j, ct); let [bt, Rt] = u1(e.history, $, Ae, pe, I, !1, d.v7_skipActionErrorRevalidation, k, O, U, Q, N, T, ce, l, [K.route.id, ne]); Rt.filter(xt => xt.key !== j).forEach(xt => { let os = xt.key, b0 = $.fetchers.get(os), UM = Ba(void 0, b0 ? b0.data : void 0); $.fetchers.set(os, UM), It(os), xt.controller && z.set(os, xt.controller) }), Pe({ fetchers: new Map($.fetchers) }); let xr = () => Rt.forEach(xt => It(xt.key)); xe.signal.addEventListener("abort", xr); let { loaderResults: wt, fetcherResults: _e } = await Fn($, Ae, bt, Rt, Z); if (xe.signal.aborted) return; xe.signal.removeEventListener("abort", xr), H.delete(j), z.delete(j), Rt.forEach(xt => z.delete(xt.key)); let Be = Ec(wt); if (Be) return ut(Z, Be.result, !1, { preventScrollReset: ue }); if (Be = Ec(_e), Be) return T.add(Be.key), ut(Z, Be.result, !1, { preventScrollReset: ue }); let { loaderData: is, errors: Ta } = h1($, Ae, wt, void 0, Rt, _e, q); if ($.fetchers.has(j)) { let xt = yi(ne.data); $.fetchers.set(j, xt) } Vn(ze), $.navigation.state === "loading" && ze > V ? (Te(L, "Expected pending action"), M && M.abort(), Oe($.navigation.location, { matches: Ae, loaderData: is, errors: Ta, fetchers: new Map($.fetchers) })) : (Pe({ errors: Ta, loaderData: m1($.loaderData, is, Ae, Ta), fetchers: new Map($.fetchers) }), k = !1) } async function jt(j, F, B, K, ie, X, me, ue, pe) { let re = $.fetchers.get(j); fn(j, Ba(pe, re ? re.data : void 0), { flushSync: me }); let he = new AbortController, xe = us(e.history, B, he.signal); if (X) { let ne = await Or(ie, B, xe.signal); if (ne.type === "aborted") return; if (ne.type === "error") { tn(j, F, ne.error, { flushSync: me }); return } else if (ne.matches) ie = ne.matches, K = al(ie, B); else { tn(j, F, pn(404, { pathname: B }), { flushSync: me }); return } } z.set(j, he); let $e = D, De = (await Wt("loader", $, xe, [K], ie, j))[K.route.id]; if (Ni(De) && (De = await By(De, xe.signal, !0) || De), z.get(j) === he && z.delete(j), !xe.signal.aborted) { if (Q.has(j)) { fn(j, yi(void 0)); return } if (Eo(De)) if (V > $e) { fn(j, yi(void 0)); return } else { T.add(j), await ut(xe, De, !1, { preventScrollReset: ue }); return } if (Tn(De)) { tn(j, F, De.error); return } Te(!Ni(De), "Unhandled fetcher deferred data"), fn(j, yi(De.data)) } } async function ut(j, F, B, K) { let { submission: ie, fetcherSubmission: X, preventScrollReset: me, replace: ue } = K === void 0 ? {} : K; F.response.headers.has("X-Remix-Revalidate") && (k = !0); let pe = F.response.headers.get("Location"); Te(pe, "Expected a Location header on the redirect Response"), pe = f1(pe, new URL(j.url), l); let re = nu($.location, pe, { _isRedirect: !0 }); if (n) { let ne = !1; if (F.response.headers.has("X-Remix-Reload-Document")) ne = !0; else if (Vy.test(pe)) { const I = e.history.createURL(pe); ne = I.origin !== t.location.origin || va(I.pathname, l) == null } if (ne) { ue ? t.location.replace(pe) : t.location.assign(pe); return } } M = null; let he = ue === !0 || F.response.headers.has("X-Remix-Replace") ? Et.Replace : Et.Push, { formMethod: xe, formAction: $e, formEncType: yt } = $.navigation; !ie && !X && xe && $e && yt && (ie = b1($.navigation)); let De = ie || X; if (yF.has(F.response.status) && De && cr(De.formMethod)) await it(he, re, { submission: Qe({}, De, { formAction: pe }), preventScrollReset: me || b, enableViewTransition: B ? R : void 0 }); else { let ne = ah(re, ie); await it(he, re, { overrideNavigation: ne, fetcherSubmission: X, preventScrollReset: me || b, enableViewTransition: B ? R : void 0 }) } } async function Wt(j, F, B, K, ie, X) { let me, ue = {}; try { me = await PF(u, j, F, B, K, ie, X, o, i) } catch (pe) { return K.forEach(re => { ue[re.route.id] = { type: Fe.error, error: pe } }), ue } for (let [pe, re] of Object.entries(me)) if (RF(re)) { let he = re.result; ue[pe] = { type: Fe.redirect, response: MF(he, B, pe, ie, l, d.v7_relativeSplatPath) } } else ue[pe] = await AF(re); return ue } async function Fn(j, F, B, K, ie) { let X = j.matches, me = Wt("loader", j, ie, B, F, null), ue = Promise.all(K.map(async he => { if (he.matches && he.match && he.controller) { let $e = (await Wt("loader", j, us(e.history, he.path, he.controller.signal), [he.match], he.matches, he.key))[he.match.route.id]; return { [he.key]: $e } } else return Promise.resolve({ [he.key]: { type: Fe.error, error: pn(404, { pathname: he.path }) } }) })), pe = await me, re = (await ue).reduce((he, xe) => Object.assign(he, xe), {}); return await Promise.all([OF(F, pe, ie.signal, X, j.loaderData), jF(F, re, K)]), { loaderResults: pe, fetcherResults: re } } function wn() { k = !0, O.push(...nn()), N.forEach((j, F) => { z.has(F) && U.add(F), It(F) }) } function fn(j, F, B) { B === void 0 && (B = {}), $.fetchers.set(j, F), Pe({ fetchers: new Map($.fetchers) }, { flushSync: (B && B.flushSync) === !0 }) } function tn(j, F, B, K) { K === void 0 && (K = {}); let ie = ho($.matches, F); Pt(j), Pe({ errors: { [ie.route.id]: B }, fetchers: new Map($.fetchers) }, { flushSync: (K && K.flushSync) === !0 }) } function zn(j) { return d.v7_fetcherPersist && (W.set(j, (W.get(j) || 0) + 1), Q.has(j) && Q.delete(j)), $.fetchers.get(j) || bF } function Pt(j) { let F = $.fetchers.get(j); z.has(j) && !(F && F.state === "loading" && H.has(j)) && It(j), N.delete(j), H.delete(j), T.delete(j), Q.delete(j), U.delete(j), $.fetchers.delete(j) } function li(j) { if (d.v7_fetcherPersist) { let F = (W.get(j) || 0) - 1; F <= 0 ? (W.delete(j), Q.add(j)) : W.set(j, F) } else Pt(j); Pe({ fetchers: new Map($.fetchers) }) } function It(j) { let F = z.get(j); F && (F.abort(), z.delete(j)) } function br(j) { for (let F of j) { let B = zn(F), K = yi(B.data); $.fetchers.set(F, K) } } function vt() { let j = [], F = !1; for (let B of T) { let K = $.fetchers.get(B); Te(K, "Expected fetcher: " + B), K.state === "loading" && (T.delete(B), j.push(B), F = !0) } return br(j), F } function Vn(j) { let F = []; for (let [B, K] of H) if (K < j) { let ie = $.fetchers.get(B); Te(ie, "Expected fetcher: " + B), ie.state === "loading" && (It(B), H.delete(B), F.push(B)) } return br(F), F.length > 0 } function Lr(j, F) { let B = $.blockers.get(j) || Va; return te.get(j) !== F && te.set(j, F), B } function Nr(j) { $.blockers.delete(j), te.delete(j) } function ui(j, F) { let B = $.blockers.get(j) || Va; Te(B.state === "unblocked" && F.state === "blocked" || B.state === "blocked" && F.state === "blocked" || B.state === "blocked" && F.state === "proceeding" || B.state === "blocked" && F.state === "unblocked" || B.state === "proceeding" && F.state === "unblocked", "Invalid blocker state transition: " + B.state + " -> " + F.state); let K = new Map($.blockers); K.set(j, F), Pe({ blockers: K }) } function xn(j) { let { currentLocation: F, nextLocation: B, historyAction: K } = j; if (te.size === 0) return; te.size > 1 && la(!1, "A router only supports one blocker at a time"); let ie = Array.from(te.entries()), [X, me] = ie[ie.length - 1], ue = $.blockers.get(X); if (!(ue && ue.state === "proceeding") && me({ currentLocation: F, nextLocation: B, historyAction: K })) return X } function io(j) { let F = pn(404, { pathname: j }), B = a || s, { matches: K, route: ie } = v1(B); return nn(), { notFoundMatches: K, route: ie, error: F } } function nn(j) { let F = []; return q.forEach((B, K) => { (!j || j(K)) && (B.cancel(), F.push(K), q.delete(K)) }), F } function ot(j, F, B) { if (m = j, x = F, v = B || null, !g && $.navigation === sh) { g = !0; let K = oo($.location, $.matches); K != null && Pe({ restoreScrollPosition: K }) } return () => { m = null, x = null, v = null } } function rr(j, F) { return v && v(j, F.map(K => Q6(K, $.loaderData))) || j.key } function Ye(j, F) { if (m && x) { let B = rr(j, F); m[B] = x() } } function oo(j, F) { if (m) { let B = rr(j, F), K = m[B]; if (typeof K == "number") return K } return null } function wr(j, F, B) { if (c) if (j) { if (Object.keys(j[0].params).length > 0) return { active: !0, matches: Jc(F, B, l, !0) } } else return { active: !0, matches: Jc(F, B, l, !0) || [] }; return { active: !1, matches: null } } async function Or(j, F, B) { if (!c) return { type: "success", matches: j }; let K = j; for (; ;) { let ie = a == null, X = a || s, me = o; try { await c({ path: F, matches: K, patch: (re, he) => { B.aborted || d1(re, he, X, me, i) } }) } catch (re) { return { type: "error", error: re, partialMatches: K } } finally { ie && !B.aborted && (s = [...s]) } if (B.aborted) return { type: "aborted" }; let ue = po(X, F, l); if (ue) return { type: "success", matches: ue }; let pe = Jc(X, F, l, !0); if (!pe || K.length === pe.length && K.every((re, he) => re.route.id === pe[he].route.id)) return { type: "success", matches: null }; K = pe } } function rs(j) { o = {}, a = Gd(j, i, void 0, o) } function Ea(j, F) { let B = a == null; d1(j, F, a || s, o, i), B && (s = [...s], Pe({})) } return P = { get basename() { return l }, get future() { return d }, get state() { return $ }, get routes() { return s }, get window() { return t }, initialize: le, subscribe: ge, enableScrollRestoration: ot, navigate: gt, fetch: Ht, revalidate: Je, createHref: j => e.history.createHref(j), encodeLocation: j => e.history.encodeLocation(j), getFetcher: zn, deleteFetcher: li, dispose: oe, getBlocker: Lr, deleteBlocker: Nr, patchRoutes: Ea, _internalFetchControllers: z, _internalActiveDeferreds: q, _internalSetRoutes: rs }, P } function SF(e) { return e != null && ("formData" in e && e.formData != null || "body" in e && e.body !== void 0) } function gg(e, t, n, r, i, o, s, a) { let l, u; if (s) { l = []; for (let d of t) if (l.push(d), d.route.id === s) { u = d; break } } else l = t, u = t[t.length - 1]; let c = Wf(i || ".", Hf(l, o), va(e.pathname, n) || e.pathname, a === "path"); if (i == null && (c.search = e.search, c.hash = e.hash), (i == null || i === "" || i === ".") && u) { let d = Uy(c.search); if (u.route.index && !d) c.search = c.search ? c.search.replace(/^\?/, "?index&") : "?index"; else if (!u.route.index && d) { let f = new URLSearchParams(c.search), p = f.getAll("index"); f.delete("index"), p.filter(v => v).forEach(v => f.append("index", v)); let m = f.toString(); c.search = m ? "?" + m : "" } } return r && n !== "/" && (c.pathname = c.pathname === "/" ? n : Xr([n, c.pathname])), Uo(c) } function a1(e, t, n, r) {
  if (!r || !SF(r)) return { path: n }; if (r.formMethod && !NF(r.formMethod)) return { path: n, error: pn(405, { method: r.formMethod }) }; let i = () => ({ path: n, error: pn(400, { type: "invalid-body" }) }), o = r.formMethod || "get", s = e ? o.toUpperCase() : o.toLowerCase(), a = C2(n); if (r.body !== void 0) {
    if (r.formEncType === "text/plain") {
      if (!cr(s)) return i(); let f = typeof r.body == "string" ? r.body : r.body instanceof FormData || r.body instanceof URLSearchParams ? Array.from(r.body.entries()).reduce((p, m) => {
        let [v, x] = m; return "" + p + v + "=" + x + `
`}, "") : String(r.body); return { path: n, submission: { formMethod: s, formAction: a, formEncType: r.formEncType, formData: void 0, json: void 0, text: f } }
    } else if (r.formEncType === "application/json") { if (!cr(s)) return i(); try { let f = typeof r.body == "string" ? JSON.parse(r.body) : r.body; return { path: n, submission: { formMethod: s, formAction: a, formEncType: r.formEncType, formData: void 0, json: f, text: void 0 } } } catch { return i() } }
  } Te(typeof FormData == "function", "FormData is not available in this environment"); let l, u; if (r.formData) l = yg(r.formData), u = r.formData; else if (r.body instanceof FormData) l = yg(r.body), u = r.body; else if (r.body instanceof URLSearchParams) l = r.body, u = p1(l); else if (r.body == null) l = new URLSearchParams, u = new FormData; else try { l = new URLSearchParams(r.body), u = p1(l) } catch { return i() } let c = { formMethod: s, formAction: a, formEncType: r && r.formEncType || "application/x-www-form-urlencoded", formData: u, json: void 0, text: void 0 }; if (cr(c.formMethod)) return { path: n, submission: c }; let d = no(n); return t && d.search && Uy(d.search) && l.append("index", ""), d.search = "?" + l, { path: Uo(d), submission: c }
} function l1(e, t, n) { n === void 0 && (n = !1); let r = e.findIndex(i => i.route.id === t); return r >= 0 ? e.slice(0, n ? r + 1 : r) : e } function u1(e, t, n, r, i, o, s, a, l, u, c, d, f, p, m, v) { let x = v ? Tn(v[1]) ? v[1].error : v[1].data : void 0, g = e.createURL(t.location), h = e.createURL(i), y = n; o && t.errors ? y = l1(n, Object.keys(t.errors)[0], !0) : v && Tn(v[1]) && (y = l1(n, v[0])); let E = v ? v[1].statusCode : void 0, P = s && E && E >= 400, $ = y.filter((b, M) => { let { route: R } = b; if (R.lazy) return !0; if (R.loader == null) return !1; if (o) return vg(R, t.loaderData, t.errors); if (EF(t.loaderData, t.matches[M], b) || l.some(C => C === b.route.id)) return !0; let A = t.matches[M], _ = b; return c1(b, Qe({ currentUrl: g, currentParams: A.params, nextUrl: h, nextParams: _.params }, r, { actionResult: x, actionStatus: E, defaultShouldRevalidate: P ? !1 : a || g.pathname + g.search === h.pathname + h.search || g.search !== h.search || E2(A, _) })) }), L = []; return d.forEach((b, M) => { if (o || !n.some(k => k.route.id === b.routeId) || c.has(M)) return; let R = po(p, b.path, m); if (!R) { L.push({ key: M, routeId: b.routeId, path: b.path, matches: null, match: null, controller: null }); return } let A = t.fetchers.get(M), _ = al(R, b.path), C = !1; f.has(M) ? C = !1 : u.has(M) ? (u.delete(M), C = !0) : A && A.state !== "idle" && A.data === void 0 ? C = a : C = c1(_, Qe({ currentUrl: g, currentParams: t.matches[t.matches.length - 1].params, nextUrl: h, nextParams: n[n.length - 1].params }, r, { actionResult: x, actionStatus: E, defaultShouldRevalidate: P ? !1 : a })), C && L.push({ key: M, routeId: b.routeId, path: b.path, matches: R, match: _, controller: new AbortController }) }), [$, L] } function vg(e, t, n) { if (e.lazy) return !0; if (!e.loader) return !1; let r = t != null && t[e.id] !== void 0, i = n != null && n[e.id] !== void 0; return !r && i ? !1 : typeof e.loader == "function" && e.loader.hydrate === !0 ? !0 : !r && !i } function EF(e, t, n) { let r = !t || n.route.id !== t.route.id, i = e[n.route.id] === void 0; return r || i } function E2(e, t) { let n = e.route.path; return e.pathname !== t.pathname || n != null && n.endsWith("*") && e.params["*"] !== t.params["*"] } function c1(e, t) { if (e.route.shouldRevalidate) { let n = e.route.shouldRevalidate(t); if (typeof n == "boolean") return n } return t.defaultShouldRevalidate } function d1(e, t, n, r, i) { var o; let s; if (e) { let u = r[e]; Te(u, "No route found to patch children into: routeId = " + e), u.children || (u.children = []), s = u.children } else s = n; let a = t.filter(u => !s.some(c => T2(u, c))), l = Gd(a, i, [e || "_", "patch", String(((o = s) == null ? void 0 : o.length) || "0")], r); s.push(...l) } function T2(e, t) { return "id" in e && "id" in t && e.id === t.id ? !0 : e.index === t.index && e.path === t.path && e.caseSensitive === t.caseSensitive ? (!e.children || e.children.length === 0) && (!t.children || t.children.length === 0) ? !0 : e.children.every((n, r) => { var i; return (i = t.children) == null ? void 0 : i.some(o => T2(n, o)) }) : !1 } async function TF(e, t, n) { if (!e.lazy) return; let r = await e.lazy(); if (!e.lazy) return; let i = n[e.id]; Te(i, "No route found in manifest"); let o = {}; for (let s in r) { let l = i[s] !== void 0 && s !== "hasErrorBoundary"; la(!l, 'Route "' + i.id + '" has a static property "' + s + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + s + '" will be ignored.')), !l && !q6.has(s) && (o[s] = r[s]) } Object.assign(i, o), Object.assign(i, Qe({}, t(i), { lazy: void 0 })) } async function CF(e) { let { matches: t } = e, n = t.filter(i => i.shouldLoad); return (await Promise.all(n.map(i => i.resolve()))).reduce((i, o, s) => Object.assign(i, { [n[s].route.id]: o }), {}) } async function PF(e, t, n, r, i, o, s, a, l, u) { let c = o.map(p => p.route.lazy ? TF(p.route, l, a) : void 0), d = o.map((p, m) => { let v = c[m], x = i.some(h => h.route.id === p.route.id); return Qe({}, p, { shouldLoad: x, resolve: async h => (h && r.method === "GET" && (p.route.lazy || p.route.loader) && (x = !0), x ? $F(t, r, p, v, h, u) : Promise.resolve({ type: Fe.data, result: void 0 })) }) }), f = await e({ matches: d, request: r, params: o[0].params, fetcherKey: s, context: u }); try { await Promise.all(c) } catch { } return f } async function $F(e, t, n, r, i, o) { let s, a, l = u => { let c, d = new Promise((m, v) => c = v); a = () => c(), t.signal.addEventListener("abort", a); let f = m => typeof u != "function" ? Promise.reject(new Error("You cannot call the handler for a route which defines a boolean " + ('"' + e + '" [routeId: ' + n.route.id + "]"))) : u({ request: t, params: n.params, context: o }, ...m !== void 0 ? [m] : []), p = (async () => { try { return { type: "data", result: await (i ? i(v => f(v)) : f()) } } catch (m) { return { type: "error", result: m } } })(); return Promise.race([p, d]) }; try { let u = n.route[e]; if (r) if (u) { let c, [d] = await Promise.all([l(u).catch(f => { c = f }), r]); if (c !== void 0) throw c; s = d } else if (await r, u = n.route[e], u) s = await l(u); else if (e === "action") { let c = new URL(t.url), d = c.pathname + c.search; throw pn(405, { method: t.method, pathname: d, routeId: n.route.id }) } else return { type: Fe.data, result: void 0 }; else if (u) s = await l(u); else { let c = new URL(t.url), d = c.pathname + c.search; throw pn(404, { pathname: d }) } Te(s.result !== void 0, "You defined " + (e === "action" ? "an action" : "a loader") + " for route " + ('"' + n.route.id + "\" but didn't return anything from your `" + e + "` ") + "function. Please return a value or `null`.") } catch (u) { return { type: Fe.error, result: u } } finally { a && t.signal.removeEventListener("abort", a) } return s } async function AF(e) { let { result: t, type: n } = e; if (P2(t)) { let u; try { let c = t.headers.get("Content-Type"); c && /\bapplication\/json\b/.test(c) ? t.body == null ? u = null : u = await t.json() : u = await t.text() } catch (c) { return { type: Fe.error, error: c } } return n === Fe.error ? { type: Fe.error, error: new Kd(t.status, t.statusText, u), statusCode: t.status, headers: t.headers } : { type: Fe.data, data: u, statusCode: t.status, headers: t.headers } } if (n === Fe.error) { if (y1(t)) { var r; if (t.data instanceof Error) { var i; return { type: Fe.error, error: t.data, statusCode: (i = t.init) == null ? void 0 : i.status } } t = new Kd(((r = t.init) == null ? void 0 : r.status) || 500, void 0, t.data) } return { type: Fe.error, error: t, statusCode: Gf(t) ? t.status : void 0 } } if (LF(t)) { var o, s; return { type: Fe.deferred, deferredData: t, statusCode: (o = t.init) == null ? void 0 : o.status, headers: ((s = t.init) == null ? void 0 : s.headers) && new Headers(t.init.headers) } } if (y1(t)) { var a, l; return { type: Fe.data, data: t.data, statusCode: (a = t.init) == null ? void 0 : a.status, headers: (l = t.init) != null && l.headers ? new Headers(t.init.headers) : void 0 } } return { type: Fe.data, data: t } } function MF(e, t, n, r, i, o) { let s = e.headers.get("Location"); if (Te(s, "Redirects returned/thrown from loaders/actions must have a Location header"), !Vy.test(s)) { let a = r.slice(0, r.findIndex(l => l.route.id === n) + 1); s = gg(new URL(t.url), a, i, !0, s, o), e.headers.set("Location", s) } return e } function f1(e, t, n) { if (Vy.test(e)) { let r = e, i = r.startsWith("//") ? new URL(t.protocol + r) : new URL(r), o = va(i.pathname, n) != null; if (i.origin === t.origin && o) return i.pathname + i.search + i.hash } return e } function us(e, t, n, r) { let i = e.createURL(C2(t)).toString(), o = { signal: n }; if (r && cr(r.formMethod)) { let { formMethod: s, formEncType: a } = r; o.method = s.toUpperCase(), a === "application/json" ? (o.headers = new Headers({ "Content-Type": a }), o.body = JSON.stringify(r.json)) : a === "text/plain" ? o.body = r.text : a === "application/x-www-form-urlencoded" && r.formData ? o.body = yg(r.formData) : o.body = r.formData } return new Request(i, o) } function yg(e) { let t = new URLSearchParams; for (let [n, r] of e.entries()) t.append(n, typeof r == "string" ? r : r.name); return t } function p1(e) { let t = new FormData; for (let [n, r] of e.entries()) t.append(n, r); return t } function kF(e, t, n, r, i) { let o = {}, s = null, a, l = !1, u = {}, c = n && Tn(n[1]) ? n[1].error : void 0; return e.forEach(d => { if (!(d.route.id in t)) return; let f = d.route.id, p = t[f]; if (Te(!Eo(p), "Cannot handle redirect results in processLoaderData"), Tn(p)) { let m = p.error; c !== void 0 && (m = c, c = void 0), s = s || {}; { let v = ho(e, f); s[v.route.id] == null && (s[v.route.id] = m) } o[f] = void 0, l || (l = !0, a = Gf(p.error) ? p.error.status : 500), p.headers && (u[f] = p.headers) } else Ni(p) ? (r.set(f, p.deferredData), o[f] = p.deferredData.data, p.statusCode != null && p.statusCode !== 200 && !l && (a = p.statusCode), p.headers && (u[f] = p.headers)) : (o[f] = p.data, p.statusCode && p.statusCode !== 200 && !l && (a = p.statusCode), p.headers && (u[f] = p.headers)) }), c !== void 0 && n && (s = { [n[0]]: c }, o[n[0]] = void 0), { loaderData: o, errors: s, statusCode: a || 200, loaderHeaders: u } } function h1(e, t, n, r, i, o, s) { let { loaderData: a, errors: l } = kF(t, n, r, s); return i.forEach(u => { let { key: c, match: d, controller: f } = u, p = o[c]; if (Te(p, "Did not find corresponding fetcher result"), !(f && f.signal.aborted)) if (Tn(p)) { let m = ho(e.matches, d == null ? void 0 : d.route.id); l && l[m.route.id] || (l = Qe({}, l, { [m.route.id]: p.error })), e.fetchers.delete(c) } else if (Eo(p)) Te(!1, "Unhandled fetcher revalidation redirect"); else if (Ni(p)) Te(!1, "Unhandled fetcher deferred data"); else { let m = yi(p.data); e.fetchers.set(c, m) } }), { loaderData: a, errors: l } } function m1(e, t, n, r) { let i = Qe({}, t); for (let o of n) { let s = o.route.id; if (t.hasOwnProperty(s) ? t[s] !== void 0 && (i[s] = t[s]) : e[s] !== void 0 && o.route.loader && (i[s] = e[s]), r && r.hasOwnProperty(s)) break } return i } function g1(e) { return e ? Tn(e[1]) ? { actionData: {} } : { actionData: { [e[0]]: e[1].data } } : {} } function ho(e, t) { return (t ? e.slice(0, e.findIndex(r => r.route.id === t) + 1) : [...e]).reverse().find(r => r.route.hasErrorBoundary === !0) || e[0] } function v1(e) { let t = e.length === 1 ? e[0] : e.find(n => n.index || !n.path || n.path === "/") || { id: "__shim-error-route__" }; return { matches: [{ params: {}, pathname: "", pathnameBase: "", route: t }], route: t } } function pn(e, t) { let { pathname: n, routeId: r, method: i, type: o, message: s } = t === void 0 ? {} : t, a = "Unknown Server Error", l = "Unknown @remix-run/router error"; return e === 400 ? (a = "Bad Request", i && n && r ? l = "You made a " + i + ' request to "' + n + '" but ' + ('did not provide a `loader` for route "' + r + '", ') + "so there is no way to handle the request." : o === "defer-action" ? l = "defer() is not supported in actions" : o === "invalid-body" && (l = "Unable to encode submission body")) : e === 403 ? (a = "Forbidden", l = 'Route "' + r + '" does not match URL "' + n + '"') : e === 404 ? (a = "Not Found", l = 'No route matches URL "' + n + '"') : e === 405 && (a = "Method Not Allowed", i && n && r ? l = "You made a " + i.toUpperCase() + ' request to "' + n + '" but ' + ('did not provide an `action` for route "' + r + '", ') + "so there is no way to handle the request." : i && (l = 'Invalid request method "' + i.toUpperCase() + '"')), new Kd(e || 500, a, new Error(l), !0) } function Ec(e) { let t = Object.entries(e); for (let n = t.length - 1; n >= 0; n--) { let [r, i] = t[n]; if (Eo(i)) return { key: r, result: i } } } function C2(e) { let t = typeof e == "string" ? no(e) : e; return Uo(Qe({}, t, { hash: "" })) } function _F(e, t) { return e.pathname !== t.pathname || e.search !== t.search ? !1 : e.hash === "" ? t.hash !== "" : e.hash === t.hash ? !0 : t.hash !== "" } function RF(e) { return P2(e.result) && vF.has(e.result.status) } function Ni(e) { return e.type === Fe.deferred } function Tn(e) { return e.type === Fe.error } function Eo(e) { return (e && e.type) === Fe.redirect } function y1(e) { return typeof e == "object" && e != null && "type" in e && "data" in e && "init" in e && e.type === "DataWithResponseInit" } function LF(e) { let t = e; return t && typeof t == "object" && typeof t.data == "object" && typeof t.subscribe == "function" && typeof t.cancel == "function" && typeof t.resolveData == "function" } function P2(e) { return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.headers == "object" && typeof e.body < "u" } function NF(e) { return gF.has(e.toLowerCase()) } function cr(e) { return hF.has(e.toLowerCase()) } async function OF(e, t, n, r, i) { let o = Object.entries(t); for (let s = 0; s < o.length; s++) { let [a, l] = o[s], u = e.find(f => (f == null ? void 0 : f.route.id) === a); if (!u) continue; let c = r.find(f => f.route.id === u.route.id), d = c != null && !E2(c, u) && (i && i[u.route.id]) !== void 0; Ni(l) && d && await By(l, n, !1).then(f => { f && (t[a] = f) }) } } async function jF(e, t, n) { for (let r = 0; r < n.length; r++) { let { key: i, routeId: o, controller: s } = n[r], a = t[i]; e.find(u => (u == null ? void 0 : u.route.id) === o) && Ni(a) && (Te(s, "Expected an AbortController for revalidating fetcher deferred result"), await By(a, s.signal, !0).then(u => { u && (t[i] = u) })) } } async function By(e, t, n) { if (n === void 0 && (n = !1), !await e.deferredData.resolveData(t)) { if (n) try { return { type: Fe.data, data: e.deferredData.unwrappedData } } catch (i) { return { type: Fe.error, error: i } } return { type: Fe.data, data: e.deferredData.data } } } function Uy(e) { return new URLSearchParams(e).getAll("index").some(t => t === "") } function al(e, t) { let n = typeof t == "string" ? no(t).search : t.search; if (e[e.length - 1].route.index && Uy(n || "")) return e[e.length - 1]; let r = w2(e); return r[r.length - 1] } function b1(e) { let { formMethod: t, formAction: n, formEncType: r, text: i, formData: o, json: s } = e; if (!(!t || !n || !r)) { if (i != null) return { formMethod: t, formAction: n, formEncType: r, formData: void 0, json: void 0, text: i }; if (o != null) return { formMethod: t, formAction: n, formEncType: r, formData: o, json: void 0, text: void 0 }; if (s !== void 0) return { formMethod: t, formAction: n, formEncType: r, formData: void 0, json: s, text: void 0 } } } function ah(e, t) { return t ? { state: "loading", location: e, formMethod: t.formMethod, formAction: t.formAction, formEncType: t.formEncType, formData: t.formData, json: t.json, text: t.text } : { state: "loading", location: e, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, json: void 0, text: void 0 } } function IF(e, t) { return { state: "submitting", location: e, formMethod: t.formMethod, formAction: t.formAction, formEncType: t.formEncType, formData: t.formData, json: t.json, text: t.text } } function Ba(e, t) { return e ? { state: "loading", formMethod: e.formMethod, formAction: e.formAction, formEncType: e.formEncType, formData: e.formData, json: e.json, text: e.text, data: t } : { state: "loading", formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, json: void 0, text: void 0, data: t } } function DF(e, t) { return { state: "submitting", formMethod: e.formMethod, formAction: e.formAction, formEncType: e.formEncType, formData: e.formData, json: e.json, text: e.text, data: t ? t.data : void 0 } } function yi(e) { return { state: "idle", formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, json: void 0, text: void 0, data: e } } function FF(e, t) { try { let n = e.sessionStorage.getItem(S2); if (n) { let r = JSON.parse(n); for (let [i, o] of Object.entries(r || {})) o && Array.isArray(o) && t.set(i, new Set(o || [])) } } catch { } } function zF(e, t) { if (t.size > 0) { let n = {}; for (let [r, i] of t) n[r] = [...i]; try { e.sessionStorage.setItem(S2, JSON.stringify(n)) } catch (r) { la(!1, "Failed to save applied view transitions in sessionStorage (" + r + ").") } } }/**
 * React Router v6.28.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function qd() { return qd = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, qd.apply(this, arguments) } const Kf = S.createContext(null), $2 = S.createContext(null), ro = S.createContext(null), Hy = S.createContext(null), Rr = S.createContext({ outlet: null, matches: [], isDataRoute: !1 }), A2 = S.createContext(null); function VF(e, t) { let { relative: n } = t === void 0 ? {} : t; ya() || Te(!1); let { basename: r, navigator: i } = S.useContext(ro), { hash: o, pathname: s, search: a } = k2(e, { relative: n }), l = s; return r !== "/" && (l = s === "/" ? r : Xr([r, s])), i.createHref({ pathname: l, search: a, hash: o }) } function ya() { return S.useContext(Hy) != null } function es() { return ya() || Te(!1), S.useContext(Hy).location } function M2(e) { S.useContext(ro).static || S.useLayoutEffect(e) } function ts() { let { isDataRoute: e } = S.useContext(Rr); return e ? n7() : BF() } function BF() { ya() || Te(!1); let e = S.useContext(Kf), { basename: t, future: n, navigator: r } = S.useContext(ro), { matches: i } = S.useContext(Rr), { pathname: o } = es(), s = JSON.stringify(Hf(i, n.v7_relativeSplatPath)), a = S.useRef(!1); return M2(() => { a.current = !0 }), S.useCallback(function (u, c) { if (c === void 0 && (c = {}), !a.current) return; if (typeof u == "number") { r.go(u); return } let d = Wf(u, JSON.parse(s), o, c.relative === "path"); e == null && t !== "/" && (d.pathname = d.pathname === "/" ? t : Xr([t, d.pathname])), (c.replace ? r.replace : r.push)(d, c.state, c) }, [t, r, s, o, e]) } const UF = S.createContext(null); function HF(e) { let t = S.useContext(Rr).outlet; return t && S.createElement(UF.Provider, { value: e }, t) } function WF() { let { matches: e } = S.useContext(Rr), t = e[e.length - 1]; return t ? t.params : {} } function k2(e, t) { let { relative: n } = t === void 0 ? {} : t, { future: r } = S.useContext(ro), { matches: i } = S.useContext(Rr), { pathname: o } = es(), s = JSON.stringify(Hf(i, r.v7_relativeSplatPath)); return S.useMemo(() => Wf(e, JSON.parse(s), o, n === "path"), [e, s, o, n]) } function GF(e, t, n, r) { ya() || Te(!1); let { navigator: i } = S.useContext(ro), { matches: o } = S.useContext(Rr), s = o[o.length - 1], a = s ? s.params : {}; s && s.pathname; let l = s ? s.pathnameBase : "/"; s && s.route; let u = es(), c; c = u; let d = c.pathname || "/", f = d; if (l !== "/") { let v = l.replace(/^\//, "").split("/"); f = "/" + d.replace(/^\//, "").split("/").slice(v.length).join("/") } let p = po(e, { pathname: f }); return XF(p && p.map(v => Object.assign({}, v, { params: Object.assign({}, a, v.params), pathname: Xr([l, i.encodeLocation ? i.encodeLocation(v.pathname).pathname : v.pathname]), pathnameBase: v.pathnameBase === "/" ? l : Xr([l, i.encodeLocation ? i.encodeLocation(v.pathnameBase).pathname : v.pathnameBase]) })), o, n, r) } function KF() { let e = t7(), t = Gf(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e), n = e instanceof Error ? e.stack : null, i = { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" }; return S.createElement(S.Fragment, null, S.createElement("h2", null, "Unexpected Application Error!"), S.createElement("h3", { style: { fontStyle: "italic" } }, t), n ? S.createElement("pre", { style: i }, n) : null, null) } const qF = S.createElement(KF, null); class YF extends S.Component { constructor(t) { super(t), this.state = { location: t.location, revalidation: t.revalidation, error: t.error } } static getDerivedStateFromError(t) { return { error: t } } static getDerivedStateFromProps(t, n) { return n.location !== t.location || n.revalidation !== "idle" && t.revalidation === "idle" ? { error: t.error, location: t.location, revalidation: t.revalidation } : { error: t.error !== void 0 ? t.error : n.error, location: n.location, revalidation: t.revalidation || n.revalidation } } componentDidCatch(t, n) { console.error("React Router caught the following error during render", t, n) } render() { return this.state.error !== void 0 ? S.createElement(Rr.Provider, { value: this.props.routeContext }, S.createElement(A2.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } } function QF(e) { let { routeContext: t, match: n, children: r } = e, i = S.useContext(Kf); return i && i.static && i.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (i.staticContext._deepestRenderedBoundaryId = n.route.id), S.createElement(Rr.Provider, { value: t }, r) } function XF(e, t, n, r) { var i; if (t === void 0 && (t = []), n === void 0 && (n = null), r === void 0 && (r = null), e == null) { var o; if (!n) return null; if (n.errors) e = n.matches; else if ((o = r) != null && o.v7_partialHydration && t.length === 0 && !n.initialized && n.matches.length > 0) e = n.matches; else return null } let s = e, a = (i = n) == null ? void 0 : i.errors; if (a != null) { let c = s.findIndex(d => d.route.id && (a == null ? void 0 : a[d.route.id]) !== void 0); c >= 0 || Te(!1), s = s.slice(0, Math.min(s.length, c + 1)) } let l = !1, u = -1; if (n && r && r.v7_partialHydration) for (let c = 0; c < s.length; c++) { let d = s[c]; if ((d.route.HydrateFallback || d.route.hydrateFallbackElement) && (u = c), d.route.id) { let { loaderData: f, errors: p } = n, m = d.route.loader && f[d.route.id] === void 0 && (!p || p[d.route.id] === void 0); if (d.route.lazy || m) { l = !0, u >= 0 ? s = s.slice(0, u + 1) : s = [s[0]]; break } } } return s.reduceRight((c, d, f) => { let p, m = !1, v = null, x = null; n && (p = a && d.route.id ? a[d.route.id] : void 0, v = d.route.errorElement || qF, l && (u < 0 && f === 0 ? (m = !0, x = null) : u === f && (m = !0, x = d.route.hydrateFallbackElement || null))); let g = t.concat(s.slice(0, f + 1)), h = () => { let y; return p ? y = v : m ? y = x : d.route.Component ? y = S.createElement(d.route.Component, null) : d.route.element ? y = d.route.element : y = c, S.createElement(QF, { match: d, routeContext: { outlet: c, matches: g, isDataRoute: n != null }, children: y }) }; return n && (d.route.ErrorBoundary || d.route.errorElement || f === 0) ? S.createElement(YF, { location: n.location, revalidation: n.revalidation, component: v, error: p, children: h(), routeContext: { outlet: null, matches: g, isDataRoute: !0 } }) : h() }, null) } var _2 = function (e) { return e.UseBlocker = "useBlocker", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e }(_2 || {}), Yd = function (e) { return e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId", e }(Yd || {}); function JF(e) { let t = S.useContext(Kf); return t || Te(!1), t } function ZF(e) { let t = S.useContext($2); return t || Te(!1), t } function e7(e) { let t = S.useContext(Rr); return t || Te(!1), t } function R2(e) { let t = e7(), n = t.matches[t.matches.length - 1]; return n.route.id || Te(!1), n.route.id } function t7() { var e; let t = S.useContext(A2), n = ZF(Yd.UseRouteError), r = R2(Yd.UseRouteError); return t !== void 0 ? t : (e = n.errors) == null ? void 0 : e[r] } function n7() { let { router: e } = JF(_2.UseNavigateStable), t = R2(Yd.UseNavigateStable), n = S.useRef(!1); return M2(() => { n.current = !0 }), S.useCallback(function (i, o) { o === void 0 && (o = {}), n.current && (typeof i == "number" ? e.navigate(i) : e.navigate(i, qd({ fromRouteId: t }, o))) }, [e, t]) } const w1 = {}; function r7(e, t) { w1[t] || (w1[t] = !0, console.warn(t)) } const cs = (e, t, n) => r7(e, " React Router Future Flag Warning: " + t + ". " + ("You can use the `" + e + "` future flag to opt-in early. ") + ("For more information, see " + n + ".")); function i7(e, t) { (e == null ? void 0 : e.v7_startTransition) === void 0 && cs("v7_startTransition", "React Router will begin wrapping state updates in `React.startTransition` in v7", "https://reactrouter.com/v6/upgrading/future#v7_starttransition"), (e == null ? void 0 : e.v7_relativeSplatPath) === void 0 && (!t || !t.v7_relativeSplatPath) && cs("v7_relativeSplatPath", "Relative route resolution within Splat routes is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_relativesplatpath"), t && (t.v7_fetcherPersist === void 0 && cs("v7_fetcherPersist", "The persistence behavior of fetchers is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_fetcherpersist"), t.v7_normalizeFormMethod === void 0 && cs("v7_normalizeFormMethod", "Casing of `formMethod` fields is being normalized to uppercase in v7", "https://reactrouter.com/v6/upgrading/future#v7_normalizeformmethod"), t.v7_partialHydration === void 0 && cs("v7_partialHydration", "`RouterProvider` hydration behavior is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_partialhydration"), t.v7_skipActionErrorRevalidation === void 0 && cs("v7_skipActionErrorRevalidation", "The revalidation behavior after 4xx/5xx `action` responses is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_skipactionerrorrevalidation")) } const o7 = "startTransition", x1 = lk[o7]; function s7(e) { let { fallbackElement: t, router: n, future: r } = e, [i, o] = S.useState(n.state), { v7_startTransition: s } = r || {}, a = S.useCallback(d => { s && x1 ? x1(() => o(d)) : o(d) }, [o, s]); S.useLayoutEffect(() => n.subscribe(a), [n, a]), S.useEffect(() => { }, []); let l = S.useMemo(() => ({ createHref: n.createHref, encodeLocation: n.encodeLocation, go: d => n.navigate(d), push: (d, f, p) => n.navigate(d, { state: f, preventScrollReset: p == null ? void 0 : p.preventScrollReset }), replace: (d, f, p) => n.navigate(d, { replace: !0, state: f, preventScrollReset: p == null ? void 0 : p.preventScrollReset }) }), [n]), u = n.basename || "/", c = S.useMemo(() => ({ router: n, navigator: l, static: !1, basename: u }), [n, l, u]); return S.useEffect(() => i7(r, n.future), [n, r]), S.createElement(S.Fragment, null, S.createElement(Kf.Provider, { value: c }, S.createElement($2.Provider, { value: i }, S.createElement(c7, { basename: u, location: i.location, navigationType: i.historyAction, navigator: l, future: { v7_relativeSplatPath: n.future.v7_relativeSplatPath } }, i.initialized || n.future.v7_partialHydration ? S.createElement(a7, { routes: n.routes, future: n.future, state: i }) : t))), null) } function a7(e) { let { routes: t, future: n, state: r } = e; return GF(t, void 0, r, n) } function l7(e) { let { to: t, replace: n, state: r, relative: i } = e; ya() || Te(!1); let { future: o, static: s } = S.useContext(ro), { matches: a } = S.useContext(Rr), { pathname: l } = es(), u = ts(), c = Wf(t, Hf(a, o.v7_relativeSplatPath), l, i === "path"), d = JSON.stringify(c); return S.useEffect(() => u(JSON.parse(d), { replace: n, state: r, relative: i }), [u, d, i, n, r]), null } function u7(e) { return HF(e.context) } function c7(e) { let { basename: t = "/", children: n = null, location: r, navigationType: i = Et.Pop, navigator: o, static: s = !1, future: a } = e; ya() && Te(!1); let l = t.replace(/^\/*/, "/"), u = S.useMemo(() => ({ basename: l, navigator: o, static: s, future: qd({ v7_relativeSplatPath: !1 }, a) }), [l, a, o, s]); typeof r == "string" && (r = no(r)); let { pathname: c = "/", search: d = "", hash: f = "", state: p = null, key: m = "default" } = r, v = S.useMemo(() => { let x = va(c, l); return x == null ? null : { location: { pathname: x, search: d, hash: f, state: p, key: m }, navigationType: i } }, [l, c, d, f, p, m, i]); return v == null ? null : S.createElement(ro.Provider, { value: u }, S.createElement(Hy.Provider, { children: n, value: v })) } new Promise(() => { }); function d7(e) { let t = { hasErrorBoundary: e.ErrorBoundary != null || e.errorElement != null }; return e.Component && Object.assign(t, { element: S.createElement(e.Component), Component: void 0 }), e.HydrateFallback && Object.assign(t, { hydrateFallbackElement: S.createElement(e.HydrateFallback), HydrateFallback: void 0 }), e.ErrorBoundary && Object.assign(t, { errorElement: S.createElement(e.ErrorBoundary), ErrorBoundary: void 0 }), t }/**
 * React Router DOM v6.28.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function ru() { return ru = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, ru.apply(this, arguments) } function f7(e, t) { if (e == null) return {}; var n = {}, r = Object.keys(e), i, o; for (o = 0; o < r.length; o++)i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]); return n } function p7(e) { return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) } function h7(e, t) { return e.button === 0 && (!t || t === "_self") && !p7(e) } const m7 = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"], g7 = "6"; try { window.__reactRouterVersion = g7 } catch { } function v7(e, t) { return xF({ basename: void 0, future: ru({}, void 0, { v7_prependBasename: !0 }), history: W6({ window: void 0 }), hydrationData: y7(), routes: e, mapRouteProperties: d7, dataStrategy: void 0, patchRoutesOnNavigation: void 0, window: void 0 }).initialize() } function y7() { var e; let t = (e = window) == null ? void 0 : e.__staticRouterHydrationData; return t && t.errors && (t = ru({}, t, { errors: b7(t.errors) })), t } function b7(e) { if (!e) return null; let t = Object.entries(e), n = {}; for (let [r, i] of t) if (i && i.__type === "RouteErrorResponse") n[r] = new Kd(i.status, i.statusText, i.data, i.internal === !0); else if (i && i.__type === "Error") { if (i.__subType) { let o = window[i.__subType]; if (typeof o == "function") try { let s = new o(i.message); s.stack = "", n[r] = s } catch { } } if (n[r] == null) { let o = new Error(i.message); o.stack = "", n[r] = o } } else n[r] = i; return n } const w7 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", x7 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Oi = S.forwardRef(function (t, n) { let { onClick: r, relative: i, reloadDocument: o, replace: s, state: a, target: l, to: u, preventScrollReset: c, viewTransition: d } = t, f = f7(t, m7), { basename: p } = S.useContext(ro), m, v = !1; if (typeof u == "string" && x7.test(u) && (m = u, w7)) try { let y = new URL(window.location.href), E = u.startsWith("//") ? new URL(y.protocol + u) : new URL(u), P = va(E.pathname, p); E.origin === y.origin && P != null ? u = P + E.search + E.hash : v = !0 } catch { } let x = VF(u, { relative: i }), g = S7(u, { replace: s, state: a, target: l, preventScrollReset: c, relative: i, viewTransition: d }); function h(y) { r && r(y), y.defaultPrevented || g(y) } return S.createElement("a", ru({}, f, { href: m || x, onClick: v || o ? r : h, ref: n, target: l })) }); var S1; (function (e) { e.UseScrollRestoration = "useScrollRestoration", e.UseSubmit = "useSubmit", e.UseSubmitFetcher = "useSubmitFetcher", e.UseFetcher = "useFetcher", e.useViewTransitionState = "useViewTransitionState" })(S1 || (S1 = {})); var E1; (function (e) { e.UseFetcher = "useFetcher", e.UseFetchers = "useFetchers", e.UseScrollRestoration = "useScrollRestoration" })(E1 || (E1 = {})); function S7(e, t) { let { target: n, replace: r, state: i, preventScrollReset: o, relative: s, viewTransition: a } = t === void 0 ? {} : t, l = ts(), u = es(), c = k2(e, { relative: s }); return S.useCallback(d => { if (h7(d, n)) { d.preventDefault(); let f = r !== void 0 ? r : Uo(u) === Uo(c); l(e, { replace: f, state: i, preventScrollReset: o, relative: s, viewTransition: a }) } }, [u, l, c, r, i, n, e, o, s, a]) } var L2 = { color: void 0, size: void 0, className: void 0, style: void 0, attr: void 0 }, T1 = se.createContext && se.createContext(L2), E7 = ["attr", "size", "title"]; function T7(e, t) { if (e == null) return {}; var n = C7(e, t), r, i; if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); for (i = 0; i < o.length; i++)r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]) } return n } function C7(e, t) { if (e == null) return {}; var n = {}; for (var r in e) if (Object.prototype.hasOwnProperty.call(e, r)) { if (t.indexOf(r) >= 0) continue; n[r] = e[r] } return n } function Qd() { return Qd = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, Qd.apply(this, arguments) } function C1(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(e, i).enumerable })), n.push.apply(n, r) } return n } function Xd(e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; t % 2 ? C1(Object(n), !0).forEach(function (r) { P7(e, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : C1(Object(n)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r)) }) } return e } function P7(e, t, n) { return t = $7(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function $7(e) { var t = A7(e, "string"); return typeof t == "symbol" ? t : t + "" } function A7(e, t) { if (typeof e != "object" || !e) return e; var n = e[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(e, t || "default"); if (typeof r != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (t === "string" ? String : Number)(e) } function N2(e) { return e && e.map((t, n) => se.createElement(t.tag, Xd({ key: n }, t.attr), N2(t.child))) } function vr(e) { return t => se.createElement(M7, Qd({ attr: Xd({}, e.attr) }, t), N2(e.child)) } function M7(e) { var t = n => { var { attr: r, size: i, title: o } = e, s = T7(e, E7), a = i || n.size || "1em", l; return n.className && (l = n.className), e.className && (l = (l ? l + " " : "") + e.className), se.createElement("svg", Qd({ stroke: "currentColor", fill: "currentColor", strokeWidth: "0" }, n.attr, r, s, { className: l, style: Xd(Xd({ color: e.color || n.color }, n.style), e.style), height: a, width: a, xmlns: "http://www.w3.org/2000/svg" }), o && se.createElement("title", null, o), e.children) }; return T1 !== void 0 ? se.createElement(T1.Consumer, null, n => t(n)) : t(L2) } function k7(e) { return vr({ tag: "svg", attr: { fill: "currentColor", viewBox: "0 0 16 16" }, child: [{ tag: "path", attr: { d: "M5.026 15c6.038 0 9.341-5.003 9.341-9.334q.002-.211-.006-.422A6.7 6.7 0 0 0 16 3.542a6.7 6.7 0 0 1-1.889.518 3.3 3.3 0 0 0 1.447-1.817 6.5 6.5 0 0 1-2.087.793A3.286 3.286 0 0 0 7.875 6.03a9.32 9.32 0 0 1-6.767-3.429 3.29 3.29 0 0 0 1.018 4.382A3.3 3.3 0 0 1 .64 6.575v.045a3.29 3.29 0 0 0 2.632 3.218 3.2 3.2 0 0 1-.865.115 3 3 0 0 1-.614-.057 3.28 3.28 0 0 0 3.067 2.277A6.6 6.6 0 0 1 .78 13.58a6 6 0 0 1-.78-.045A9.34 9.34 0 0 0 5.026 15" }, child: [] }] })(e) } function O2(e) { return vr({ tag: "svg", attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z" }, child: [] }] })(e) } function j2(e) { return vr({ tag: "svg", attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M288 144a110.94 110.94 0 0 0-31.24 5 55.4 55.4 0 0 1 7.24 27 56 56 0 0 1-56 56 55.4 55.4 0 0 1-27-7.24A111.71 111.71 0 1 0 288 144zm284.52 97.4C518.29 135.59 410.93 64 288 64S57.68 135.64 3.48 241.41a32.35 32.35 0 0 0 0 29.19C57.71 376.41 165.07 448 288 448s230.32-71.64 284.52-177.41a32.35 32.35 0 0 0 0-29.19zM288 400c-98.65 0-189.09-55-237.93-144C98.91 167 189.34 112 288 112s189.09 55 237.93 144C477.1 345 386.66 400 288 400z" }, child: [] }] })(e) } const I2 = "/assets/logo-CycsGb-R.png"; function D2(e) { return vr({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M18.3362 18.339H15.6707V14.1622C15.6707 13.1662 15.6505 11.8845 14.2817 11.8845C12.892 11.8845 12.6797 12.9683 12.6797 14.0887V18.339H10.0142V9.75H12.5747V10.9207H12.6092C12.967 10.2457 13.837 9.53325 15.1367 9.53325C17.8375 9.53325 18.337 11.3108 18.337 13.6245V18.339H18.3362ZM7.00373 8.57475C6.14573 8.57475 5.45648 7.88025 5.45648 7.026C5.45648 6.1725 6.14648 5.47875 7.00373 5.47875C7.85873 5.47875 8.55173 6.1725 8.55173 7.026C8.55173 7.88025 7.85798 8.57475 7.00373 8.57475ZM8.34023 18.339H5.66723V9.75H8.34023V18.339ZM19.6697 3H4.32923C3.59498 3 3.00098 3.5805 3.00098 4.29675V19.7033C3.00098 20.4202 3.59498 21 4.32923 21H19.6675C20.401 21 21.001 20.4202 21.001 19.7033V4.29675C21.001 3.5805 20.401 3 19.6675 3H19.6697Z" }, child: [] }] })(e) } const _7 = () => w.jsxs("footer", { className: "text-mainText p-8 border-t-2 border-secondary mt-20", children: [w.jsxs("div", { className: "container mx-auto grid grid-cols-1 md:grid-cols-2 lg:grid-cols-[3fr_4fr_2fr_2fr] gap-8", children: [w.jsxs("div", { className: "flex flex-col gap-2 items-center md:items-start", children: [w.jsx("img", { src: I2, alt: "Logo", loading: "lazy", className: "w-28 h-fit ml-[-15px]" }), w.jsx("p", { className: "text-sm text-center md:text-start", children: "Journey Story was created to inspire through real-life experiences of entrepreneurs and leaders, offering insights and motivation for personal and professional growth." })] }), w.jsxs("div", { className: "flex justify-between flex-1", children: [w.jsxs("div", { children: [w.jsx("h2", { className: "text-2xl font-bold mb-3", children: "Pages" }), w.jsxs("ul", { className: "space-y-2", children: [w.jsx("li", { children: w.jsx(Oi, { to: "/episodes", className: "hover:underline", children: "Episodes" }) }), w.jsx("li", { children: w.jsx(Oi, { to: "https://blogs.journeystory.in", className: "hover:underline", children: "Blogs" }) }), w.jsx("li", { children: w.jsx(Oi, { to: "/reviews", className: "hover:underline", children: "Reviews" }) }), w.jsx("li", { children: w.jsx(Oi, { to: "/contact-us", className: "hover:underline", children: "Contact us" }) })] })] }), w.jsxs("div", { children: [w.jsx("h2", { className: "text-2xl font-bold mb-3", children: "Where to listen" }), w.jsxs("ul", { className: "space-y-2", children: [w.jsx("li", { children: w.jsx("a", { href: "https://open.spotify.com/show/1ZQE9AUhjChYhjKTgUr3ld?si=9cc36ba0d51345c5", target: "_blank", rel: "noopener noreferrer", className: "hover:underline", children: "Spotify" }) }), w.jsx("li", { children: w.jsx("a", { href: "https://www.youtube.com/@JourneyStoryHindi", target: "_blank", rel: "noopener noreferrer", className: "hover:underline", children: "Youtube" }) })] })] })] }), w.jsxs("div", { children: [w.jsx("h2", { className: "text-2xl font-bold mb-3", children: "Contact Info" }), w.jsx("p", { className: "text-sm", children: "Email: ceo@journeystory.in" }), w.jsx("p", { className: "text-sm", children: "Phone: +91 8530975857" })] }), w.jsxs("div", { className: "flex flex-col gap-4", children: [w.jsx("h2", { className: "text-2xl font-bold mb-3", children: "Social Media" }), w.jsxs("a", { href: "https://x.com/JourneyStory_in", target: "_blank", rel: "noopener noreferrer", className: "flex items-center gap-2", children: [w.jsx(k7, { className: "text-3xl bg-background rounded-full p-1 border border-primary" }), w.jsx("div", { className: "text-md", children: "Twitter" })] }), w.jsxs("a", { href: " https://www.instagram.com/journeystory_me", target: "_blank", rel: "noopener noreferrer", className: "flex items-center gap-2", children: [w.jsx(O2, { className: "text-3xl bg-background rounded-full p-1 border border-primary" }), w.jsx("div", { className: "text-md", children: "Instagram" })] }), w.jsxs("a", { href: "https://www.linkedin.com/company/journeystory/", target: "_blank", rel: "noopener noreferrer", className: "flex items-center gap-2", children: [w.jsx(D2, { className: "text-3xl bg-background rounded-full p-1 border border-primary" }), w.jsx("div", { className: "text-md", children: "LinkedIn" })] })] })] }), w.jsxs("div", { className: "flex justify-center items-center mt-8", children: [w.jsx("p", { className: "text-sm", children: " 2024 Journey Story" }), w.jsx("br", {})] })] });/*! js-cookie v3.0.5 | MIT */function Tc(e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) e[r] = n[r] } return e } var R7 = { read: function (e) { return e[0] === '"' && (e = e.slice(1, -1)), e.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent) }, write: function (e) { return encodeURIComponent(e).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent) } }; function bg(e, t) { function n(i, o, s) { if (!(typeof document > "u")) { s = Tc({}, t, s), typeof s.expires == "number" && (s.expires = new Date(Date.now() + s.expires * 864e5)), s.expires && (s.expires = s.expires.toUTCString()), i = encodeURIComponent(i).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape); var a = ""; for (var l in s) s[l] && (a += "; " + l, s[l] !== !0 && (a += "=" + s[l].split(";")[0])); return document.cookie = i + "=" + e.write(o, i) + a } } function r(i) { if (!(typeof document > "u" || arguments.length && !i)) { for (var o = document.cookie ? document.cookie.split("; ") : [], s = {}, a = 0; a < o.length; a++) { var l = o[a].split("="), u = l.slice(1).join("="); try { var c = decodeURIComponent(l[0]); if (s[c] = e.read(u, c), i === c) break } catch { } } return i ? s[i] : s } } return Object.create({ set: n, get: r, remove: function (i, o) { n(i, "", Tc({}, o, { expires: -1 })) }, withAttributes: function (i) { return bg(this.converter, Tc({}, this.attributes, i)) }, withConverter: function (i) { return bg(Tc({}, this.converter, i), this.attributes) } }, { attributes: { value: Object.freeze(t) }, converter: { value: Object.freeze(e) } }) } bg(R7, { path: "/" }); const Lu = ({ text: e, toLink: t }) => w.jsx(Dy, { variant: "bordered", radius: "full", className: "bg-primary text-white font-bold", children: w.jsx(Oi, { to: t, className: "w-full text-center", children: e }) }), L7 = () => { const [e, t] = S.useState(!1), [n, r] = S.useState(!1), i = es(), o = ts(); S.useEffect(() => { switch (i.pathname) { case "/episodes": document.title = "Journey-Story | Episodes"; break; case "/blogs": document.title = "Journey-Story | Blogs"; break; case "/stories": document.title = "Journey-Story | Stories"; break; case "/reviews": document.title = "Journey-Story | Reviews"; break; case "/about": document.title = "Journey-Story | About Us"; break; case "/team": document.title = "Journey-Story | Our Team"; break; default: document.title = "Journey-Story"; break } }, [i.pathname]), S.useEffect(() => { window.scrollTo(0, 0) }, [i]), S.useEffect(() => { const u = i.hash; if (u) { const c = document.getElementById(u.substring(1)); c && c.scrollIntoView({ behavior: "smooth" }) } }, [i]); const s = [{ label: "Episodes", toLink: "/episodes" }, { label: "Blogs", toLink: "https://blogs.journeystory.in" }, { label: "Stories", toLink: "/stories" }, { label: "About us", toLink: "#about" }, { label: "Team", toLink: "#team" }, { label: "Reviews", toLink: "/reviews" }], a = u => { u.startsWith("http") ? window.location.href = u : u.startsWith("#") ? o("/" + u) : o(u), t(!1), r(!1) }, l = () => { r(!n) }; return w.jsxs("div", { className: "bg-black", children: [w.jsxs(v6, { onMenuOpenChange: t, isMenuOpen: e, className: "bg-transparent", children: [w.jsxs(nh, { children: [w.jsx(w6, { "aria-label": e ? "Close menu" : "Open menu", className: "sm:hidden", onClick: l }), w.jsx(y6, { children: w.jsx(Oi, { to: "/", children: w.jsx("img", { className: "w-28 h-[100%]", src: I2, alt: "Logo", loading: "lazy" }) }) })] }), w.jsx(nh, { className: "hidden sm:flex gap-12", justify: "center", children: s.map((u, c) => w.jsx(b6, { className: "cursor-pointer", onClick: () => a(u.toLink), children: w.jsx("span", { className: "text-white", children: u.label }) }, `${u.label}-${c}`)) }), w.jsx(nh, { justify: "end", children: w.jsx(Lu, { text: "Contact us", toLink: "/contact-us" }) })] }), n && w.jsx("div", { className: "lg:hidden bg-black text-center p-4 space-y-4", children: s.map((u, c) => w.jsx("p", { onClick: () => a(u.toLink), className: "text-gray-300 font-semibold text-[1.5rem] cursor-pointer", children: u.label }, `${u.label}-${c}`)) })] }) }, N7 = new g2, O7 = () => { const [e, t] = S.useState([]); return w.jsx(v2, { client: N7, children: w.jsxs("div", { className: "bg-background text-white overflow-hidden", children: [w.jsx(L7, {}), w.jsx(u7, {}), w.jsx(_7, {}), e.map(n => w.jsxs("p", { children: [n.name, ",", n.description] }))] }) }) }, qf = ({ src: e, alt: t, className: n }) => { const [r, i] = S.useState(!1); return w.jsx("div", { className: `relative ${n} overflow-hidden`, children: w.jsx("img", { src: e, alt: t, loading: "lazy", className: ` object-cover transform group-hover:scale-105 transition-all duration-500 ${r ? "opacity-100  blur-none" : "opacity-25 blur-sm"} ${n}`, onLoad: () => i(!0) }) }) }, Wy = ({ blog: e }) => { var t, n, r; return w.jsx(Oi, { to: `https://blogs.journeystory.in/post/${e.slug.current}`, className: "group", children: w.jsx(oi.div, { initial: { scale: 1.2 }, whileInView: { scale: 1 }, transition: { duration: .2 }, className: "relative w-full overflow-hidden", children: w.jsxs(Fy, { className: "bg-transparent text-w-full h-fit pb-4 px-0", children: [w.jsx(j$, { className: "w-full aspect-w-16 aspect-h-9 flex-col items-start", children: (n = (t = e.mainImage) == null ? void 0 : t.asset) != null && n.url ? w.jsx(qf, { src: e.mainImage.asset.url, className: "object-cover h-full w-full", alt: e.title }) : w.jsx("div", { className: "w-full h-full bg-gray-300", "aria-label": "No image available" }) }), w.jsxs(dg, { className: "w-full mt-[-25px] flex flex-col gap-2 items-start", children: [e.categories && e.categories.length > 0 && w.jsx(u5, { color: "success", variant: "faded", size: "md", className: "mt-2", children: e.categories[0].title }), w.jsx("h3", { className: "text-xl md:text-2xl font-semibold p-0", children: e.title.length > 100 ? e.title.substr(0, 100) + "..." : e.title }), w.jsx("p", { className: "text-md md:text-md", children: ((r = e.excerpt) == null ? void 0 : r.length) > 200 ? e.excerpt.substr(0, 200) + "..." : e.excerpt })] })] }) }) }) };/*! @license DOMPurify 3.1.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.1.6/LICENSE */const { entries: F2, setPrototypeOf: P1, isFrozen: j7, getPrototypeOf: I7, getOwnPropertyDescriptor: D7 } = Object; let { freeze: un, seal: tr, create: z2 } = Object, { apply: wg, construct: xg } = typeof Reflect < "u" && Reflect; un || (un = function (t) { return t }); tr || (tr = function (t) { return t }); wg || (wg = function (t, n, r) { return t.apply(n, r) }); xg || (xg = function (t, n) { return new t(...n) }); const Cc = Nn(Array.prototype.forEach), $1 = Nn(Array.prototype.pop), Ua = Nn(Array.prototype.push), Zc = Nn(String.prototype.toLowerCase), lh = Nn(String.prototype.toString), A1 = Nn(String.prototype.match), Ha = Nn(String.prototype.replace), F7 = Nn(String.prototype.indexOf), z7 = Nn(String.prototype.trim), ar = Nn(Object.prototype.hasOwnProperty), on = Nn(RegExp.prototype.test), Wa = V7(TypeError); function Nn(e) { return function (t) { for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)r[i - 1] = arguments[i]; return wg(e, t, r) } } function V7(e) { return function () { for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)n[r] = arguments[r]; return xg(e, n) } } function Ee(e, t) { let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Zc; P1 && P1(e, null); let r = t.length; for (; r--;) { let i = t[r]; if (typeof i == "string") { const o = n(i); o !== i && (j7(t) || (t[r] = o), i = o) } e[i] = !0 } return e } function B7(e) { for (let t = 0; t < e.length; t++)ar(e, t) || (e[t] = null); return e } function fo(e) { const t = z2(null); for (const [n, r] of F2(e)) ar(e, n) && (Array.isArray(r) ? t[n] = B7(r) : r && typeof r == "object" && r.constructor === Object ? t[n] = fo(r) : t[n] = r); return t } function Ga(e, t) { for (; e !== null;) { const r = D7(e, t); if (r) { if (r.get) return Nn(r.get); if (typeof r.value == "function") return Nn(r.value) } e = I7(e) } function n() { return null } return n } const M1 = un(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), uh = un(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), ch = un(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), U7 = un(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), dh = un(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), H7 = un(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), k1 = un(["#text"]), _1 = un(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), fh = un(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), R1 = un(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Pc = un(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), W7 = tr(/\{\{[\w\W]*|[\w\W]*\}\}/gm), G7 = tr(/<%[\w\W]*|[\w\W]*%>/gm), K7 = tr(/\${[\w\W]*}/gm), q7 = tr(/^data-[\-\w.\u00B7-\uFFFF]/), Y7 = tr(/^aria-[\-\w]+$/), V2 = tr(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i), Q7 = tr(/^(?:\w+script|data):/i), X7 = tr(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), B2 = tr(/^html$/i), J7 = tr(/^[a-z][.\w]*(-[.\w]+)+$/i); var L1 = Object.freeze({ __proto__: null, MUSTACHE_EXPR: W7, ERB_EXPR: G7, TMPLIT_EXPR: K7, DATA_ATTR: q7, ARIA_ATTR: Y7, IS_ALLOWED_URI: V2, IS_SCRIPT_OR_DATA: Q7, ATTR_WHITESPACE: X7, DOCTYPE_NAME: B2, CUSTOM_ELEMENT: J7 }); const Ka = { element: 1, attribute: 2, text: 3, cdataSection: 4, entityReference: 5, entityNode: 6, progressingInstruction: 7, comment: 8, document: 9, documentType: 10, documentFragment: 11, notation: 12 }, Z7 = function () { return typeof window > "u" ? null : window }, e8 = function (t, n) { if (typeof t != "object" || typeof t.createPolicy != "function") return null; let r = null; const i = "data-tt-policy-suffix"; n && n.hasAttribute(i) && (r = n.getAttribute(i)); const o = "dompurify" + (r ? "#" + r : ""); try { return t.createPolicy(o, { createHTML(s) { return s }, createScriptURL(s) { return s } }) } catch { return console.warn("TrustedTypes policy " + o + " could not be created."), null } }; function U2() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Z7(); const t = ne => U2(ne); if (t.version = "3.1.6", t.removed = [], !e || !e.document || e.document.nodeType !== Ka.document) return t.isSupported = !1, t; let { document: n } = e; const r = n, i = r.currentScript, { DocumentFragment: o, HTMLTemplateElement: s, Node: a, Element: l, NodeFilter: u, NamedNodeMap: c = e.NamedNodeMap || e.MozNamedAttrMap, HTMLFormElement: d, DOMParser: f, trustedTypes: p } = e, m = l.prototype, v = Ga(m, "cloneNode"), x = Ga(m, "remove"), g = Ga(m, "nextSibling"), h = Ga(m, "childNodes"), y = Ga(m, "parentNode"); if (typeof s == "function") { const ne = n.createElement("template"); ne.content && ne.content.ownerDocument && (n = ne.content.ownerDocument) } let E, P = ""; const { implementation: $, createNodeIterator: L, createDocumentFragment: b, getElementsByTagName: M } = n, { importNode: R } = r; let A = {}; t.isSupported = typeof F2 == "function" && typeof y == "function" && $ && $.createHTMLDocument !== void 0; const { MUSTACHE_EXPR: _, ERB_EXPR: C, TMPLIT_EXPR: k, DATA_ATTR: O, ARIA_ATTR: U, IS_SCRIPT_OR_DATA: z, ATTR_WHITESPACE: D, CUSTOM_ELEMENT: V } = L1; let { IS_ALLOWED_URI: H } = L1, T = null; const N = Ee({}, [...M1, ...uh, ...ch, ...dh, ...k1]); let W = null; const Q = Ee({}, [..._1, ...fh, ...R1, ...Pc]); let q = Object.seal(z2(null, { tagNameCheck: { writable: !0, configurable: !1, enumerable: !0, value: null }, attributeNameCheck: { writable: !0, configurable: !1, enumerable: !0, value: null }, allowCustomizedBuiltInElements: { writable: !0, configurable: !1, enumerable: !0, value: !1 } })), te = null, ae = null, le = !0, oe = !0, ge = !1, Pe = !0, Oe = !1, gt = !0, Je = !1, it = !1, lt = !1, Jt = !1, Zt = !1, ye = !1, Ht = !0, en = !1; const jt = "user-content-"; let ut = !0, Wt = !1, Fn = {}, wn = null; const fn = Ee({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]); let tn = null; const zn = Ee({}, ["audio", "video", "img", "source", "image", "track"]); let Pt = null; const li = Ee({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), It = "http://www.w3.org/1998/Math/MathML", br = "http://www.w3.org/2000/svg", vt = "http://www.w3.org/1999/xhtml"; let Vn = vt, Lr = !1, Nr = null; const ui = Ee({}, [It, br, vt], lh); let xn = null; const io = ["application/xhtml+xml", "text/html"], nn = "text/html"; let ot = null, rr = null; const Ye = n.createElement("form"), oo = function (I) { return I instanceof RegExp || I instanceof Function }, wr = function () { let I = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; if (!(rr && rr === I)) { if ((!I || typeof I != "object") && (I = {}), I = fo(I), xn = io.indexOf(I.PARSER_MEDIA_TYPE) === -1 ? nn : I.PARSER_MEDIA_TYPE, ot = xn === "application/xhtml+xml" ? lh : Zc, T = ar(I, "ALLOWED_TAGS") ? Ee({}, I.ALLOWED_TAGS, ot) : N, W = ar(I, "ALLOWED_ATTR") ? Ee({}, I.ALLOWED_ATTR, ot) : Q, Nr = ar(I, "ALLOWED_NAMESPACES") ? Ee({}, I.ALLOWED_NAMESPACES, lh) : ui, Pt = ar(I, "ADD_URI_SAFE_ATTR") ? Ee(fo(li), I.ADD_URI_SAFE_ATTR, ot) : li, tn = ar(I, "ADD_DATA_URI_TAGS") ? Ee(fo(zn), I.ADD_DATA_URI_TAGS, ot) : zn, wn = ar(I, "FORBID_CONTENTS") ? Ee({}, I.FORBID_CONTENTS, ot) : fn, te = ar(I, "FORBID_TAGS") ? Ee({}, I.FORBID_TAGS, ot) : {}, ae = ar(I, "FORBID_ATTR") ? Ee({}, I.FORBID_ATTR, ot) : {}, Fn = ar(I, "USE_PROFILES") ? I.USE_PROFILES : !1, le = I.ALLOW_ARIA_ATTR !== !1, oe = I.ALLOW_DATA_ATTR !== !1, ge = I.ALLOW_UNKNOWN_PROTOCOLS || !1, Pe = I.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Oe = I.SAFE_FOR_TEMPLATES || !1, gt = I.SAFE_FOR_XML !== !1, Je = I.WHOLE_DOCUMENT || !1, Jt = I.RETURN_DOM || !1, Zt = I.RETURN_DOM_FRAGMENT || !1, ye = I.RETURN_TRUSTED_TYPE || !1, lt = I.FORCE_BODY || !1, Ht = I.SANITIZE_DOM !== !1, en = I.SANITIZE_NAMED_PROPS || !1, ut = I.KEEP_CONTENT !== !1, Wt = I.IN_PLACE || !1, H = I.ALLOWED_URI_REGEXP || V2, Vn = I.NAMESPACE || vt, q = I.CUSTOM_ELEMENT_HANDLING || {}, I.CUSTOM_ELEMENT_HANDLING && oo(I.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (q.tagNameCheck = I.CUSTOM_ELEMENT_HANDLING.tagNameCheck), I.CUSTOM_ELEMENT_HANDLING && oo(I.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (q.attributeNameCheck = I.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), I.CUSTOM_ELEMENT_HANDLING && typeof I.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (q.allowCustomizedBuiltInElements = I.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Oe && (oe = !1), Zt && (Jt = !0), Fn && (T = Ee({}, k1), W = [], Fn.html === !0 && (Ee(T, M1), Ee(W, _1)), Fn.svg === !0 && (Ee(T, uh), Ee(W, fh), Ee(W, Pc)), Fn.svgFilters === !0 && (Ee(T, ch), Ee(W, fh), Ee(W, Pc)), Fn.mathMl === !0 && (Ee(T, dh), Ee(W, R1), Ee(W, Pc))), I.ADD_TAGS && (T === N && (T = fo(T)), Ee(T, I.ADD_TAGS, ot)), I.ADD_ATTR && (W === Q && (W = fo(W)), Ee(W, I.ADD_ATTR, ot)), I.ADD_URI_SAFE_ATTR && Ee(Pt, I.ADD_URI_SAFE_ATTR, ot), I.FORBID_CONTENTS && (wn === fn && (wn = fo(wn)), Ee(wn, I.FORBID_CONTENTS, ot)), ut && (T["#text"] = !0), Je && Ee(T, ["html", "head", "body"]), T.table && (Ee(T, ["tbody"]), delete te.tbody), I.TRUSTED_TYPES_POLICY) { if (typeof I.TRUSTED_TYPES_POLICY.createHTML != "function") throw Wa('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.'); if (typeof I.TRUSTED_TYPES_POLICY.createScriptURL != "function") throw Wa('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.'); E = I.TRUSTED_TYPES_POLICY, P = E.createHTML("") } else E === void 0 && (E = e8(p, i)), E !== null && typeof P == "string" && (P = E.createHTML("")); un && un(I), rr = I } }, Or = Ee({}, ["mi", "mo", "mn", "ms", "mtext"]), rs = Ee({}, ["foreignobject", "annotation-xml"]), Ea = Ee({}, ["title", "style", "font", "a", "script"]), j = Ee({}, [...uh, ...ch, ...U7]), F = Ee({}, [...dh, ...H7]), B = function (I) { let Z = y(I); (!Z || !Z.tagName) && (Z = { namespaceURI: Vn, tagName: "template" }); const ce = Zc(I.tagName), Ae = Zc(Z.tagName); return Nr[I.namespaceURI] ? I.namespaceURI === br ? Z.namespaceURI === vt ? ce === "svg" : Z.namespaceURI === It ? ce === "svg" && (Ae === "annotation-xml" || Or[Ae]) : !!j[ce] : I.namespaceURI === It ? Z.namespaceURI === vt ? ce === "math" : Z.namespaceURI === br ? ce === "math" && rs[Ae] : !!F[ce] : I.namespaceURI === vt ? Z.namespaceURI === br && !rs[Ae] || Z.namespaceURI === It && !Or[Ae] ? !1 : !F[ce] && (Ea[ce] || !j[ce]) : !!(xn === "application/xhtml+xml" && Nr[I.namespaceURI]) : !1 }, K = function (I) { Ua(t.removed, { element: I }); try { y(I).removeChild(I) } catch { x(I) } }, ie = function (I, Z) { try { Ua(t.removed, { attribute: Z.getAttributeNode(I), from: Z }) } catch { Ua(t.removed, { attribute: null, from: Z }) } if (Z.removeAttribute(I), I === "is" && !W[I]) if (Jt || Zt) try { K(Z) } catch { } else try { Z.setAttribute(I, "") } catch { } }, X = function (I) { let Z = null, ce = null; if (lt) I = "<remove></remove>" + I; else { const ct = A1(I, /^[\r\n\t ]+/); ce = ct && ct[0] } xn === "application/xhtml+xml" && Vn === vt && (I = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + I + "</body></html>"); const Ae = E ? E.createHTML(I) : I; if (Vn === vt) try { Z = new f().parseFromString(Ae, xn) } catch { } if (!Z || !Z.documentElement) { Z = $.createDocument(Vn, "template", null); try { Z.documentElement.innerHTML = Lr ? P : Ae } catch { } } const ze = Z.body || Z.documentElement; return I && ce && ze.insertBefore(n.createTextNode(ce), ze.childNodes[0] || null), Vn === vt ? M.call(Z, Je ? "html" : "body")[0] : Je ? Z.documentElement : ze }, me = function (I) { return L.call(I.ownerDocument || I, I, u.SHOW_ELEMENT | u.SHOW_COMMENT | u.SHOW_TEXT | u.SHOW_PROCESSING_INSTRUCTION | u.SHOW_CDATA_SECTION, null) }, ue = function (I) { return I instanceof d && (typeof I.nodeName != "string" || typeof I.textContent != "string" || typeof I.removeChild != "function" || !(I.attributes instanceof c) || typeof I.removeAttribute != "function" || typeof I.setAttribute != "function" || typeof I.namespaceURI != "string" || typeof I.insertBefore != "function" || typeof I.hasChildNodes != "function") }, pe = function (I) { return typeof a == "function" && I instanceof a }, re = function (I, Z, ce) { A[I] && Cc(A[I], Ae => { Ae.call(t, Z, ce, rr) }) }, he = function (I) { let Z = null; if (re("beforeSanitizeElements", I, null), ue(I)) return K(I), !0; const ce = ot(I.nodeName); if (re("uponSanitizeElement", I, { tagName: ce, allowedTags: T }), I.hasChildNodes() && !pe(I.firstElementChild) && on(/<[/\w]/g, I.innerHTML) && on(/<[/\w]/g, I.textContent) || I.nodeType === Ka.progressingInstruction || gt && I.nodeType === Ka.comment && on(/<[/\w]/g, I.data)) return K(I), !0; if (!T[ce] || te[ce]) { if (!te[ce] && $e(ce) && (q.tagNameCheck instanceof RegExp && on(q.tagNameCheck, ce) || q.tagNameCheck instanceof Function && q.tagNameCheck(ce))) return !1; if (ut && !wn[ce]) { const Ae = y(I) || I.parentNode, ze = h(I) || I.childNodes; if (ze && Ae) { const ct = ze.length; for (let bt = ct - 1; bt >= 0; --bt) { const Rt = v(ze[bt], !0); Rt.__removalCount = (I.__removalCount || 0) + 1, Ae.insertBefore(Rt, g(I)) } } } return K(I), !0 } return I instanceof l && !B(I) || (ce === "noscript" || ce === "noembed" || ce === "noframes") && on(/<\/no(script|embed|frames)/i, I.innerHTML) ? (K(I), !0) : (Oe && I.nodeType === Ka.text && (Z = I.textContent, Cc([_, C, k], Ae => { Z = Ha(Z, Ae, " ") }), I.textContent !== Z && (Ua(t.removed, { element: I.cloneNode() }), I.textContent = Z)), re("afterSanitizeElements", I, null), !1) }, xe = function (I, Z, ce) { if (Ht && (Z === "id" || Z === "name") && (ce in n || ce in Ye)) return !1; if (!(oe && !ae[Z] && on(O, Z))) { if (!(le && on(U, Z))) { if (!W[Z] || ae[Z]) { if (!($e(I) && (q.tagNameCheck instanceof RegExp && on(q.tagNameCheck, I) || q.tagNameCheck instanceof Function && q.tagNameCheck(I)) && (q.attributeNameCheck instanceof RegExp && on(q.attributeNameCheck, Z) || q.attributeNameCheck instanceof Function && q.attributeNameCheck(Z)) || Z === "is" && q.allowCustomizedBuiltInElements && (q.tagNameCheck instanceof RegExp && on(q.tagNameCheck, ce) || q.tagNameCheck instanceof Function && q.tagNameCheck(ce)))) return !1 } else if (!Pt[Z]) { if (!on(H, Ha(ce, D, ""))) { if (!((Z === "src" || Z === "xlink:href" || Z === "href") && I !== "script" && F7(ce, "data:") === 0 && tn[I])) { if (!(ge && !on(z, Ha(ce, D, "")))) { if (ce) return !1 } } } } } } return !0 }, $e = function (I) { return I !== "annotation-xml" && A1(I, V) }, yt = function (I) { re("beforeSanitizeAttributes", I, null); const { attributes: Z } = I; if (!Z) return; const ce = { attrName: "", attrValue: "", keepAttr: !0, allowedAttributes: W }; let Ae = Z.length; for (; Ae--;) { const ze = Z[Ae], { name: ct, namespaceURI: bt, value: Rt } = ze, xr = ot(ct); let wt = ct === "value" ? Rt : z7(Rt); if (ce.attrName = xr, ce.attrValue = wt, ce.keepAttr = !0, ce.forceKeepAttr = void 0, re("uponSanitizeAttribute", I, ce), wt = ce.attrValue, gt && on(/((--!?|])>)|<\/(style|title)/i, wt)) { ie(ct, I); continue } if (ce.forceKeepAttr || (ie(ct, I), !ce.keepAttr)) continue; if (!Pe && on(/\/>/i, wt)) { ie(ct, I); continue } Oe && Cc([_, C, k], Be => { wt = Ha(wt, Be, " ") }); const _e = ot(I.nodeName); if (xe(_e, xr, wt)) { if (en && (xr === "id" || xr === "name") && (ie(ct, I), wt = jt + wt), E && typeof p == "object" && typeof p.getAttributeType == "function" && !bt) switch (p.getAttributeType(_e, xr)) { case "TrustedHTML": { wt = E.createHTML(wt); break } case "TrustedScriptURL": { wt = E.createScriptURL(wt); break } }try { bt ? I.setAttributeNS(bt, ct, wt) : I.setAttribute(ct, wt), ue(I) ? K(I) : $1(t.removed) } catch { } } } re("afterSanitizeAttributes", I, null) }, De = function ne(I) { let Z = null; const ce = me(I); for (re("beforeSanitizeShadowDOM", I, null); Z = ce.nextNode();)re("uponSanitizeShadowNode", Z, null), !he(Z) && (Z.content instanceof o && ne(Z.content), yt(Z)); re("afterSanitizeShadowDOM", I, null) }; return t.sanitize = function (ne) {
    let I = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Z = null, ce = null, Ae = null, ze = null; if (Lr = !ne, Lr && (ne = "<!-->"), typeof ne != "string" && !pe(ne)) if (typeof ne.toString == "function") { if (ne = ne.toString(), typeof ne != "string") throw Wa("dirty is not a string, aborting") } else throw Wa("toString is not a function"); if (!t.isSupported) return ne; if (it || wr(I), t.removed = [], typeof ne == "string" && (Wt = !1), Wt) { if (ne.nodeName) { const Rt = ot(ne.nodeName); if (!T[Rt] || te[Rt]) throw Wa("root node is forbidden and cannot be sanitized in-place") } } else if (ne instanceof a) Z = X("<!---->"), ce = Z.ownerDocument.importNode(ne, !0), ce.nodeType === Ka.element && ce.nodeName === "BODY" || ce.nodeName === "HTML" ? Z = ce : Z.appendChild(ce); else { if (!Jt && !Oe && !Je && ne.indexOf("<") === -1) return E && ye ? E.createHTML(ne) : ne; if (Z = X(ne), !Z) return Jt ? null : ye ? P : "" } Z && lt && K(Z.firstChild); const ct = me(Wt ? ne : Z); for (; Ae = ct.nextNode();)he(Ae) || (Ae.content instanceof o && De(Ae.content), yt(Ae)); if (Wt) return ne; if (Jt) { if (Zt) for (ze = b.call(Z.ownerDocument); Z.firstChild;)ze.appendChild(Z.firstChild); else ze = Z; return (W.shadowroot || W.shadowrootmode) && (ze = R.call(r, ze, !0)), ze } let bt = Je ? Z.outerHTML : Z.innerHTML; return Je && T["!doctype"] && Z.ownerDocument && Z.ownerDocument.doctype && Z.ownerDocument.doctype.name && on(B2, Z.ownerDocument.doctype.name) && (bt = "<!DOCTYPE " + Z.ownerDocument.doctype.name + `>
`+ bt), Oe && Cc([_, C, k], Rt => { bt = Ha(bt, Rt, " ") }), E && ye ? E.createHTML(bt) : bt
  }, t.setConfig = function () { let ne = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; wr(ne), it = !0 }, t.clearConfig = function () { rr = null, it = !1 }, t.isValidAttribute = function (ne, I, Z) { rr || wr({}); const ce = ot(ne), Ae = ot(I); return xe(ce, Ae, Z) }, t.addHook = function (ne, I) { typeof I == "function" && (A[ne] = A[ne] || [], Ua(A[ne], I)) }, t.removeHook = function (ne) { if (A[ne]) return $1(A[ne]) }, t.removeHooks = function (ne) { A[ne] && (A[ne] = []) }, t.removeAllHooks = function () { A = {} }, t
} var t8 = U2(); const n8 = ({ blog: e }) => { const t = t8.sanitize(e.content); return w.jsx("div", { className: "w-[80%] mx-auto mt-24", dangerouslySetInnerHTML: { __html: t } }) }, r8 = ({ blog: e }) => w.jsxs("div", { className: "flex flex-col gap-4 text-md w-full", children: [w.jsx("div", { className: "w-full", children: w.jsx(qf, { src: e == null ? void 0 : e.blogImageUrl, alt: e == null ? void 0 : e.title }) }), w.jsxs("div", { className: "flex flex-col gap-8 w-full items-start", children: [w.jsxs("div", { className: "flex justify-between gap-10 w-full", children: [w.jsx("span", { className: "text-primary", children: e.category }), w.jsx("span", { className: "text-mainText", children: e.date })] }), w.jsx("h1", { className: "text-2xl md:text-3xl lg:text-4xl font-semibold", children: e.title }), w.jsx(Q$, { name: e.author, description: e.authorProffesion, avatarProps: { src: e.authorImageUrl } }), w.jsx("div", { children: w.jsx("p", { className: "text-mainText", children: e.description }) })] })] }); function H2(e, t) { return function () { return e.apply(t, arguments) } } const { toString: i8 } = Object.prototype, { getPrototypeOf: Gy } = Object, Yf = (e => t => { const n = i8.call(t); return e[n] || (e[n] = n.slice(8, -1).toLowerCase()) })(Object.create(null)), yr = e => (e = e.toLowerCase(), t => Yf(t) === e), Qf = e => t => typeof t === e, { isArray: ba } = Array, iu = Qf("undefined"); function o8(e) { return e !== null && !iu(e) && e.constructor !== null && !iu(e.constructor) && kn(e.constructor.isBuffer) && e.constructor.isBuffer(e) } const W2 = yr("ArrayBuffer"); function s8(e) { let t; return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && W2(e.buffer), t } const a8 = Qf("string"), kn = Qf("function"), G2 = Qf("number"), Xf = e => e !== null && typeof e == "object", l8 = e => e === !0 || e === !1, ed = e => { if (Yf(e) !== "object") return !1; const t = Gy(e); return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e) }, u8 = yr("Date"), c8 = yr("File"), d8 = yr("Blob"), f8 = yr("FileList"), p8 = e => Xf(e) && kn(e.pipe), h8 = e => { let t; return e && (typeof FormData == "function" && e instanceof FormData || kn(e.append) && ((t = Yf(e)) === "formdata" || t === "object" && kn(e.toString) && e.toString() === "[object FormData]")) }, m8 = yr("URLSearchParams"), [g8, v8, y8, b8] = ["ReadableStream", "Request", "Response", "Headers"].map(yr), w8 = e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""); function Nu(e, t, { allOwnKeys: n = !1 } = {}) { if (e === null || typeof e > "u") return; let r, i; if (typeof e != "object" && (e = [e]), ba(e)) for (r = 0, i = e.length; r < i; r++)t.call(null, e[r], r, e); else { const o = n ? Object.getOwnPropertyNames(e) : Object.keys(e), s = o.length; let a; for (r = 0; r < s; r++)a = o[r], t.call(null, e[a], a, e) } } function K2(e, t) { t = t.toLowerCase(); const n = Object.keys(e); let r = n.length, i; for (; r-- > 0;)if (i = n[r], t === i.toLowerCase()) return i; return null } const To = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, q2 = e => !iu(e) && e !== To; function Sg() { const { caseless: e } = q2(this) && this || {}, t = {}, n = (r, i) => { const o = e && K2(t, i) || i; ed(t[o]) && ed(r) ? t[o] = Sg(t[o], r) : ed(r) ? t[o] = Sg({}, r) : ba(r) ? t[o] = r.slice() : t[o] = r }; for (let r = 0, i = arguments.length; r < i; r++)arguments[r] && Nu(arguments[r], n); return t } const x8 = (e, t, n, { allOwnKeys: r } = {}) => (Nu(t, (i, o) => { n && kn(i) ? e[o] = H2(i, n) : e[o] = i }, { allOwnKeys: r }), e), S8 = e => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), E8 = (e, t, n, r) => { e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", { value: t.prototype }), n && Object.assign(e.prototype, n) }, T8 = (e, t, n, r) => { let i, o, s; const a = {}; if (t = t || {}, e == null) return t; do { for (i = Object.getOwnPropertyNames(e), o = i.length; o-- > 0;)s = i[o], (!r || r(s, e, t)) && !a[s] && (t[s] = e[s], a[s] = !0); e = n !== !1 && Gy(e) } while (e && (!n || n(e, t)) && e !== Object.prototype); return t }, C8 = (e, t, n) => { e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length; const r = e.indexOf(t, n); return r !== -1 && r === n }, P8 = e => { if (!e) return null; if (ba(e)) return e; let t = e.length; if (!G2(t)) return null; const n = new Array(t); for (; t-- > 0;)n[t] = e[t]; return n }, $8 = (e => t => e && t instanceof e)(typeof Uint8Array < "u" && Gy(Uint8Array)), A8 = (e, t) => { const r = (e && e[Symbol.iterator]).call(e); let i; for (; (i = r.next()) && !i.done;) { const o = i.value; t.call(e, o[0], o[1]) } }, M8 = (e, t) => { let n; const r = []; for (; (n = e.exec(t)) !== null;)r.push(n); return r }, k8 = yr("HTMLFormElement"), _8 = e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (n, r, i) { return r.toUpperCase() + i }), N1 = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), R8 = yr("RegExp"), Y2 = (e, t) => { const n = Object.getOwnPropertyDescriptors(e), r = {}; Nu(n, (i, o) => { let s; (s = t(i, o, e)) !== !1 && (r[o] = s || i) }), Object.defineProperties(e, r) }, L8 = e => { Y2(e, (t, n) => { if (kn(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1) return !1; const r = e[n]; if (kn(r)) { if (t.enumerable = !1, "writable" in t) { t.writable = !1; return } t.set || (t.set = () => { throw Error("Can not rewrite read-only method '" + n + "'") }) } }) }, N8 = (e, t) => { const n = {}, r = i => { i.forEach(o => { n[o] = !0 }) }; return ba(e) ? r(e) : r(String(e).split(t)), n }, O8 = () => { }, j8 = (e, t) => e != null && Number.isFinite(e = +e) ? e : t, ph = "abcdefghijklmnopqrstuvwxyz", O1 = "0123456789", Q2 = { DIGIT: O1, ALPHA: ph, ALPHA_DIGIT: ph + ph.toUpperCase() + O1 }, I8 = (e = 16, t = Q2.ALPHA_DIGIT) => { let n = ""; const { length: r } = t; for (; e--;)n += t[Math.random() * r | 0]; return n }; function D8(e) { return !!(e && kn(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]) } const F8 = e => { const t = new Array(10), n = (r, i) => { if (Xf(r)) { if (t.indexOf(r) >= 0) return; if (!("toJSON" in r)) { t[i] = r; const o = ba(r) ? [] : {}; return Nu(r, (s, a) => { const l = n(s, i + 1); !iu(l) && (o[a] = l) }), t[i] = void 0, o } } return r }; return n(e, 0) }, z8 = yr("AsyncFunction"), V8 = e => e && (Xf(e) || kn(e)) && kn(e.then) && kn(e.catch), X2 = ((e, t) => e ? setImmediate : t ? ((n, r) => (To.addEventListener("message", ({ source: i, data: o }) => { i === To && o === n && r.length && r.shift()() }, !1), i => { r.push(i), To.postMessage(n, "*") }))(`axios@${Math.random()}`, []) : n => setTimeout(n))(typeof setImmediate == "function", kn(To.postMessage)), B8 = typeof queueMicrotask < "u" ? queueMicrotask.bind(To) : typeof process < "u" && process.nextTick || X2, G = { isArray: ba, isArrayBuffer: W2, isBuffer: o8, isFormData: h8, isArrayBufferView: s8, isString: a8, isNumber: G2, isBoolean: l8, isObject: Xf, isPlainObject: ed, isReadableStream: g8, isRequest: v8, isResponse: y8, isHeaders: b8, isUndefined: iu, isDate: u8, isFile: c8, isBlob: d8, isRegExp: R8, isFunction: kn, isStream: p8, isURLSearchParams: m8, isTypedArray: $8, isFileList: f8, forEach: Nu, merge: Sg, extend: x8, trim: w8, stripBOM: S8, inherits: E8, toFlatObject: T8, kindOf: Yf, kindOfTest: yr, endsWith: C8, toArray: P8, forEachEntry: A8, matchAll: M8, isHTMLForm: k8, hasOwnProperty: N1, hasOwnProp: N1, reduceDescriptors: Y2, freezeMethods: L8, toObjectSet: N8, toCamelCase: _8, noop: O8, toFiniteNumber: j8, findKey: K2, global: To, isContextDefined: q2, ALPHABET: Q2, generateString: I8, isSpecCompliantForm: D8, toJSONObject: F8, isAsyncFn: z8, isThenable: V8, setImmediate: X2, asap: B8 }; function be(e, t, n, r, i) { Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), i && (this.response = i, this.status = i.status ? i.status : null) } G.inherits(be, Error, { toJSON: function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: G.toJSONObject(this.config), code: this.code, status: this.status } } }); const J2 = be.prototype, Z2 = {};["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(e => { Z2[e] = { value: e } }); Object.defineProperties(be, Z2); Object.defineProperty(J2, "isAxiosError", { value: !0 }); be.from = (e, t, n, r, i, o) => { const s = Object.create(J2); return G.toFlatObject(e, s, function (l) { return l !== Error.prototype }, a => a !== "isAxiosError"), be.call(s, e.message, t, n, r, i), s.cause = e, s.name = e.name, o && Object.assign(s, o), s }; const U8 = null; function Eg(e) { return G.isPlainObject(e) || G.isArray(e) } function eA(e) { return G.endsWith(e, "[]") ? e.slice(0, -2) : e } function j1(e, t, n) { return e ? e.concat(t).map(function (i, o) { return i = eA(i), !n && o ? "[" + i + "]" : i }).join(n ? "." : "") : t } function H8(e) { return G.isArray(e) && !e.some(Eg) } const W8 = G.toFlatObject(G, {}, null, function (t) { return /^is[A-Z]/.test(t) }); function Jf(e, t, n) { if (!G.isObject(e)) throw new TypeError("target must be an object"); t = t || new FormData, n = G.toFlatObject(n, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function (v, x) { return !G.isUndefined(x[v]) }); const r = n.metaTokens, i = n.visitor || c, o = n.dots, s = n.indexes, l = (n.Blob || typeof Blob < "u" && Blob) && G.isSpecCompliantForm(t); if (!G.isFunction(i)) throw new TypeError("visitor must be a function"); function u(m) { if (m === null) return ""; if (G.isDate(m)) return m.toISOString(); if (!l && G.isBlob(m)) throw new be("Blob is not supported. Use a Buffer instead."); return G.isArrayBuffer(m) || G.isTypedArray(m) ? l && typeof Blob == "function" ? new Blob([m]) : Buffer.from(m) : m } function c(m, v, x) { let g = m; if (m && !x && typeof m == "object") { if (G.endsWith(v, "{}")) v = r ? v : v.slice(0, -2), m = JSON.stringify(m); else if (G.isArray(m) && H8(m) || (G.isFileList(m) || G.endsWith(v, "[]")) && (g = G.toArray(m))) return v = eA(v), g.forEach(function (y, E) { !(G.isUndefined(y) || y === null) && t.append(s === !0 ? j1([v], E, o) : s === null ? v : v + "[]", u(y)) }), !1 } return Eg(m) ? !0 : (t.append(j1(x, v, o), u(m)), !1) } const d = [], f = Object.assign(W8, { defaultVisitor: c, convertValue: u, isVisitable: Eg }); function p(m, v) { if (!G.isUndefined(m)) { if (d.indexOf(m) !== -1) throw Error("Circular reference detected in " + v.join(".")); d.push(m), G.forEach(m, function (g, h) { (!(G.isUndefined(g) || g === null) && i.call(t, g, G.isString(h) ? h.trim() : h, v, f)) === !0 && p(g, v ? v.concat(h) : [h]) }), d.pop() } } if (!G.isObject(e)) throw new TypeError("data must be an object"); return p(e), t } function I1(e) { const t = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }; return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function (r) { return t[r] }) } function Ky(e, t) { this._pairs = [], e && Jf(e, this, t) } const tA = Ky.prototype; tA.append = function (t, n) { this._pairs.push([t, n]) }; tA.toString = function (t) { const n = t ? function (r) { return t.call(this, r, I1) } : I1; return this._pairs.map(function (i) { return n(i[0]) + "=" + n(i[1]) }, "").join("&") }; function G8(e) { return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]") } function nA(e, t, n) { if (!t) return e; const r = n && n.encode || G8, i = n && n.serialize; let o; if (i ? o = i(t, n) : o = G.isURLSearchParams(t) ? t.toString() : new Ky(t, n).toString(r), o) { const s = e.indexOf("#"); s !== -1 && (e = e.slice(0, s)), e += (e.indexOf("?") === -1 ? "?" : "&") + o } return e } class D1 { constructor() { this.handlers = [] } use(t, n, r) { return this.handlers.push({ fulfilled: t, rejected: n, synchronous: r ? r.synchronous : !1, runWhen: r ? r.runWhen : null }), this.handlers.length - 1 } eject(t) { this.handlers[t] && (this.handlers[t] = null) } clear() { this.handlers && (this.handlers = []) } forEach(t) { G.forEach(this.handlers, function (r) { r !== null && t(r) }) } } const rA = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, K8 = typeof URLSearchParams < "u" ? URLSearchParams : Ky, q8 = typeof FormData < "u" ? FormData : null, Y8 = typeof Blob < "u" ? Blob : null, Q8 = { isBrowser: !0, classes: { URLSearchParams: K8, FormData: q8, Blob: Y8 }, protocols: ["http", "https", "file", "blob", "url", "data"] }, qy = typeof window < "u" && typeof document < "u", Tg = typeof navigator == "object" && navigator || void 0, X8 = qy && (!Tg || ["ReactNative", "NativeScript", "NS"].indexOf(Tg.product) < 0), J8 = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function", Z8 = qy && window.location.href || "http://localhost", ez = Object.freeze(Object.defineProperty({ __proto__: null, hasBrowserEnv: qy, hasStandardBrowserEnv: X8, hasStandardBrowserWebWorkerEnv: J8, navigator: Tg, origin: Z8 }, Symbol.toStringTag, { value: "Module" })), _n = { ...ez, ...Q8 }; function tz(e, t) { return Jf(e, new _n.classes.URLSearchParams, Object.assign({ visitor: function (n, r, i, o) { return _n.isNode && G.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : o.defaultVisitor.apply(this, arguments) } }, t)) } function nz(e) { return G.matchAll(/\w+|\[(\w*)]/g, e).map(t => t[0] === "[]" ? "" : t[1] || t[0]) } function rz(e) { const t = {}, n = Object.keys(e); let r; const i = n.length; let o; for (r = 0; r < i; r++)o = n[r], t[o] = e[o]; return t } function iA(e) { function t(n, r, i, o) { let s = n[o++]; if (s === "__proto__") return !0; const a = Number.isFinite(+s), l = o >= n.length; return s = !s && G.isArray(i) ? i.length : s, l ? (G.hasOwnProp(i, s) ? i[s] = [i[s], r] : i[s] = r, !a) : ((!i[s] || !G.isObject(i[s])) && (i[s] = []), t(n, r, i[s], o) && G.isArray(i[s]) && (i[s] = rz(i[s])), !a) } if (G.isFormData(e) && G.isFunction(e.entries)) { const n = {}; return G.forEachEntry(e, (r, i) => { t(nz(r), i, n, 0) }), n } return null } function iz(e, t, n) { if (G.isString(e)) try { return (t || JSON.parse)(e), G.trim(e) } catch (r) { if (r.name !== "SyntaxError") throw r } return (0, JSON.stringify)(e) } const Ou = { transitional: rA, adapter: ["xhr", "http", "fetch"], transformRequest: [function (t, n) { const r = n.getContentType() || "", i = r.indexOf("application/json") > -1, o = G.isObject(t); if (o && G.isHTMLForm(t) && (t = new FormData(t)), G.isFormData(t)) return i ? JSON.stringify(iA(t)) : t; if (G.isArrayBuffer(t) || G.isBuffer(t) || G.isStream(t) || G.isFile(t) || G.isBlob(t) || G.isReadableStream(t)) return t; if (G.isArrayBufferView(t)) return t.buffer; if (G.isURLSearchParams(t)) return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString(); let a; if (o) { if (r.indexOf("application/x-www-form-urlencoded") > -1) return tz(t, this.formSerializer).toString(); if ((a = G.isFileList(t)) || r.indexOf("multipart/form-data") > -1) { const l = this.env && this.env.FormData; return Jf(a ? { "files[]": t } : t, l && new l, this.formSerializer) } } return o || i ? (n.setContentType("application/json", !1), iz(t)) : t }], transformResponse: [function (t) { const n = this.transitional || Ou.transitional, r = n && n.forcedJSONParsing, i = this.responseType === "json"; if (G.isResponse(t) || G.isReadableStream(t)) return t; if (t && G.isString(t) && (r && !this.responseType || i)) { const s = !(n && n.silentJSONParsing) && i; try { return JSON.parse(t) } catch (a) { if (s) throw a.name === "SyntaxError" ? be.from(a, be.ERR_BAD_RESPONSE, this, null, this.response) : a } } return t }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: _n.classes.FormData, Blob: _n.classes.Blob }, validateStatus: function (t) { return t >= 200 && t < 300 }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } }; G.forEach(["delete", "get", "head", "post", "put", "patch"], e => { Ou.headers[e] = {} }); const oz = G.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), sz = e => {
  const t = {}; let n, r, i; return e && e.split(`
`).forEach(function (s) { i = s.indexOf(":"), n = s.substring(0, i).trim().toLowerCase(), r = s.substring(i + 1).trim(), !(!n || t[n] && oz[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r) }), t
}, F1 = Symbol("internals"); function qa(e) { return e && String(e).trim().toLowerCase() } function td(e) { return e === !1 || e == null ? e : G.isArray(e) ? e.map(td) : String(e) } function az(e) { const t = Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let r; for (; r = n.exec(e);)t[r[1]] = r[2]; return t } const lz = e => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim()); function hh(e, t, n, r, i) { if (G.isFunction(r)) return r.call(this, t, n); if (i && (t = n), !!G.isString(t)) { if (G.isString(r)) return t.indexOf(r) !== -1; if (G.isRegExp(r)) return r.test(t) } } function uz(e) { return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r) } function cz(e, t) { const n = G.toCamelCase(" " + t);["get", "set", "has"].forEach(r => { Object.defineProperty(e, r + n, { value: function (i, o, s) { return this[r].call(this, t, i, o, s) }, configurable: !0 }) }) } class bn {
  constructor(t) { t && this.set(t) } set(t, n, r) { const i = this; function o(a, l, u) { const c = qa(l); if (!c) throw new Error("header name must be a non-empty string"); const d = G.findKey(i, c); (!d || i[d] === void 0 || u === !0 || u === void 0 && i[d] !== !1) && (i[d || l] = td(a)) } const s = (a, l) => G.forEach(a, (u, c) => o(u, c, l)); if (G.isPlainObject(t) || t instanceof this.constructor) s(t, n); else if (G.isString(t) && (t = t.trim()) && !lz(t)) s(sz(t), n); else if (G.isHeaders(t)) for (const [a, l] of t.entries()) o(l, a, r); else t != null && o(n, t, r); return this } get(t, n) { if (t = qa(t), t) { const r = G.findKey(this, t); if (r) { const i = this[r]; if (!n) return i; if (n === !0) return az(i); if (G.isFunction(n)) return n.call(this, i, r); if (G.isRegExp(n)) return n.exec(i); throw new TypeError("parser must be boolean|regexp|function") } } } has(t, n) { if (t = qa(t), t) { const r = G.findKey(this, t); return !!(r && this[r] !== void 0 && (!n || hh(this, this[r], r, n))) } return !1 } delete(t, n) { const r = this; let i = !1; function o(s) { if (s = qa(s), s) { const a = G.findKey(r, s); a && (!n || hh(r, r[a], a, n)) && (delete r[a], i = !0) } } return G.isArray(t) ? t.forEach(o) : o(t), i } clear(t) { const n = Object.keys(this); let r = n.length, i = !1; for (; r--;) { const o = n[r]; (!t || hh(this, this[o], o, t, !0)) && (delete this[o], i = !0) } return i } normalize(t) { const n = this, r = {}; return G.forEach(this, (i, o) => { const s = G.findKey(r, o); if (s) { n[s] = td(i), delete n[o]; return } const a = t ? uz(o) : String(o).trim(); a !== o && delete n[o], n[a] = td(i), r[a] = !0 }), this } concat(...t) { return this.constructor.concat(this, ...t) } toJSON(t) { const n = Object.create(null); return G.forEach(this, (r, i) => { r != null && r !== !1 && (n[i] = t && G.isArray(r) ? r.join(", ") : r) }), n } [Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() } toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`)
  } get [Symbol.toStringTag]() { return "AxiosHeaders" } static from(t) { return t instanceof this ? t : new this(t) } static concat(t, ...n) { const r = new this(t); return n.forEach(i => r.set(i)), r } static accessor(t) { const r = (this[F1] = this[F1] = { accessors: {} }).accessors, i = this.prototype; function o(s) { const a = qa(s); r[a] || (cz(i, s), r[a] = !0) } return G.isArray(t) ? t.forEach(o) : o(t), this }
} bn.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]); G.reduceDescriptors(bn.prototype, ({ value: e }, t) => { let n = t[0].toUpperCase() + t.slice(1); return { get: () => e, set(r) { this[n] = r } } }); G.freezeMethods(bn); function mh(e, t) { const n = this || Ou, r = t || n, i = bn.from(r.headers); let o = r.data; return G.forEach(e, function (a) { o = a.call(n, o, i.normalize(), t ? t.status : void 0) }), i.normalize(), o } function oA(e) { return !!(e && e.__CANCEL__) } function wa(e, t, n) { be.call(this, e ?? "canceled", be.ERR_CANCELED, t, n), this.name = "CanceledError" } G.inherits(wa, be, { __CANCEL__: !0 }); function sA(e, t, n) { const r = n.config.validateStatus; !n.status || !r || r(n.status) ? e(n) : t(new be("Request failed with status code " + n.status, [be.ERR_BAD_REQUEST, be.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4], n.config, n.request, n)) } function dz(e) { const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e); return t && t[1] || "" } function fz(e, t) { e = e || 10; const n = new Array(e), r = new Array(e); let i = 0, o = 0, s; return t = t !== void 0 ? t : 1e3, function (l) { const u = Date.now(), c = r[o]; s || (s = u), n[i] = l, r[i] = u; let d = o, f = 0; for (; d !== i;)f += n[d++], d = d % e; if (i = (i + 1) % e, i === o && (o = (o + 1) % e), u - s < t) return; const p = c && u - c; return p ? Math.round(f * 1e3 / p) : void 0 } } function pz(e, t) { let n = 0, r = 1e3 / t, i, o; const s = (u, c = Date.now()) => { n = c, i = null, o && (clearTimeout(o), o = null), e.apply(null, u) }; return [(...u) => { const c = Date.now(), d = c - n; d >= r ? s(u, c) : (i = u, o || (o = setTimeout(() => { o = null, s(i) }, r - d))) }, () => i && s(i)] } const Jd = (e, t, n = 3) => { let r = 0; const i = fz(50, 250); return pz(o => { const s = o.loaded, a = o.lengthComputable ? o.total : void 0, l = s - r, u = i(l), c = s <= a; r = s; const d = { loaded: s, total: a, progress: a ? s / a : void 0, bytes: l, rate: u || void 0, estimated: u && a && c ? (a - s) / u : void 0, event: o, lengthComputable: a != null, [t ? "download" : "upload"]: !0 }; e(d) }, n) }, z1 = (e, t) => { const n = e != null; return [r => t[0]({ lengthComputable: n, total: e, loaded: r }), t[1]] }, V1 = e => (...t) => G.asap(() => e(...t)), hz = _n.hasStandardBrowserEnv ? function () { const t = _n.navigator && /(msie|trident)/i.test(_n.navigator.userAgent), n = document.createElement("a"); let r; function i(o) { let s = o; return t && (n.setAttribute("href", s), s = n.href), n.setAttribute("href", s), { href: n.href, protocol: n.protocol ? n.protocol.replace(/:$/, "") : "", host: n.host, search: n.search ? n.search.replace(/^\?/, "") : "", hash: n.hash ? n.hash.replace(/^#/, "") : "", hostname: n.hostname, port: n.port, pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname } } return r = i(window.location.href), function (s) { const a = G.isString(s) ? i(s) : s; return a.protocol === r.protocol && a.host === r.host } }() : function () { return function () { return !0 } }(), mz = _n.hasStandardBrowserEnv ? { write(e, t, n, r, i, o) { const s = [e + "=" + encodeURIComponent(t)]; G.isNumber(n) && s.push("expires=" + new Date(n).toGMTString()), G.isString(r) && s.push("path=" + r), G.isString(i) && s.push("domain=" + i), o === !0 && s.push("secure"), document.cookie = s.join("; ") }, read(e) { const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)")); return t ? decodeURIComponent(t[3]) : null }, remove(e) { this.write(e, "", Date.now() - 864e5) } } : { write() { }, read() { return null }, remove() { } }; function gz(e) { return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e) } function vz(e, t) { return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e } function aA(e, t) { return e && !gz(t) ? vz(e, t) : t } const B1 = e => e instanceof bn ? { ...e } : e; function Ho(e, t) { t = t || {}; const n = {}; function r(u, c, d) { return G.isPlainObject(u) && G.isPlainObject(c) ? G.merge.call({ caseless: d }, u, c) : G.isPlainObject(c) ? G.merge({}, c) : G.isArray(c) ? c.slice() : c } function i(u, c, d) { if (G.isUndefined(c)) { if (!G.isUndefined(u)) return r(void 0, u, d) } else return r(u, c, d) } function o(u, c) { if (!G.isUndefined(c)) return r(void 0, c) } function s(u, c) { if (G.isUndefined(c)) { if (!G.isUndefined(u)) return r(void 0, u) } else return r(void 0, c) } function a(u, c, d) { if (d in t) return r(u, c); if (d in e) return r(void 0, u) } const l = { url: o, method: o, data: o, baseURL: s, transformRequest: s, transformResponse: s, paramsSerializer: s, timeout: s, timeoutMessage: s, withCredentials: s, withXSRFToken: s, adapter: s, responseType: s, xsrfCookieName: s, xsrfHeaderName: s, onUploadProgress: s, onDownloadProgress: s, decompress: s, maxContentLength: s, maxBodyLength: s, beforeRedirect: s, transport: s, httpAgent: s, httpsAgent: s, cancelToken: s, socketPath: s, responseEncoding: s, validateStatus: a, headers: (u, c) => i(B1(u), B1(c), !0) }; return G.forEach(Object.keys(Object.assign({}, e, t)), function (c) { const d = l[c] || i, f = d(e[c], t[c], c); G.isUndefined(f) && d !== a || (n[c] = f) }), n } const lA = e => { const t = Ho({}, e); let { data: n, withXSRFToken: r, xsrfHeaderName: i, xsrfCookieName: o, headers: s, auth: a } = t; t.headers = s = bn.from(s), t.url = nA(aA(t.baseURL, t.url), e.params, e.paramsSerializer), a && s.set("Authorization", "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))); let l; if (G.isFormData(n)) { if (_n.hasStandardBrowserEnv || _n.hasStandardBrowserWebWorkerEnv) s.setContentType(void 0); else if ((l = s.getContentType()) !== !1) { const [u, ...c] = l ? l.split(";").map(d => d.trim()).filter(Boolean) : []; s.setContentType([u || "multipart/form-data", ...c].join("; ")) } } if (_n.hasStandardBrowserEnv && (r && G.isFunction(r) && (r = r(t)), r || r !== !1 && hz(t.url))) { const u = i && o && mz.read(o); u && s.set(i, u) } return t }, yz = typeof XMLHttpRequest < "u", bz = yz && function (e) { return new Promise(function (n, r) { const i = lA(e); let o = i.data; const s = bn.from(i.headers).normalize(); let { responseType: a, onUploadProgress: l, onDownloadProgress: u } = i, c, d, f, p, m; function v() { p && p(), m && m(), i.cancelToken && i.cancelToken.unsubscribe(c), i.signal && i.signal.removeEventListener("abort", c) } let x = new XMLHttpRequest; x.open(i.method.toUpperCase(), i.url, !0), x.timeout = i.timeout; function g() { if (!x) return; const y = bn.from("getAllResponseHeaders" in x && x.getAllResponseHeaders()), P = { data: !a || a === "text" || a === "json" ? x.responseText : x.response, status: x.status, statusText: x.statusText, headers: y, config: e, request: x }; sA(function (L) { n(L), v() }, function (L) { r(L), v() }, P), x = null } "onloadend" in x ? x.onloadend = g : x.onreadystatechange = function () { !x || x.readyState !== 4 || x.status === 0 && !(x.responseURL && x.responseURL.indexOf("file:") === 0) || setTimeout(g) }, x.onabort = function () { x && (r(new be("Request aborted", be.ECONNABORTED, e, x)), x = null) }, x.onerror = function () { r(new be("Network Error", be.ERR_NETWORK, e, x)), x = null }, x.ontimeout = function () { let E = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded"; const P = i.transitional || rA; i.timeoutErrorMessage && (E = i.timeoutErrorMessage), r(new be(E, P.clarifyTimeoutError ? be.ETIMEDOUT : be.ECONNABORTED, e, x)), x = null }, o === void 0 && s.setContentType(null), "setRequestHeader" in x && G.forEach(s.toJSON(), function (E, P) { x.setRequestHeader(P, E) }), G.isUndefined(i.withCredentials) || (x.withCredentials = !!i.withCredentials), a && a !== "json" && (x.responseType = i.responseType), u && ([f, m] = Jd(u, !0), x.addEventListener("progress", f)), l && x.upload && ([d, p] = Jd(l), x.upload.addEventListener("progress", d), x.upload.addEventListener("loadend", p)), (i.cancelToken || i.signal) && (c = y => { x && (r(!y || y.type ? new wa(null, e, x) : y), x.abort(), x = null) }, i.cancelToken && i.cancelToken.subscribe(c), i.signal && (i.signal.aborted ? c() : i.signal.addEventListener("abort", c))); const h = dz(i.url); if (h && _n.protocols.indexOf(h) === -1) { r(new be("Unsupported protocol " + h + ":", be.ERR_BAD_REQUEST, e)); return } x.send(o || null) }) }, wz = (e, t) => { let n = new AbortController, r; const i = function (l) { if (!r) { r = !0, s(); const u = l instanceof Error ? l : this.reason; n.abort(u instanceof be ? u : new wa(u instanceof Error ? u.message : u)) } }; let o = t && setTimeout(() => { i(new be(`timeout ${t} of ms exceeded`, be.ETIMEDOUT)) }, t); const s = () => { e && (o && clearTimeout(o), o = null, e.forEach(l => { l && (l.removeEventListener ? l.removeEventListener("abort", i) : l.unsubscribe(i)) }), e = null) }; e.forEach(l => l && l.addEventListener && l.addEventListener("abort", i)); const { signal: a } = n; return a.unsubscribe = s, [a, () => { o && clearTimeout(o), o = null }] }, xz = function* (e, t) { let n = e.byteLength; if (n < t) { yield e; return } let r = 0, i; for (; r < n;)i = r + t, yield e.slice(r, i), r = i }, Sz = async function* (e, t, n) { for await (const r of e) yield* xz(ArrayBuffer.isView(r) ? r : await n(String(r)), t) }, U1 = (e, t, n, r, i) => { const o = Sz(e, t, i); let s = 0, a, l = u => { a || (a = !0, r && r(u)) }; return new ReadableStream({ async pull(u) { try { const { done: c, value: d } = await o.next(); if (c) { l(), u.close(); return } let f = d.byteLength; if (n) { let p = s += f; n(p) } u.enqueue(new Uint8Array(d)) } catch (c) { throw l(c), c } }, cancel(u) { return l(u), o.return() } }, { highWaterMark: 2 }) }, Zf = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", uA = Zf && typeof ReadableStream == "function", Cg = Zf && (typeof TextEncoder == "function" ? (e => t => e.encode(t))(new TextEncoder) : async e => new Uint8Array(await new Response(e).arrayBuffer())), cA = (e, ...t) => { try { return !!e(...t) } catch { return !1 } }, Ez = uA && cA(() => { let e = !1; const t = new Request(_n.origin, { body: new ReadableStream, method: "POST", get duplex() { return e = !0, "half" } }).headers.has("Content-Type"); return e && !t }), H1 = 64 * 1024, Pg = uA && cA(() => G.isReadableStream(new Response("").body)), Zd = { stream: Pg && (e => e.body) }; Zf && (e => { ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(t => { !Zd[t] && (Zd[t] = G.isFunction(e[t]) ? n => n[t]() : (n, r) => { throw new be(`Response type '${t}' is not supported`, be.ERR_NOT_SUPPORT, r) }) }) })(new Response); const Tz = async e => { if (e == null) return 0; if (G.isBlob(e)) return e.size; if (G.isSpecCompliantForm(e)) return (await new Request(e).arrayBuffer()).byteLength; if (G.isArrayBufferView(e) || G.isArrayBuffer(e)) return e.byteLength; if (G.isURLSearchParams(e) && (e = e + ""), G.isString(e)) return (await Cg(e)).byteLength }, Cz = async (e, t) => { const n = G.toFiniteNumber(e.getContentLength()); return n ?? Tz(t) }, Pz = Zf && (async e => { let { url: t, method: n, data: r, signal: i, cancelToken: o, timeout: s, onDownloadProgress: a, onUploadProgress: l, responseType: u, headers: c, withCredentials: d = "same-origin", fetchOptions: f } = lA(e); u = u ? (u + "").toLowerCase() : "text"; let [p, m] = i || o || s ? wz([i, o], s) : [], v, x; const g = () => { !v && setTimeout(() => { p && p.unsubscribe() }), v = !0 }; let h; try { if (l && Ez && n !== "get" && n !== "head" && (h = await Cz(c, r)) !== 0) { let L = new Request(t, { method: "POST", body: r, duplex: "half" }), b; if (G.isFormData(r) && (b = L.headers.get("content-type")) && c.setContentType(b), L.body) { const [M, R] = z1(h, Jd(V1(l))); r = U1(L.body, H1, M, R, Cg) } } G.isString(d) || (d = d ? "include" : "omit"); const y = "credentials" in Request.prototype; x = new Request(t, { ...f, signal: p, method: n.toUpperCase(), headers: c.normalize().toJSON(), body: r, duplex: "half", credentials: y ? d : void 0 }); let E = await fetch(x); const P = Pg && (u === "stream" || u === "response"); if (Pg && (a || P)) { const L = {};["status", "statusText", "headers"].forEach(A => { L[A] = E[A] }); const b = G.toFiniteNumber(E.headers.get("content-length")), [M, R] = a && z1(b, Jd(V1(a), !0)) || []; E = new Response(U1(E.body, H1, M, () => { R && R(), P && g() }, Cg), L) } u = u || "text"; let $ = await Zd[G.findKey(Zd, u) || "text"](E, e); return !P && g(), m && m(), await new Promise((L, b) => { sA(L, b, { data: $, headers: bn.from(E.headers), status: E.status, statusText: E.statusText, config: e, request: x }) }) } catch (y) { throw g(), y && y.name === "TypeError" && /fetch/i.test(y.message) ? Object.assign(new be("Network Error", be.ERR_NETWORK, e, x), { cause: y.cause || y }) : be.from(y, y && y.code, e, x) } }), $g = { http: U8, xhr: bz, fetch: Pz }; G.forEach($g, (e, t) => { if (e) { try { Object.defineProperty(e, "name", { value: t }) } catch { } Object.defineProperty(e, "adapterName", { value: t }) } }); const W1 = e => `- ${e}`, $z = e => G.isFunction(e) || e === null || e === !1, dA = {
  getAdapter: e => {
    e = G.isArray(e) ? e : [e]; const { length: t } = e; let n, r; const i = {}; for (let o = 0; o < t; o++) { n = e[o]; let s; if (r = n, !$z(n) && (r = $g[(s = String(n)).toLowerCase()], r === void 0)) throw new be(`Unknown adapter '${s}'`); if (r) break; i[s || "#" + o] = r } if (!r) {
      const o = Object.entries(i).map(([a, l]) => `adapter ${a} ` + (l === !1 ? "is not supported by the environment" : "is not available in the build")); let s = t ? o.length > 1 ? `since :
`+ o.map(W1).join(`
`) : " " + W1(o[0]) : "as no adapter specified"; throw new be("There is no suitable adapter to dispatch the request " + s, "ERR_NOT_SUPPORT")
    } return r
  }, adapters: $g
}; function gh(e) { if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new wa(null, e) } function G1(e) { return gh(e), e.headers = bn.from(e.headers), e.data = mh.call(e, e.transformRequest), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), dA.getAdapter(e.adapter || Ou.adapter)(e).then(function (r) { return gh(e), r.data = mh.call(e, e.transformResponse, r), r.headers = bn.from(r.headers), r }, function (r) { return oA(r) || (gh(e), r && r.response && (r.response.data = mh.call(e, e.transformResponse, r.response), r.response.headers = bn.from(r.response.headers))), Promise.reject(r) }) } const fA = "1.7.5", Yy = {};["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => { Yy[e] = function (r) { return typeof r === e || "a" + (t < 1 ? "n " : " ") + e } }); const K1 = {}; Yy.transitional = function (t, n, r) { function i(o, s) { return "[Axios v" + fA + "] Transitional option '" + o + "'" + s + (r ? ". " + r : "") } return (o, s, a) => { if (t === !1) throw new be(i(s, " has been removed" + (n ? " in " + n : "")), be.ERR_DEPRECATED); return n && !K1[s] && (K1[s] = !0, console.warn(i(s, " has been deprecated since v" + n + " and will be removed in the near future"))), t ? t(o, s, a) : !0 } }; function Az(e, t, n) { if (typeof e != "object") throw new be("options must be an object", be.ERR_BAD_OPTION_VALUE); const r = Object.keys(e); let i = r.length; for (; i-- > 0;) { const o = r[i], s = t[o]; if (s) { const a = e[o], l = a === void 0 || s(a, o, e); if (l !== !0) throw new be("option " + o + " must be " + l, be.ERR_BAD_OPTION_VALUE); continue } if (n !== !0) throw new be("Unknown option " + o, be.ERR_BAD_OPTION) } } const Ag = { assertOptions: Az, validators: Yy }, gi = Ag.validators; class _o {
  constructor(t) { this.defaults = t, this.interceptors = { request: new D1, response: new D1 } } async request(t, n) {
    try { return await this._request(t, n) } catch (r) {
      if (r instanceof Error) {
        let i; Error.captureStackTrace ? Error.captureStackTrace(i = {}) : i = new Error; const o = i.stack ? i.stack.replace(/^.+\n/, "") : ""; try {
          r.stack ? o && !String(r.stack).endsWith(o.replace(/^.+\n.+\n/, "")) && (r.stack += `
`+ o) : r.stack = o
        } catch { }
      } throw r
    }
  } _request(t, n) { typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = Ho(this.defaults, n); const { transitional: r, paramsSerializer: i, headers: o } = n; r !== void 0 && Ag.assertOptions(r, { silentJSONParsing: gi.transitional(gi.boolean), forcedJSONParsing: gi.transitional(gi.boolean), clarifyTimeoutError: gi.transitional(gi.boolean) }, !1), i != null && (G.isFunction(i) ? n.paramsSerializer = { serialize: i } : Ag.assertOptions(i, { encode: gi.function, serialize: gi.function }, !0)), n.method = (n.method || this.defaults.method || "get").toLowerCase(); let s = o && G.merge(o.common, o[n.method]); o && G.forEach(["delete", "get", "head", "post", "put", "patch", "common"], m => { delete o[m] }), n.headers = bn.concat(s, o); const a = []; let l = !0; this.interceptors.request.forEach(function (v) { typeof v.runWhen == "function" && v.runWhen(n) === !1 || (l = l && v.synchronous, a.unshift(v.fulfilled, v.rejected)) }); const u = []; this.interceptors.response.forEach(function (v) { u.push(v.fulfilled, v.rejected) }); let c, d = 0, f; if (!l) { const m = [G1.bind(this), void 0]; for (m.unshift.apply(m, a), m.push.apply(m, u), f = m.length, c = Promise.resolve(n); d < f;)c = c.then(m[d++], m[d++]); return c } f = a.length; let p = n; for (d = 0; d < f;) { const m = a[d++], v = a[d++]; try { p = m(p) } catch (x) { v.call(this, x); break } } try { c = G1.call(this, p) } catch (m) { return Promise.reject(m) } for (d = 0, f = u.length; d < f;)c = c.then(u[d++], u[d++]); return c } getUri(t) { t = Ho(this.defaults, t); const n = aA(t.baseURL, t.url); return nA(n, t.params, t.paramsSerializer) }
} G.forEach(["delete", "get", "head", "options"], function (t) { _o.prototype[t] = function (n, r) { return this.request(Ho(r || {}, { method: t, url: n, data: (r || {}).data })) } }); G.forEach(["post", "put", "patch"], function (t) { function n(r) { return function (o, s, a) { return this.request(Ho(a || {}, { method: t, headers: r ? { "Content-Type": "multipart/form-data" } : {}, url: o, data: s })) } } _o.prototype[t] = n(), _o.prototype[t + "Form"] = n(!0) }); class Qy { constructor(t) { if (typeof t != "function") throw new TypeError("executor must be a function."); let n; this.promise = new Promise(function (o) { n = o }); const r = this; this.promise.then(i => { if (!r._listeners) return; let o = r._listeners.length; for (; o-- > 0;)r._listeners[o](i); r._listeners = null }), this.promise.then = i => { let o; const s = new Promise(a => { r.subscribe(a), o = a }).then(i); return s.cancel = function () { r.unsubscribe(o) }, s }, t(function (o, s, a) { r.reason || (r.reason = new wa(o, s, a), n(r.reason)) }) } throwIfRequested() { if (this.reason) throw this.reason } subscribe(t) { if (this.reason) { t(this.reason); return } this._listeners ? this._listeners.push(t) : this._listeners = [t] } unsubscribe(t) { if (!this._listeners) return; const n = this._listeners.indexOf(t); n !== -1 && this._listeners.splice(n, 1) } static source() { let t; return { token: new Qy(function (i) { t = i }), cancel: t } } } function Mz(e) { return function (n) { return e.apply(null, n) } } function kz(e) { return G.isObject(e) && e.isAxiosError === !0 } const Mg = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 }; Object.entries(Mg).forEach(([e, t]) => { Mg[t] = e }); function pA(e) { const t = new _o(e), n = H2(_o.prototype.request, t); return G.extend(n, _o.prototype, t, { allOwnKeys: !0 }), G.extend(n, t, null, { allOwnKeys: !0 }), n.create = function (i) { return pA(Ho(e, i)) }, n } const mt = pA(Ou); mt.Axios = _o; mt.CanceledError = wa; mt.CancelToken = Qy; mt.isCancel = oA; mt.VERSION = fA; mt.toFormData = Jf; mt.AxiosError = be; mt.Cancel = mt.CanceledError; mt.all = function (t) { return Promise.all(t) }; mt.spread = Mz; mt.isAxiosError = kz; mt.mergeConfig = Ho; mt.AxiosHeaders = bn; mt.formToJSON = e => iA(G.isHTMLForm(e) ? new FormData(e) : e); mt.getAdapter = dA.getAdapter; mt.HttpStatusCode = Mg; mt.default = mt; const hA = "https://journey-story-backend-xjuw.onrender.com", _z = "697b4492-9923-4120-82a6-3c2edb48fa02", mA = !(typeof navigator > "u") && navigator.product === "ReactNative", gA = { timeout: mA ? 6e4 : 12e4 }, Rz = function (e) { const t = { ...gA, ...typeof e == "string" ? { url: e } : e }; if (t.timeout = vA(t.timeout), t.query) { const { url: n, searchParams: r } = function (i) { const o = i.indexOf("?"); if (o === -1) return { url: i, searchParams: new URLSearchParams }; const s = i.slice(0, o), a = i.slice(o + 1); if (!mA) return { url: s, searchParams: new URLSearchParams(a) }; if (typeof decodeURIComponent != "function") throw new Error("Broken `URLSearchParams` implementation, and `decodeURIComponent` is not defined"); const l = new URLSearchParams; for (const u of a.split("&")) { const [c, d] = u.split("="); c && l.append(q1(c), q1(d || "")) } return { url: s, searchParams: l } }(t.url); for (const [i, o] of Object.entries(t.query)) { if (o !== void 0) if (Array.isArray(o)) for (const a of o) r.append(i, a); else r.append(i, o); const s = r.toString(); s && (t.url = `${n}?${s}`) } } return t.method = t.body && !t.method ? "POST" : (t.method || "GET").toUpperCase(), t }; function q1(e) { return decodeURIComponent(e.replace(/\+/g, " ")) } function vA(e) { if (e === !1 || e === 0) return !1; if (e.connect || e.socket) return e; const t = Number(e); return isNaN(t) ? vA(gA.timeout) : { connect: t, socket: t } } const Lz = /^https?:\/\//i, Nz = function (e) { if (!Lz.test(e.url)) throw new Error(`"${e.url}" is not a valid URL`) }; function yA(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } const Oz = ["request", "response", "progress", "error", "abort"], Y1 = ["processOptions", "validateOptions", "interceptRequest", "finalizeOptions", "onRequest", "onResponse", "onError", "onReturn", "onHeaders"]; function bA(e, t) { const n = [], r = Y1.reduce((o, s) => (o[s] = o[s] || [], o), { processOptions: [Rz], validateOptions: [Nz] }); function i(o) { const s = Oz.reduce((p, m) => (p[m] = function () { const v = Object.create(null); let x = 0; return { publish: function (g) { for (const h in v) v[h](g) }, subscribe: function (g) { const h = x++; return v[h] = g, function () { delete v[h] } } } }(), p), {}), a = (p => function (m, v, ...x) { const g = m === "onError"; let h = v; for (let y = 0; y < p[m].length && (h = (0, p[m][y])(h, ...x), !g || h); y++); return h })(r), l = a("processOptions", o); a("validateOptions", l); const u = { options: l, channels: s, applyMiddleware: a }; let c; const d = s.request.subscribe(p => { c = t(p, (m, v) => ((x, g, h) => { let y = x, E = g; if (!y) try { E = a("onResponse", g, h) } catch (P) { E = null, y = P } y = y && a("onError", y, h), y ? s.error.publish(y) : E && s.response.publish(E) })(m, v, p)) }); s.abort.subscribe(() => { d(), c && c.abort() }); const f = a("onReturn", s, u); return f === s && s.request.publish(u), f } return i.use = function (o) { if (!o) throw new Error("Tried to add middleware that resolved to falsey value"); if (typeof o == "function") throw new Error("Tried to add middleware that was a function. It probably expects you to pass options to it."); if (o.onReturn && r.onReturn.length > 0) throw new Error("Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event"); return Y1.forEach(s => { o[s] && r[s].push(o[s]) }), n.push(o), i }, i.clone = () => bA(n, t), e.forEach(i.use), i } var vh = function (e) { return e.replace(/^\s+|\s+$/g, "") }, jz = yA(function (e) {
  if (!e) return {}; for (var t = {}, n = vh(e).split(`
`), r = 0; r < n.length; r++) { var i = n[r], o = i.indexOf(":"), s = vh(i.slice(0, o)).toLowerCase(), a = vh(i.slice(o + 1)); typeof t[s] > "u" ? t[s] = a : (l = t[s], Object.prototype.toString.call(l) === "[object Array]" ? t[s].push(a) : t[s] = [t[s], a]) } var l; return t
}), au, lu, Ks, uu, Br, cu, du, TS; let kg = (TS = class {
  constructor() { Se(this, "onabort"); Se(this, "onerror"); Se(this, "onreadystatechange"); Se(this, "ontimeout"); Se(this, "readyState", 0); Se(this, "response"); Se(this, "responseText", ""); Se(this, "responseType", ""); Se(this, "status"); Se(this, "statusText"); Se(this, "withCredentials"); Le(this, au); Le(this, lu); Le(this, Ks); Le(this, uu, {}); Le(this, Br); Le(this, cu, {}); Le(this, du) } open(t, n, r) { var i; Re(this, au, t), Re(this, lu, n), Re(this, Ks, ""), this.readyState = 1, (i = this.onreadystatechange) == null || i.call(this), Re(this, Br, void 0) } abort() { Y(this, Br) && Y(this, Br).abort() } getAllResponseHeaders() { return Y(this, Ks) } setRequestHeader(t, n) { Y(this, uu)[t] = n } setInit(t, n = !0) { Re(this, cu, t), Re(this, du, n) } send(t) {
    const n = this.responseType !== "arraybuffer", r = { ...Y(this, cu), method: Y(this, au), headers: Y(this, uu), body: t }; typeof AbortController == "function" && Y(this, du) && (Re(this, Br, new AbortController), typeof EventTarget < "u" && Y(this, Br).signal instanceof EventTarget && (r.signal = Y(this, Br).signal)), typeof document < "u" && (r.credentials = this.withCredentials ? "include" : "omit"), fetch(Y(this, lu), r).then(i => {
      var o; return i.headers.forEach((s, a) => {
        Re(this, Ks, Y(this, Ks) + `${a}: ${s}\r
`)
      }), this.status = i.status, this.statusText = i.statusText, this.readyState = 3, (o = this.onreadystatechange) == null || o.call(this), n ? i.text() : i.arrayBuffer()
    }).then(i => { var o; typeof i == "string" ? this.responseText = i : this.response = i, this.readyState = 4, (o = this.onreadystatechange) == null || o.call(this) }).catch(i => { var o, s; i.name !== "AbortError" ? (o = this.onerror) == null || o.call(this, i) : (s = this.onabort) == null || s.call(this) })
  }
}, au = new WeakMap, lu = new WeakMap, Ks = new WeakMap, uu = new WeakMap, Br = new WeakMap, cu = new WeakMap, du = new WeakMap, TS); const _g = typeof XMLHttpRequest == "function" ? "xhr" : "fetch", Iz = _g === "xhr" ? XMLHttpRequest : kg, Dz = (e, t) => { const n = e.options, r = e.applyMiddleware("finalizeOptions", n), i = {}, o = e.applyMiddleware("interceptRequest", void 0, { adapter: _g, context: e }); if (o) { const v = setTimeout(t, 0, null, o); return { abort: () => clearTimeout(v) } } let s = new Iz; s instanceof kg && typeof r.fetch == "object" && s.setInit(r.fetch, r.useAbortSignal ?? !0); const a = r.headers, l = r.timeout; let u = !1, c = !1, d = !1; if (s.onerror = v => { m(s instanceof kg ? v instanceof Error ? v : new Error(`Request error while attempting to reach is ${r.url}`, { cause: v }) : new Error(`Request error while attempting to reach is ${r.url}${v.lengthComputable ? `(${v.loaded} of ${v.total} bytes transferred)` : ""}`)) }, s.ontimeout = v => { m(new Error(`Request timeout while attempting to reach ${r.url}${v.lengthComputable ? `(${v.loaded} of ${v.total} bytes transferred)` : ""}`)) }, s.onabort = () => { p(!0), u = !0 }, s.onreadystatechange = () => { l && (p(), i.socket = setTimeout(() => f("ESOCKETTIMEDOUT"), l.socket)), !u && s.readyState === 4 && s.status !== 0 && function () { if (!(u || c || d)) { if (s.status === 0) return void m(new Error("Unknown XHR error")); p(), c = !0, t(null, { body: s.response || (s.responseType === "" || s.responseType === "text" ? s.responseText : ""), url: r.url, method: r.method, headers: jz(s.getAllResponseHeaders()), statusCode: s.status, statusMessage: s.statusText }) } }() }, s.open(r.method, r.url, !0), s.withCredentials = !!r.withCredentials, a && s.setRequestHeader) for (const v in a) a.hasOwnProperty(v) && s.setRequestHeader(v, a[v]); return r.rawBody && (s.responseType = "arraybuffer"), e.applyMiddleware("onRequest", { options: r, adapter: _g, request: s, context: e }), s.send(r.body || null), l && (i.connect = setTimeout(() => f("ETIMEDOUT"), l.connect)), { abort: function () { u = !0, s && s.abort() } }; function f(v) { d = !0, s.abort(); const x = new Error(v === "ESOCKETTIMEDOUT" ? `Socket timed out on request to ${r.url}` : `Connection timed out on request to ${r.url}`); x.code = v, e.channels.error.publish(x) } function p(v) { (v || u || s.readyState >= 2 && i.connect) && clearTimeout(i.connect), i.socket && clearTimeout(i.socket) } function m(v) { if (c) return; p(!0), c = !0, s = null; const x = v || new Error(`Network error while attempting to reach ${r.url}`); x.isNetworkError = !0, x.request = r, t(x) } }, Fz = (e = [], t = Dz) => bA(e, t); var zz = {}, Q1, X1, Rg = { exports: {} }; function Vz() { if (X1) return Q1; X1 = 1; var e = 1e3, t = 60 * e, n = 60 * t, r = 24 * n, i = 7 * r, o = 365.25 * r; function s(a, l, u, c) { var d = l >= 1.5 * u; return Math.round(a / u) + " " + c + (d ? "s" : "") } return Q1 = function (a, l) { l = l || {}; var u, c, d = typeof a; if (d === "string" && a.length > 0) return function (f) { if (!((f = String(f)).length > 100)) { var p = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(f); if (p) { var m = parseFloat(p[1]); switch ((p[2] || "ms").toLowerCase()) { case "years": case "year": case "yrs": case "yr": case "y": return m * o; case "weeks": case "week": case "w": return m * i; case "days": case "day": case "d": return m * r; case "hours": case "hour": case "hrs": case "hr": case "h": return m * n; case "minutes": case "minute": case "mins": case "min": case "m": return m * t; case "seconds": case "second": case "secs": case "sec": case "s": return m * e; case "milliseconds": case "millisecond": case "msecs": case "msec": case "ms": return m; default: return } } } }(a); if (d === "number" && isFinite(a)) return l.long ? (u = a, (c = Math.abs(u)) >= r ? s(u, c, r, "day") : c >= n ? s(u, c, n, "hour") : c >= t ? s(u, c, t, "minute") : c >= e ? s(u, c, e, "second") : u + " ms") : function (f) { var p = Math.abs(f); return p >= r ? Math.round(f / r) + "d" : p >= n ? Math.round(f / n) + "h" : p >= t ? Math.round(f / t) + "m" : p >= e ? Math.round(f / e) + "s" : f + "ms" }(a); throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(a)) } } var Bz = function (e) { function t(i) { let o, s, a, l = null; function u(...c) { if (!u.enabled) return; const d = u, f = Number(new Date), p = f - (o || f); d.diff = p, d.prev = o, d.curr = f, o = f, c[0] = t.coerce(c[0]), typeof c[0] != "string" && c.unshift("%O"); let m = 0; c[0] = c[0].replace(/%([a-zA-Z%])/g, (v, x) => { if (v === "%%") return "%"; m++; const g = t.formatters[x]; if (typeof g == "function") { const h = c[m]; v = g.call(d, h), c.splice(m, 1), m-- } return v }), t.formatArgs.call(d, c), (d.log || t.log).apply(d, c) } return u.namespace = i, u.useColors = t.useColors(), u.color = t.selectColor(i), u.extend = n, u.destroy = t.destroy, Object.defineProperty(u, "enabled", { enumerable: !0, configurable: !1, get: () => l !== null ? l : (s !== t.namespaces && (s = t.namespaces, a = t.enabled(i)), a), set: c => { l = c } }), typeof t.init == "function" && t.init(u), u } function n(i, o) { const s = t(this.namespace + (typeof o > "u" ? ":" : o) + i); return s.log = this.log, s } function r(i) { return i.toString().substring(2, i.toString().length - 2).replace(/\.\*\?$/, "*") } return t.debug = t, t.default = t, t.coerce = function (i) { return i instanceof Error ? i.stack || i.message : i }, t.disable = function () { const i = [...t.names.map(r), ...t.skips.map(r).map(o => "-" + o)].join(","); return t.enable(""), i }, t.enable = function (i) { let o; t.save(i), t.namespaces = i, t.names = [], t.skips = []; const s = (typeof i == "string" ? i : "").split(/[\s,]+/), a = s.length; for (o = 0; o < a; o++)s[o] && ((i = s[o].replace(/\*/g, ".*?"))[0] === "-" ? t.skips.push(new RegExp("^" + i.slice(1) + "$")) : t.names.push(new RegExp("^" + i + "$"))) }, t.enabled = function (i) { if (i[i.length - 1] === "*") return !0; let o, s; for (o = 0, s = t.skips.length; o < s; o++)if (t.skips[o].test(i)) return !1; for (o = 0, s = t.names.length; o < s; o++)if (t.names[o].test(i)) return !0; return !1 }, t.humanize = Vz(), t.destroy = function () { console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.") }, Object.keys(e).forEach(i => { t[i] = e[i] }), t.names = [], t.skips = [], t.formatters = {}, t.selectColor = function (i) { let o = 0; for (let s = 0; s < i.length; s++)o = (o << 5) - o + i.charCodeAt(s), o |= 0; return t.colors[Math.abs(o) % t.colors.length] }, t.enable(t.load()), t }; (function (e, t) { t.formatArgs = function (r) { if (r[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + r[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors) return; const i = "color: " + this.color; r.splice(1, 0, i, "color: inherit"); let o = 0, s = 0; r[0].replace(/%[a-zA-Z%]/g, a => { a !== "%%" && (o++, a === "%c" && (s = o)) }), r.splice(s, 0, i) }, t.save = function (r) { try { r ? t.storage.setItem("debug", r) : t.storage.removeItem("debug") } catch { } }, t.load = function () { let r; try { r = t.storage.getItem("debug") } catch { } return !r && typeof process < "u" && "env" in process && (r = zz.DEBUG), r }, t.useColors = function () { return !(!(typeof window < "u" && window.process) || window.process.type !== "renderer" && !window.process.__nwjs) || !(typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && (typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)) }, t.storage = function () { try { return localStorage } catch { } }(), t.destroy = (() => { let r = !1; return () => { r || (r = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")) } })(), t.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], t.log = console.debug || console.log || (() => { }), e.exports = Bz(t); const { formatters: n } = e.exports; n.j = function (r) { try { return JSON.stringify(r) } catch (i) { return "[UnexpectedJSONParseError]: " + i.message } } })(Rg, Rg.exports); yA(Rg.exports); const Uz = typeof Buffer > "u" ? () => !1 : e => Buffer.isBuffer(e); function J1(e) { return Object.prototype.toString.call(e) === "[object Object]" } function Hz(e) { if (J1(e) === !1) return !1; const t = e.constructor; if (t === void 0) return !0; const n = t.prototype; return !(J1(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1) } const Wz = ["boolean", "string", "number"]; function Gz() { return { processOptions: e => { const t = e.body; return !t || typeof t.pipe == "function" || Uz(t) || Wz.indexOf(typeof t) === -1 && !Array.isArray(t) && !Hz(t) ? e : Object.assign({}, e, { body: JSON.stringify(e.body), headers: Object.assign({}, e.headers, { "Content-Type": "application/json" }) }) } } } function Kz(e) { return { onResponse: n => { const r = n.headers["content-type"] || "", i = r.indexOf("application/json") !== -1; return n.body && r && i ? Object.assign({}, n, { body: t(n.body) }) : n }, processOptions: n => Object.assign({}, n, { headers: Object.assign({ Accept: "application/json" }, n.headers) }) }; function t(n) { try { return JSON.parse(n) } catch (r) { throw r.message = `Failed to parsed response body as JSON: ${r.message}`, r } } } let ll = {}; typeof globalThis < "u" ? ll = globalThis : typeof window < "u" ? ll = window : typeof global < "u" ? ll = global : typeof self < "u" && (ll = self); var qz = ll; function Yz(e = {}) { const t = e.implementation || qz.Observable; if (!t) throw new Error("`Observable` is not available in global scope, and no implementation was passed"); return { onReturn: (n, r) => new t(i => (n.error.subscribe(o => i.error(o)), n.progress.subscribe(o => i.next(Object.assign({ type: "progress" }, o))), n.response.subscribe(o => { i.next(Object.assign({ type: "response" }, o)), i.complete() }), n.request.publish(r), () => n.abort.publish())) } } function Qz() { return { onRequest: e => { if (e.adapter !== "xhr") return; const t = e.request, n = e.context; function r(i) { return o => { const s = o.lengthComputable ? o.loaded / o.total * 100 : -1; n.channels.progress.publish({ stage: i, percent: s, total: o.total, loaded: o.loaded, lengthComputable: o.lengthComputable }) } } "upload" in t && "onprogress" in t.upload && (t.upload.onprogress = r("upload")), "onprogress" in t && (t.onprogress = r("download")) } } } var wA = (e, t, n) => (n.method === "GET" || n.method === "HEAD") && (e.isNetworkError || !1); function Xz(e) { return 100 * Math.pow(2, e) + 100 * Math.random() } const Xy = (e = {}) => (t => { const n = t.maxRetries || 5, r = t.retryDelay || Xz, i = t.shouldRetry; return { onError: (o, s) => { const a = s.options, l = a.maxRetries || n, u = a.retryDelay || r, c = a.shouldRetry || i, d = a.attemptNumber || 0; if ((f = a.body) !== null && typeof f == "object" && typeof f.pipe == "function" || !c(o, d, a) || d >= l) return o; var f; const p = Object.assign({}, s, { options: Object.assign({}, a, { attemptNumber: d + 1 }) }); return setTimeout(() => s.channels.request.publish(p), u(d)), null } } })({ shouldRetry: wA, ...e }); Xy.shouldRetry = wA; function Bt(e) { return typeof e == "function" } function xA(e) { var t = function (r) { Error.call(r), r.stack = new Error().stack }, n = e(t); return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n } var yh = xA(function (e) {
  return function (n) {
    e(this), this.message = n ? n.length + ` errors occurred during unsubscription:
`+ n.map(function (r, i) { return i + 1 + ") " + r.toString() }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = n
  }
}); function Z1(e, t) { if (e) { var n = e.indexOf(t); 0 <= n && e.splice(n, 1) } } var Jy = function () { function e(t) { this.initialTeardown = t, this.closed = !1, this._parentage = null, this._finalizers = null } return e.prototype.unsubscribe = function () { var t, n, r, i, o; if (!this.closed) { this.closed = !0; var s = this._parentage; if (s) if (this._parentage = null, Array.isArray(s)) try { for (var a = Wl(s), l = a.next(); !l.done; l = a.next()) { var u = l.value; u.remove(this) } } catch (v) { t = { error: v } } finally { try { l && !l.done && (n = a.return) && n.call(a) } finally { if (t) throw t.error } } else s.remove(this); var c = this.initialTeardown; if (Bt(c)) try { c() } catch (v) { o = v instanceof yh ? v.errors : [v] } var d = this._finalizers; if (d) { this._finalizers = null; try { for (var f = Wl(d), p = f.next(); !p.done; p = f.next()) { var m = p.value; try { eS(m) } catch (v) { o = o ?? [], v instanceof yh ? o = zo(zo([], Fo(o)), Fo(v.errors)) : o.push(v) } } } catch (v) { r = { error: v } } finally { try { p && !p.done && (i = f.return) && i.call(f) } finally { if (r) throw r.error } } } if (o) throw new yh(o) } }, e.prototype.add = function (t) { var n; if (t && t !== this) if (this.closed) eS(t); else { if (t instanceof e) { if (t.closed || t._hasParent(this)) return; t._addParent(this) } (this._finalizers = (n = this._finalizers) !== null && n !== void 0 ? n : []).push(t) } }, e.prototype._hasParent = function (t) { var n = this._parentage; return n === t || Array.isArray(n) && n.includes(t) }, e.prototype._addParent = function (t) { var n = this._parentage; this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t }, e.prototype._removeParent = function (t) { var n = this._parentage; n === t ? this._parentage = null : Array.isArray(n) && Z1(n, t) }, e.prototype.remove = function (t) { var n = this._finalizers; n && Z1(n, t), t instanceof e && t._removeParent(this) }, e.EMPTY = function () { var t = new e; return t.closed = !0, t }(), e }(); Jy.EMPTY; function SA(e) { return e instanceof Jy || e && "closed" in e && Bt(e.remove) && Bt(e.add) && Bt(e.unsubscribe) } function eS(e) { Bt(e) ? e() : e.unsubscribe() } var EA = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }, TA = { setTimeout: function (e, t) { for (var n = [], r = 2; r < arguments.length; r++)n[r - 2] = arguments[r]; return setTimeout.apply(void 0, zo([e, t], Fo(n))) }, clearTimeout: function (e) { var t = TA.delegate; return ((t == null ? void 0 : t.clearTimeout) || clearTimeout)(e) }, delegate: void 0 }; function CA(e) { TA.setTimeout(function () { throw e }) } function tS() { } function Jz(e) { e() } var Zy = function (e) { Uv(t, e); function t(n) { var r = e.call(this) || this; return r.isStopped = !1, n ? (r.destination = n, SA(n) && n.add(r)) : r.destination = n9, r } return t.create = function (n, r, i) { return new Lg(n, r, i) }, t.prototype.next = function (n) { this.isStopped || this._next(n) }, t.prototype.error = function (n) { this.isStopped || (this.isStopped = !0, this._error(n)) }, t.prototype.complete = function () { this.isStopped || (this.isStopped = !0, this._complete()) }, t.prototype.unsubscribe = function () { this.closed || (this.isStopped = !0, e.prototype.unsubscribe.call(this), this.destination = null) }, t.prototype._next = function (n) { this.destination.next(n) }, t.prototype._error = function (n) { try { this.destination.error(n) } finally { this.unsubscribe() } }, t.prototype._complete = function () { try { this.destination.complete() } finally { this.unsubscribe() } }, t }(Jy), Zz = Function.prototype.bind; function bh(e, t) { return Zz.call(e, t) } var e9 = function () { function e(t) { this.partialObserver = t } return e.prototype.next = function (t) { var n = this.partialObserver; if (n.next) try { n.next(t) } catch (r) { $c(r) } }, e.prototype.error = function (t) { var n = this.partialObserver; if (n.error) try { n.error(t) } catch (r) { $c(r) } else $c(t) }, e.prototype.complete = function () { var t = this.partialObserver; if (t.complete) try { t.complete() } catch (n) { $c(n) } }, e }(), Lg = function (e) { Uv(t, e); function t(n, r, i) { var o = e.call(this) || this, s; if (Bt(n) || !n) s = { next: n ?? void 0, error: r ?? void 0, complete: i ?? void 0 }; else { var a; o && EA.useDeprecatedNextContext ? (a = Object.create(n), a.unsubscribe = function () { return o.unsubscribe() }, s = { next: n.next && bh(n.next, a), error: n.error && bh(n.error, a), complete: n.complete && bh(n.complete, a) }) : s = n } return o.destination = new e9(s), o } return t }(Zy); function $c(e) { CA(e) } function t9(e) { throw e } var n9 = { closed: !0, next: tS, error: t9, complete: tS }, e0 = function () { return typeof Symbol == "function" && Symbol.observable || "@@observable" }(); function PA(e) { return e } function r9() { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; return $A(e) } function $A(e) { return e.length === 0 ? PA : e.length === 1 ? e[0] : function (n) { return e.reduce(function (r, i) { return i(r) }, n) } } var nr = function () { function e(t) { t && (this._subscribe = t) } return e.prototype.lift = function (t) { var n = new e; return n.source = this, n.operator = t, n }, e.prototype.subscribe = function (t, n, r) { var i = this, o = o9(t) ? t : new Lg(t, n, r); return Jz(function () { var s = i, a = s.operator, l = s.source; o.add(a ? a.call(o, l) : l ? i._subscribe(o) : i._trySubscribe(o)) }), o }, e.prototype._trySubscribe = function (t) { try { return this._subscribe(t) } catch (n) { t.error(n) } }, e.prototype.forEach = function (t, n) { var r = this; return n = nS(n), new n(function (i, o) { var s = new Lg({ next: function (a) { try { t(a) } catch (l) { o(l), s.unsubscribe() } }, error: o, complete: i }); r.subscribe(s) }) }, e.prototype._subscribe = function (t) { var n; return (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(t) }, e.prototype[e0] = function () { return this }, e.prototype.pipe = function () { for (var t = [], n = 0; n < arguments.length; n++)t[n] = arguments[n]; return $A(t)(this) }, e.prototype.toPromise = function (t) { var n = this; return t = nS(t), new t(function (r, i) { var o; n.subscribe(function (s) { return o = s }, function (s) { return i(s) }, function () { return r(o) }) }) }, e.create = function (t) { return new e(t) }, e }(); function nS(e) { var t; return (t = e ?? EA.Promise) !== null && t !== void 0 ? t : Promise } function i9(e) { return e && Bt(e.next) && Bt(e.error) && Bt(e.complete) } function o9(e) { return e && e instanceof Zy || i9(e) && SA(e) } function s9(e) { return Bt(e == null ? void 0 : e.lift) } function t0(e) { return function (t) { if (s9(t)) return t.lift(function (n) { try { return e(n, this) } catch (r) { this.error(r) } }); throw new TypeError("Unable to lift unknown Observable type") } } function n0(e, t, n, r, i) { return new a9(e, t, n, r, i) } var a9 = function (e) { Uv(t, e); function t(n, r, i, o, s, a) { var l = e.call(this, n) || this; return l.onFinalize = s, l.shouldUnsubscribe = a, l._next = r ? function (u) { try { r(u) } catch (c) { n.error(c) } } : e.prototype._next, l._error = o ? function (u) { try { o(u) } catch (c) { n.error(c) } finally { this.unsubscribe() } } : e.prototype._error, l._complete = i ? function () { try { i() } catch (u) { n.error(u) } finally { this.unsubscribe() } } : e.prototype._complete, l } return t.prototype.unsubscribe = function () { var n; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { var r = this.closed; e.prototype.unsubscribe.call(this), !r && ((n = this.onFinalize) === null || n === void 0 || n.call(this)) } }, t }(Zy); function l9(e) { return e[e.length - 1] } function u9(e) { return Bt(l9(e)) ? e.pop() : void 0 } var c9 = function (e) { return e && typeof e.length == "number" && typeof e != "function" }; function d9(e) { return Bt(e == null ? void 0 : e.then) } function f9(e) { return Bt(e[e0]) } function p9(e) { return Symbol.asyncIterator && Bt(e == null ? void 0 : e[Symbol.asyncIterator]) } function h9(e) { return new TypeError("You provided " + (e !== null && typeof e == "object" ? "an invalid object" : "'" + e + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.") } function m9() { return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator } var g9 = m9(); function v9(e) { return Bt(e == null ? void 0 : e[g9]) } function y9(e) { return eL(this, arguments, function () { var n, r, i, o; return QT(this, function (s) { switch (s.label) { case 0: n = e.getReader(), s.label = 1; case 1: s.trys.push([1, , 9, 10]), s.label = 2; case 2: return [4, Us(n.read())]; case 3: return r = s.sent(), i = r.value, o = r.done, o ? [4, Us(void 0)] : [3, 5]; case 4: return [2, s.sent()]; case 5: return [4, Us(i)]; case 6: return [4, s.sent()]; case 7: return s.sent(), [3, 2]; case 8: return [3, 10]; case 9: return n.releaseLock(), [7]; case 10: return [2] } }) }) } function b9(e) { return Bt(e == null ? void 0 : e.getReader) } function w9(e) { if (e instanceof nr) return e; if (e != null) { if (f9(e)) return x9(e); if (c9(e)) return S9(e); if (d9(e)) return E9(e); if (p9(e)) return AA(e); if (v9(e)) return T9(e); if (b9(e)) return C9(e) } throw h9(e) } function x9(e) { return new nr(function (t) { var n = e[e0](); if (Bt(n.subscribe)) return n.subscribe(t); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) } function S9(e) { return new nr(function (t) { for (var n = 0; n < e.length && !t.closed; n++)t.next(e[n]); t.complete() }) } function E9(e) { return new nr(function (t) { e.then(function (n) { t.closed || (t.next(n), t.complete()) }, function (n) { return t.error(n) }).then(null, CA) }) } function T9(e) { return new nr(function (t) { var n, r; try { for (var i = Wl(e), o = i.next(); !o.done; o = i.next()) { var s = o.value; if (t.next(s), t.closed) return } } catch (a) { n = { error: a } } finally { try { o && !o.done && (r = i.return) && r.call(i) } finally { if (n) throw n.error } } t.complete() }) } function AA(e) { return new nr(function (t) { P9(e, t).catch(function (n) { return t.error(n) }) }) } function C9(e) { return AA(y9(e)) } function P9(e, t) { var n, r, i, o; return ZR(this, void 0, void 0, function () { var s, a; return QT(this, function (l) { switch (l.label) { case 0: l.trys.push([0, 5, 6, 11]), n = tL(e), l.label = 1; case 1: return [4, n.next()]; case 2: if (r = l.sent(), !!r.done) return [3, 4]; if (s = r.value, t.next(s), t.closed) return [2]; l.label = 3; case 3: return [3, 1]; case 4: return [3, 11]; case 5: return a = l.sent(), i = { error: a }, [3, 11]; case 6: return l.trys.push([6, , 9, 10]), r && !r.done && (o = n.return) ? [4, o.call(n)] : [3, 8]; case 7: l.sent(), l.label = 8; case 8: return [3, 10]; case 9: if (i) throw i.error; return [7]; case 10: return [7]; case 11: return t.complete(), [2] } }) }) } function MA(e, t) { return w9(e) } var $9 = xA(function (e) { return function () { e(this), this.name = "EmptyError", this.message = "no elements in sequence" } }); function At(e, t) { return new Promise(function (n, r) { var i = !1, o; e.subscribe({ next: function (s) { o = s, i = !0 }, error: r, complete: function () { i ? n(o) : r(new $9) } }) }) } function si(e, t) { return t0(function (n, r) { var i = 0; n.subscribe(n0(r, function (o) { r.next(e.call(t, o, i++)) })) }) } var A9 = Array.isArray; function M9(e, t) { return A9(t) ? e.apply(void 0, zo([], Fo(t))) : e(t) } function k9(e) { return si(function (t) { return M9(e, t) }) } function _9(e, t, n) { return n === void 0 && (n = PA), function (r) { rS(t, function () { for (var i = e.length, o = new Array(i), s = i, a = i, l = function (c) { rS(t, function () { var d = MA(e[c]), f = !1; d.subscribe(n0(r, function (p) { o[c] = p, f || (f = !0, a--), a || r.next(n(o.slice())) }, function () { --s || r.complete() })) }, r) }, u = 0; u < i; u++)l(u) }) } } function rS(e, t, n) { t() } var R9 = Array.isArray; function L9(e) { return e.length === 1 && R9(e[0]) ? e[0] : e } function ju(e, t) { return t0(function (n, r) { var i = 0; n.subscribe(n0(r, function (o) { return e.call(t, o, i++) && r.next(o) })) }) } function kA() { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; var n = u9(e); return n ? r9(kA.apply(void 0, zo([], Fo(e))), k9(n)) : t0(function (r, i) { _9(zo([r], Fo(L9(e))))(i) }) } function N9() { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; return kA.apply(void 0, zo([], Fo(e))) } var _A = { 0: 8203, 1: 8204, 2: 8205, 3: 8290, 4: 8291, 5: 8288, 6: 65279, 7: 8289, 8: 119155, 9: 119156, a: 119157, b: 119158, c: 119159, d: 119160, e: 119161, f: 119162 }, r0 = { 0: 8203, 1: 8204, 2: 8205, 3: 65279 }, O9 = new Array(4).fill(String.fromCodePoint(r0[0])).join(""); function j9(e) { let t = JSON.stringify(e); return `${O9}${Array.from(t).map(n => { let r = n.charCodeAt(0); if (r > 255) throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${t} on character ${n} (${r})`); return Array.from(r.toString(4).padStart(4, "0")).map(i => String.fromCodePoint(r0[i])).join("") }).join("")}` } function I9(e) { return !Number.isNaN(Number(e)) || /[a-z]/i.test(e) && !/\d+(?:[-:\/]\d+){2}(?:T\d+(?:[-:\/]\d+){1,2}(\.\d+)?Z?)?/.test(e) ? !1 : !!Date.parse(e) } function D9(e) { try { new URL(e, e.startsWith("/") ? "https://acme.com" : void 0) } catch { return !1 } return !0 } function aW(e, t, n = "auto") { return n === !0 || n === "auto" && (I9(e) || D9(e)) ? e : `${e}${j9(t)}` } Object.fromEntries(Object.entries(r0).map(e => e.reverse())); Object.fromEntries(Object.entries(_A).map(e => e.reverse())); var F9 = `${Object.values(_A).map(e => `\\u{${e.toString(16)}}`).join("")}`, iS = new RegExp(`[${F9}]{4,}`, "gu"); function z9(e) { var t; return { cleaned: e.replace(iS, ""), encoded: ((t = e.match(iS)) == null ? void 0 : t[0]) || "" } } function V9(e) { return e && JSON.parse(z9(JSON.stringify(e)).cleaned) } function B9(e) { return V9(e) } class U9 extends Error { constructor(n) { const r = RA(n); super(r.message); Se(this, "response"); Se(this, "statusCode", 400); Se(this, "responseBody"); Se(this, "details"); Object.assign(this, r) } } class H9 extends Error { constructor(n) { const r = RA(n); super(r.message); Se(this, "response"); Se(this, "statusCode", 500); Se(this, "responseBody"); Se(this, "details"); Object.assign(this, r) } } function RA(e) {
  const t = e.body, n = { response: e, statusCode: e.statusCode, responseBody: q9(t, e), message: "", details: void 0 }; if (t.error && t.message) return n.message = `${t.error} - ${t.message}`, n; if (W9(t) || G9(t)) {
    const r = t.error.items || [], i = r.slice(0, 5).map(s => { var a; return (a = s.error) == null ? void 0 : a.description }).filter(Boolean); let o = i.length ? `:
- ${i.join(`
- `)}` : ""; return r.length > 5 && (o += `
...and ${r.length - 5} more`), n.message = `${t.error.description}${o}`, n.details = t.error, n
  } return t.error && t.error.description ? (n.message = t.error.description, n.details = t.error, n) : (n.message = t.error || t.message || K9(e), n)
} function W9(e) { return ef(e) && ef(e.error) && e.error.type === "mutationError" && typeof e.error.description == "string" } function G9(e) { return ef(e) && ef(e.error) && e.error.type === "actionError" && typeof e.error.description == "string" } function ef(e) { return typeof e == "object" && e !== null && !Array.isArray(e) } function K9(e) { const t = e.statusMessage ? ` ${e.statusMessage}` : ""; return `${e.method}-request to ${e.url} resulted in HTTP ${e.statusCode}${t}` } function q9(e, t) { return (t.headers["content-type"] || "").toLowerCase().indexOf("application/json") !== -1 ? JSON.stringify(e, null, 2) : e } const Y9 = { onResponse: e => { if (e.statusCode >= 500) throw new H9(e); if (e.statusCode >= 400) throw new U9(e); return e } }, Q9 = { onResponse: e => { const t = e.headers["x-sanity-warning"]; return (Array.isArray(t) ? t : [t]).filter(Boolean).forEach(n => console.warn(n)), e } }; function X9(e) { return Fz([Xy({ shouldRetry: J9 }), ...e, Q9, Gz(), Kz(), Qz(), Y9, Yz({ implementation: nr })]) } function J9(e, t, n) { if (n.maxRetries === 0) return !1; const r = n.method === "GET" || n.method === "HEAD", i = (n.uri || n.url).startsWith("/data/query"), o = e.response && (e.response.statusCode === 429 || e.response.statusCode === 502 || e.response.statusCode === 503); return (r || i) && o ? !0 : Xy.shouldRetry(e, t, n) } function LA(e) {
  if (typeof e == "string") return { id: e }; if (Array.isArray(e)) return { query: "*[_id in $ids]", params: { ids: e } }; if (typeof e == "object" && e !== null && "query" in e && typeof e.query == "string") return "params" in e && typeof e.params == "object" && e.params !== null ? { query: e.query, params: e.params } : { query: e.query }; const t = ["* Document ID (<docId>)", "* Array of document IDs", "* Object containing `query`"].join(`
`); throw new Error(`Unknown selection - must be one of:

${t}`)
} const oS = ["image", "file"], sS = ["before", "after", "replace"], NA = e => { if (!/^(~[a-z0-9]{1}[-\w]{0,63}|[a-z0-9]{1}[-\w]{0,63})$/.test(e)) throw new Error("Datasets can only contain lowercase characters, numbers, underscores and dashes, and start with tilde, and be maximum 64 characters") }, Z9 = e => { if (!/^[-a-z0-9]+$/i.test(e)) throw new Error("`projectId` can only contain only a-z, 0-9 and dashes") }, eV = e => { if (oS.indexOf(e) === -1) throw new Error(`Invalid asset type: ${e}. Must be one of ${oS.join(", ")}`) }, Tl = (e, t) => { if (t === null || typeof t != "object" || Array.isArray(t)) throw new Error(`${e}() takes an object of properties`) }, OA = (e, t) => { if (typeof t != "string" || !/^[a-z0-9_][a-z0-9_.-]{0,127}$/i.test(t) || t.includes("..")) throw new Error(`${e}(): "${t}" is not a valid document ID`) }, tf = (e, t) => { if (!t._id) throw new Error(`${e}() requires that the document contains an ID ("_id" property)`); OA(e, t._id) }, tV = (e, t, n) => { const r = "insert(at, selector, items)"; if (sS.indexOf(e) === -1) { const i = sS.map(o => `"${o}"`).join(", "); throw new Error(`${r} takes an "at"-argument which is one of: ${i}`) } if (typeof t != "string") throw new Error(`${r} takes a "selector"-argument which must be a string`); if (!Array.isArray(n)) throw new Error(`${r} takes an "items"-argument which must be an array`) }, jA = e => { if (!e.dataset) throw new Error("`dataset` must be provided to perform queries"); return e.dataset || "" }, IA = e => { if (typeof e != "string" || !/^[a-z0-9._-]{1,75}$/i.test(e)) throw new Error("Tag can only contain alphanumeric characters, underscores, dashes and dots, and be between one and 75 characters long."); return e }; class DA { constructor(t, n = {}) { Se(this, "selection"); Se(this, "operations"); this.selection = t, this.operations = n } set(t) { return this._assign("set", t) } setIfMissing(t) { return this._assign("setIfMissing", t) } diffMatchPatch(t) { return Tl("diffMatchPatch", t), this._assign("diffMatchPatch", t) } unset(t) { if (!Array.isArray(t)) throw new Error("unset(attrs) takes an array of attributes to unset, non-array given"); return this.operations = Object.assign({}, this.operations, { unset: t }), this } inc(t) { return this._assign("inc", t) } dec(t) { return this._assign("dec", t) } insert(t, n, r) { return tV(t, n, r), this._assign("insert", { [t]: n, items: r }) } append(t, n) { return this.insert("after", `${t}[-1]`, n) } prepend(t, n) { return this.insert("before", `${t}[0]`, n) } splice(t, n, r, i) { const o = typeof r > "u" || r === -1, s = n < 0 ? n - 1 : n, a = o ? -1 : Math.max(0, n + r), l = s < 0 && a >= 0 ? "" : a, u = `${t}[${s}:${l}]`; return this.insert("replace", u, i || []) } ifRevisionId(t) { return this.operations.ifRevisionID = t, this } serialize() { return { ...LA(this.selection), ...this.operations } } toJSON() { return this.serialize() } reset() { return this.operations = {}, this } _assign(t, n, r = !0) { return Tl(t, n), this.operations = Object.assign({}, this.operations, { [t]: Object.assign({}, r && this.operations[t] || {}, n) }), this } _set(t, n) { return this._assign(t, n, !1) } } var Co; const m0 = class m0 extends DA { constructor(n, r, i) { super(n, r); Le(this, Co); Re(this, Co, i) } clone() { return new m0(this.selection, { ...this.operations }, Y(this, Co)) } commit(n) { if (!Y(this, Co)) throw new Error("No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method"); const r = typeof this.selection == "string", i = Object.assign({ returnFirst: r, returnDocuments: !0 }, n); return Y(this, Co).mutate({ patch: this.serialize() }, i) } }; Co = new WeakMap; let Ro = m0; var Po; const g0 = class g0 extends DA { constructor(n, r, i) { super(n, r); Le(this, Po); Re(this, Po, i) } clone() { return new g0(this.selection, { ...this.operations }, Y(this, Po)) } commit(n) { if (!Y(this, Po)) throw new Error("No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method"); const r = typeof this.selection == "string", i = Object.assign({ returnFirst: r, returnDocuments: !0 }, n); return Y(this, Po).mutate({ patch: this.serialize() }, i) } }; Po = new WeakMap; let Lo = g0; const FA = { returnDocuments: !1 }; class zA { constructor(t = [], n) { Se(this, "operations"); Se(this, "trxId"); this.operations = t, this.trxId = n } create(t) { return Tl("create", t), this._add({ create: t }) } createIfNotExists(t) { const n = "createIfNotExists"; return Tl(n, t), tf(n, t), this._add({ [n]: t }) } createOrReplace(t) { const n = "createOrReplace"; return Tl(n, t), tf(n, t), this._add({ [n]: t }) } delete(t) { return OA("delete", t), this._add({ delete: { id: t } }) } transactionId(t) { return t ? (this.trxId = t, this) : this.trxId } serialize() { return [...this.operations] } toJSON() { return this.serialize() } reset() { return this.operations = [], this } _add(t) { return this.operations.push(t), this } } var Ci; const v0 = class v0 extends zA { constructor(n, r, i) { super(n, i); Le(this, Ci); Re(this, Ci, r) } clone() { return new v0([...this.operations], Y(this, Ci), this.trxId) } commit(n) { if (!Y(this, Ci)) throw new Error("No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method"); return Y(this, Ci).mutate(this.serialize(), Object.assign({ transactionId: this.trxId }, FA, n || {})) } patch(n, r) { const i = typeof r == "function"; if (typeof n != "string" && n instanceof Lo) return this._add({ patch: n.serialize() }); if (i) { const o = r(new Lo(n, {}, Y(this, Ci))); if (!(o instanceof Lo)) throw new Error("function passed to `patch()` must return the patch"); return this._add({ patch: o.serialize() }) } return this._add({ patch: { id: n, ...r } }) } }; Ci = new WeakMap; let nf = v0; var Pi; const y0 = class y0 extends zA { constructor(n, r, i) { super(n, i); Le(this, Pi); Re(this, Pi, r) } clone() { return new y0([...this.operations], Y(this, Pi), this.trxId) } commit(n) { if (!Y(this, Pi)) throw new Error("No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method"); return Y(this, Pi).mutate(this.serialize(), Object.assign({ transactionId: this.trxId }, FA, n || {})) } patch(n, r) { const i = typeof r == "function"; if (typeof n != "string" && n instanceof Ro) return this._add({ patch: n.serialize() }); if (i) { const o = r(new Ro(n, {}, Y(this, Pi))); if (!(o instanceof Ro)) throw new Error("function passed to `patch()` must return the patch"); return this._add({ patch: o.serialize() }) } return this._add({ patch: { id: n, ...r } }) } }; Pi = new WeakMap; let rf = y0; const nV = "https://www.sanity.io/help/"; function i0(e) { return nV + e } function rV(e) { let t = !1, n; return (...r) => (t || (n = e(...r), t = !0), n) } const Iu = e => rV((...t) => console.warn(e.join(" "), ...t)), iV = Iu(["Because you set `withCredentials` to true, we will override your `useCdn`", "setting to be false since (cookie-based) credentials are never set on the CDN"]), oV = Iu(["Since you haven't set a value for `useCdn`, we will deliver content using our", "global, edge-cached API-CDN. If you wish to have content delivered faster, set", "`useCdn: false` to use the Live API. Note: You may incur higher costs using the live API."]), sV = Iu(["The Sanity client is configured with the `perspective` set to `previewDrafts`, which doesn't support the API-CDN.", "The Live API will be used instead. Set `useCdn: false` in your configuration to hide this warning."]), aV = Iu(["You have configured Sanity client to use a token in the browser. This may cause unintentional security issues.", `See ${i0("js-client-browser-token")} for more information and how to hide this warning.`]), lV = Iu(["Using the Sanity client without specifying an API version is deprecated.", `See ${i0("js-client-api-version")}`]), uV = "apicdn.sanity.io", Cl = { apiHost: "https://api.sanity.io", apiVersion: "1", useProjectHostname: !0, stega: { enabled: !1 } }, cV = ["localhost", "127.0.0.1", "0.0.0.0"], dV = e => cV.indexOf(e) !== -1; function fV(e) { if (e === "1" || e === "X") return; const t = new Date(e); if (!(/^\d{4}-\d{2}-\d{2}$/.test(e) && t instanceof Date && t.getTime() > 0)) throw new Error("Invalid API version string, expected `1` or date in format `YYYY-MM-DD`") } const VA = function (e) { switch (e) { case "previewDrafts": case "published": case "raw": return; default: throw new TypeError("Invalid API perspective string, expected `published`, `previewDrafts` or `raw`") } }, BA = (e, t) => { const n = { ...t, ...e, stega: { ...typeof t.stega == "boolean" ? { enabled: t.stega } : t.stega || Cl.stega, ...typeof e.stega == "boolean" ? { enabled: e.stega } : e.stega || {} } }; n.apiVersion || lV(); const r = { ...Cl, ...n }, i = r.useProjectHostname; if (typeof Promise > "u") { const d = i0("js-client-promise-polyfill"); throw new Error(`No native Promise-implementation found, polyfill needed - see ${d}`) } if (i && !r.projectId) throw new Error("Configuration must contain `projectId`"); if (typeof r.perspective == "string" && VA(r.perspective), "encodeSourceMap" in r) throw new Error("It looks like you're using options meant for '@sanity/preview-kit/client'. 'encodeSourceMap' is not supported in '@sanity/client'. Did you mean 'stega.enabled'?"); if ("encodeSourceMapAtPath" in r) throw new Error("It looks like you're using options meant for '@sanity/preview-kit/client'. 'encodeSourceMapAtPath' is not supported in '@sanity/client'. Did you mean 'stega.filter'?"); if (typeof r.stega.enabled != "boolean") throw new Error(`stega.enabled must be a boolean, received ${r.stega.enabled}`); if (r.stega.enabled && r.stega.studioUrl === void 0) throw new Error("stega.studioUrl must be defined when stega.enabled is true"); if (r.stega.enabled && typeof r.stega.studioUrl != "string" && typeof r.stega.studioUrl != "function") throw new Error(`stega.studioUrl must be a string or a function, received ${r.stega.studioUrl}`); const o = typeof window < "u" && window.location && window.location.hostname, s = o && dV(window.location.hostname); o && s && r.token && r.ignoreBrowserTokenWarning !== !0 ? aV() : typeof r.useCdn > "u" && oV(), i && Z9(r.projectId), r.dataset && NA(r.dataset), "requestTagPrefix" in r && (r.requestTagPrefix = r.requestTagPrefix ? IA(r.requestTagPrefix).replace(/\.+$/, "") : void 0), r.apiVersion = `${r.apiVersion}`.replace(/^v/, ""), r.isDefaultApi = r.apiHost === Cl.apiHost, r.useCdn === !0 && r.withCredentials && iV(), r.useCdn = r.useCdn !== !1 && !r.withCredentials, fV(r.apiVersion); const a = r.apiHost.split("://", 2), l = a[0], u = a[1], c = r.isDefaultApi ? uV : u; return r.useProjectHostname ? (r.url = `${l}://${r.projectId}.${u}/v${r.apiVersion}`, r.cdnUrl = `${l}://${r.projectId}.${c}/v${r.apiVersion}`) : (r.url = `${r.apiHost}/v${r.apiVersion}`, r.cdnUrl = r.url), r }, pV = "X-Sanity-Project-ID"; function hV(e, t = {}) { const n = {}, r = t.token || e.token; r && (n.Authorization = `Bearer ${r}`), !t.useGlobalApi && !e.useProjectHostname && e.projectId && (n[pV] = e.projectId); const i = !!(typeof t.withCredentials > "u" ? e.token || e.withCredentials : t.withCredentials), o = typeof t.timeout > "u" ? e.timeout : t.timeout; return Object.assign({}, t, { headers: Object.assign({}, n, t.headers || {}), timeout: typeof o > "u" ? 5 * 60 * 1e3 : o, proxy: t.proxy || e.proxy, json: !0, withCredentials: i, fetch: typeof t.fetch == "object" && typeof e.fetch == "object" ? { ...e.fetch, ...t.fetch } : t.fetch || e.fetch }) } const UA = ({ query: e, params: t = {}, options: n = {} }) => { const r = new URLSearchParams, { tag: i, includeMutations: o, returnQuery: s, ...a } = n; i && r.append("tag", i), r.append("query", e); for (const [l, u] of Object.entries(t)) r.append(`$${l}`, JSON.stringify(u)); for (const [l, u] of Object.entries(a)) u && r.append(l, `${u}`); return s === !1 && r.append("returnQuery", "false"), o === !1 && r.append("includeMutations", "false"), `?${r}` }, mV = (e, t) => e === !1 ? void 0 : typeof e > "u" ? t : e, gV = (e = {}) => ({ dryRun: e.dryRun, returnIds: !0, returnDocuments: mV(e.returnDocuments, !0), visibility: e.visibility || "sync", autoGenerateArrayKeys: e.autoGenerateArrayKeys, skipCrossDatasetReferenceValidation: e.skipCrossDatasetReferenceValidation }), o0 = e => e.type === "response", vV = e => e.body, yV = (e, t) => e.reduce((n, r) => (n[t(r)] = r, n), Object.create(null)), bV = 11264; function HA(e, t, n, r, i = {}, o = {}) { const s = "stega" in o ? { ...n || {}, ...typeof o.stega == "boolean" ? { enabled: o.stega } : o.stega || {} } : n, a = s.enabled ? B9(i) : i, l = o.filterResponse === !1 ? m => m : m => m.result, { cache: u, next: c, ...d } = { useAbortSignal: typeof o.signal < "u", resultSourceMap: s.enabled ? "withKeyArraySelector" : o.resultSourceMap, ...o, returnQuery: o.filterResponse === !1 && o.returnQuery !== !1 }, f = typeof u < "u" || typeof c < "u" ? { ...d, fetch: { cache: u, next: c } } : d, p = xa(e, t, "query", { query: r, params: a }, f); return s.enabled ? p.pipe(N9(MA(ga(() => import("./stegaEncodeSourceMap-DFGaYAH0.js"), []).then(function (m) { return m.stegaEncodeSourceMap$1 }).then(({ stegaEncodeSourceMap: m }) => m))), si(([m, v]) => { const x = v(m.result, m.resultSourceMap, s); return l({ ...m, result: x }) })) : p.pipe(si(l)) } function WA(e, t, n, r = {}) { const i = { uri: ns(e, "doc", n), json: !0, tag: r.tag, signal: r.signal }; return Du(e, t, i).pipe(ju(o0), si(o => o.body.documents && o.body.documents[0])) } function GA(e, t, n, r = {}) { const i = { uri: ns(e, "doc", n.join(",")), json: !0, tag: r.tag, signal: r.signal }; return Du(e, t, i).pipe(ju(o0), si(o => { const s = yV(o.body.documents || [], a => a._id); return n.map(a => s[a] || null) })) } function KA(e, t, n, r) { return tf("createIfNotExists", n), ep(e, t, n, "createIfNotExists", r) } function qA(e, t, n, r) { return tf("createOrReplace", n), ep(e, t, n, "createOrReplace", r) } function YA(e, t, n, r) { return xa(e, t, "mutate", { mutations: [{ delete: LA(n) }] }, r) } function QA(e, t, n, r) { let i; n instanceof Lo || n instanceof Ro ? i = { patch: n.serialize() } : n instanceof nf || n instanceof rf ? i = n.serialize() : i = n; const o = Array.isArray(i) ? i : [i], s = r && r.transactionId || void 0; return xa(e, t, "mutate", { mutations: o, transactionId: s }, r) } function XA(e, t, n, r) { const i = Array.isArray(n) ? n : [n], o = r && r.transactionId || void 0, s = r && r.skipCrossDatasetReferenceValidation || void 0, a = r && r.dryRun || void 0; return xa(e, t, "actions", { actions: i, transactionId: o, skipCrossDatasetReferenceValidation: s, dryRun: a }, r) } function xa(e, t, n, r, i = {}) { const o = n === "mutate", s = n === "actions", a = n === "query", l = o || s ? "" : UA(r), u = !o && !s && l.length < bV, c = u ? l : "", d = i.returnFirst, { timeout: f, token: p, tag: m, headers: v, returnQuery: x, lastLiveEventId: g } = i, h = ns(e, n, c), y = { method: u ? "GET" : "POST", uri: h, json: !0, body: u ? void 0 : r, query: o && gV(i), timeout: f, headers: v, token: p, tag: m, returnQuery: x, perspective: i.perspective, resultSourceMap: i.resultSourceMap, lastLiveEventId: Array.isArray(g) ? g[0] : g, canUseCdn: a, signal: i.signal, fetch: i.fetch, useAbortSignal: i.useAbortSignal, useCdn: i.useCdn }; return Du(e, t, y).pipe(ju(o0), si(vV), si(E => { if (!o) return E; const P = E.results || []; if (i.returnDocuments) return d ? P[0] && P[0].document : P.map(b => b.document); const $ = d ? "documentId" : "documentIds", L = d ? P[0] && P[0].id : P.map(b => b.id); return { transactionId: E.transactionId, results: P, [$]: L } })) } function ep(e, t, n, r, i = {}) { const o = { [r]: n }, s = Object.assign({ returnFirst: !0, returnDocuments: !0 }, i); return xa(e, t, "mutate", { mutations: [o] }, s) } function Du(e, t, n) { const r = n.url || n.uri, i = e.config(), o = typeof n.canUseCdn > "u" ? ["GET", "HEAD"].indexOf(n.method || "GET") >= 0 && r.indexOf("/data/") === 0 : n.canUseCdn; let s = (n.useCdn ?? i.useCdn) && o; const a = n.tag && i.requestTagPrefix ? [i.requestTagPrefix, n.tag].join(".") : n.tag || i.requestTagPrefix; if (a && n.tag !== null && (n.query = { tag: IA(a), ...n.query }), ["GET", "HEAD", "POST"].indexOf(n.method || "GET") >= 0 && r.indexOf("/data/query/") === 0) { const c = n.resultSourceMap ?? i.resultSourceMap; c !== void 0 && c !== !1 && (n.query = { resultSourceMap: c, ...n.query }); const d = n.perspective || i.perspective; typeof d == "string" && d !== "raw" && (VA(d), n.query = { perspective: d, ...n.query }, d === "previewDrafts" && s && (s = !1, sV())), n.lastLiveEventId && (n.query = { ...n.query, lastLiveEventId: n.lastLiveEventId }), n.returnQuery === !1 && (n.query = { returnQuery: "false", ...n.query }) } const l = hV(i, Object.assign({}, n, { url: s0(e, r, s) })), u = new nr(c => t(l, i.requester).subscribe(c)); return n.signal ? u.pipe(wV(n.signal)) : u } function gr(e, t, n) { return Du(e, t, n).pipe(ju(r => r.type === "response"), si(r => r.body)) } function ns(e, t, n) { const r = e.config(), i = jA(r), o = `/${t}/${i}`; return `/data${n ? `${o}/${n}` : o}`.replace(/\/($|\?)/, "$1") } function s0(e, t, n = !1) { const { url: r, cdnUrl: i } = e.config(); return `${n ? i : r}/${t.replace(/^\//, "")}` } function wV(e) { return t => new nr(n => { const r = () => n.error(SV(e)); if (e && e.aborted) { r(); return } const i = t.subscribe(n); return e.addEventListener("abort", r), () => { e.removeEventListener("abort", r), i.unsubscribe() } }) } const xV = !!globalThis.DOMException; function SV(e) { if (xV) return new DOMException((e == null ? void 0 : e.reason) ?? "The operation was aborted.", "AbortError"); const t = new Error((e == null ? void 0 : e.reason) ?? "The operation was aborted."); return t.name = "AbortError", t } var fu, pu; class EV { constructor(t, n) { Le(this, fu); Le(this, pu); Re(this, fu, t), Re(this, pu, n) } upload(t, n, r) { return JA(Y(this, fu), Y(this, pu), t, n, r) } } fu = new WeakMap, pu = new WeakMap; var hu, mu; class TV { constructor(t, n) { Le(this, hu); Le(this, mu); Re(this, hu, t), Re(this, mu, n) } upload(t, n, r) { const i = JA(Y(this, hu), Y(this, mu), t, n, r); return At(i.pipe(ju(o => o.type === "response"), si(o => o.body.document))) } } hu = new WeakMap, mu = new WeakMap; function JA(e, t, n, r, i = {}) { eV(n); let o = i.extract || void 0; o && !o.length && (o = ["none"]); const s = jA(e.config()), a = n === "image" ? "images" : "files", l = CV(i, r), { tag: u, label: c, title: d, description: f, creditLine: p, filename: m, source: v } = l, x = { label: c, title: d, description: f, filename: m, meta: o, creditLine: p }; return v && (x.sourceId = v.id, x.sourceName = v.name, x.sourceUrl = v.url), Du(e, t, { tag: u, method: "POST", timeout: l.timeout || 0, uri: `/assets/${a}/${s}`, headers: l.contentType ? { "Content-Type": l.contentType } : {}, query: x, body: r }) } function CV(e, t) { return typeof File > "u" || !(t instanceof File) ? e : Object.assign({ filename: e.preserveFilename === !1 ? void 0 : t.name, contentType: t.type }, e) } var PV = (e, t) => Object.keys(t).concat(Object.keys(e)).reduce((n, r) => (n[r] = typeof e[r] > "u" ? t[r] : e[r], n), {}); const $V = (e, t) => t.reduce((n, r) => (typeof e[r] > "u" || (n[r] = e[r]), n), {}), AV = 14800, MV = ["includePreviousRevision", "includeResult", "includeMutations", "visibility", "effectFormat", "tag"], kV = { includeResult: !0 }; function ZA(e, t, n = {}) { const { url: r, token: i, withCredentials: o, requestTagPrefix: s } = this.config(), a = n.tag && s ? [s, n.tag].join(".") : n.tag, l = { ...PV(n, kV), tag: a }, u = $V(l, MV), c = UA({ query: e, params: t, options: { tag: a, ...u } }), d = `${r}${ns(this, "listen", c)}`; if (d.length > AV) return new nr(v => v.error(new Error("Query too large for listener"))); const f = l.events ? l.events : ["mutation"], p = f.indexOf("reconnect") !== -1, m = {}; return (i || o) && (m.withCredentials = !0), i && (m.headers = { Authorization: `Bearer ${i}` }), new nr(v => { let x, g, h = !1, y = !1; A(); function E() { h || (M(), !h && x.readyState === x.CLOSED && (b(), clearTimeout(g), g = setTimeout(A, 100))) } function P(C) { v.error(_V(C)) } function $(C) { const k = eM(C); return k instanceof Error ? v.error(k) : v.next(k) } function L() { h = !0, b(), v.complete() } function b() { x && (x.removeEventListener("error", E), x.removeEventListener("channelError", P), x.removeEventListener("disconnect", L), f.forEach(C => x.removeEventListener(C, $)), x.close()) } function M() { p && v.next({ type: "reconnect" }) } async function R() { const { default: C } = await ga(async () => { const { default: O } = await import("./browser-BqPgn7jU.js").then(U => U.b); return { default: O } }, []); if (y) return; const k = new C(d, m); return k.addEventListener("error", E), k.addEventListener("channelError", P), k.addEventListener("disconnect", L), f.forEach(O => k.addEventListener(O, $)), k } function A() { R().then(C => { C && (x = C, y && b()) }).catch(C => { v.error(C), _() }) } function _() { h = !0, b(), y = !0 } return _ }) } function eM(e) { try { const t = e.data && JSON.parse(e.data) || {}; return Object.assign({ type: e.type }, t) } catch (t) { return t } } function _V(e) { if (e instanceof Error) return e; const t = eM(e); return t instanceof Error ? t : new Error(RV(t)) } function RV(e) { return e.error ? e.error.description ? e.error.description : typeof e.error == "string" ? e.error : JSON.stringify(e.error, null, 2) : e.message || "Unknown listener error" } const aS = "2021-03-26"; var $o; class tM { constructor(t) { Le(this, $o); Re(this, $o, t) } events() { const t = Y(this, $o).config().apiVersion.replace(/^v/, ""); if (t !== "X" && t < aS) throw new Error(`The live events API requires API version ${aS} or later. The current API version is ${t}. Please update your API version to use this feature.`); const n = ns(Y(this, $o), "live/events"), r = new URL(Y(this, $o).getUrl(n, !1)), i = ["restart", "message"]; return new nr(o => { let s, a, l = !1, u = !1; m(); function c(x) { if (!l) { if ("data" in x) { const g = lS(x); o.error(new Error(g.message, { cause: g })) } s.readyState === s.CLOSED && (f(), clearTimeout(a), a = setTimeout(m, 100)) } } function d(x) { const g = lS(x); return g instanceof Error ? o.error(g) : o.next(g) } function f() { if (s) { s.removeEventListener("error", c); for (const x of i) s.removeEventListener(x, d); s.close() } } async function p() { const x = typeof EventSource > "u" ? (await ga(async () => { const { default: h } = await import("./browser-BqPgn7jU.js").then(y => y.b); return { default: h } }, [])).default : EventSource; if (u) return; const g = new x(r.toString()); g.addEventListener("error", c); for (const h of i) g.addEventListener(h, d); return g } function m() { p().then(x => { x && (s = x, u && f()) }).catch(x => { o.error(x), v() }) } function v() { l = !0, f(), u = !0 } return v }) } } $o = new WeakMap; function lS(e) { try { const t = e.data && JSON.parse(e.data) || {}; return { type: e.type, id: e.lastEventId, ...t } } catch (t) { return t } } var $i, Ai; class LV { constructor(t, n) { Le(this, $i); Le(this, Ai); Re(this, $i, t), Re(this, Ai, n) } create(t, n) { return Ws(Y(this, $i), Y(this, Ai), "PUT", t, n) } edit(t, n) { return Ws(Y(this, $i), Y(this, Ai), "PATCH", t, n) } delete(t) { return Ws(Y(this, $i), Y(this, Ai), "DELETE", t) } list() { return gr(Y(this, $i), Y(this, Ai), { uri: "/datasets", tag: null }) } } $i = new WeakMap, Ai = new WeakMap; var Mi, ki; class NV { constructor(t, n) { Le(this, Mi); Le(this, ki); Re(this, Mi, t), Re(this, ki, n) } create(t, n) { return At(Ws(Y(this, Mi), Y(this, ki), "PUT", t, n)) } edit(t, n) { return At(Ws(Y(this, Mi), Y(this, ki), "PATCH", t, n)) } delete(t) { return At(Ws(Y(this, Mi), Y(this, ki), "DELETE", t)) } list() { return At(gr(Y(this, Mi), Y(this, ki), { uri: "/datasets", tag: null })) } } Mi = new WeakMap, ki = new WeakMap; function Ws(e, t, n, r, i) { return NA(r), gr(e, t, { method: n, uri: `/datasets/${r}`, body: i, tag: null }) } var qs, Ys; class OV { constructor(t, n) { Le(this, qs); Le(this, Ys); Re(this, qs, t), Re(this, Ys, n) } list(t) { const n = (t == null ? void 0 : t.includeMembers) === !1 ? "/projects?includeMembers=false" : "/projects"; return gr(Y(this, qs), Y(this, Ys), { uri: n }) } getById(t) { return gr(Y(this, qs), Y(this, Ys), { uri: `/projects/${t}` }) } } qs = new WeakMap, Ys = new WeakMap; var Qs, Xs; class jV { constructor(t, n) { Le(this, Qs); Le(this, Xs); Re(this, Qs, t), Re(this, Xs, n) } list(t) { const n = (t == null ? void 0 : t.includeMembers) === !1 ? "/projects?includeMembers=false" : "/projects"; return At(gr(Y(this, Qs), Y(this, Xs), { uri: n })) } getById(t) { return At(gr(Y(this, Qs), Y(this, Xs), { uri: `/projects/${t}` })) } } Qs = new WeakMap, Xs = new WeakMap; var gu, vu; class IV { constructor(t, n) { Le(this, gu); Le(this, vu); Re(this, gu, t), Re(this, vu, n) } getById(t) { return gr(Y(this, gu), Y(this, vu), { uri: `/users/${t}` }) } } gu = new WeakMap, vu = new WeakMap; var yu, bu; class DV { constructor(t, n) { Le(this, yu); Le(this, bu); Re(this, yu, t), Re(this, bu, n) } getById(t) { return At(gr(Y(this, yu), Y(this, bu), { uri: `/users/${t}` })) } } yu = new WeakMap, bu = new WeakMap; var Ur, St; const df = class df { constructor(t, n = Cl) { Se(this, "assets"); Se(this, "datasets"); Se(this, "live"); Se(this, "projects"); Se(this, "users"); Le(this, Ur); Le(this, St); Se(this, "listen", ZA); this.config(n), Re(this, St, t), this.assets = new EV(this, Y(this, St)), this.datasets = new LV(this, Y(this, St)), this.live = new tM(this), this.projects = new OV(this, Y(this, St)), this.users = new IV(this, Y(this, St)) } clone() { return new df(Y(this, St), this.config()) } config(t) { if (t === void 0) return { ...Y(this, Ur) }; if (Y(this, Ur) && Y(this, Ur).allowReconfigure === !1) throw new Error("Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client"); return Re(this, Ur, BA(t, Y(this, Ur) || {})), this } withConfig(t) { const n = this.config(); return new df(Y(this, St), { ...n, ...t, stega: { ...n.stega || {}, ...typeof (t == null ? void 0 : t.stega) == "boolean" ? { enabled: t.stega } : (t == null ? void 0 : t.stega) || {} } }) } fetch(t, n, r) { return HA(this, Y(this, St), Y(this, Ur).stega, t, n, r) } getDocument(t, n) { return WA(this, Y(this, St), t, n) } getDocuments(t, n) { return GA(this, Y(this, St), t, n) } create(t, n) { return ep(this, Y(this, St), t, "create", n) } createIfNotExists(t, n) { return KA(this, Y(this, St), t, n) } createOrReplace(t, n) { return qA(this, Y(this, St), t, n) } delete(t, n) { return YA(this, Y(this, St), t, n) } mutate(t, n) { return QA(this, Y(this, St), t, n) } patch(t, n) { return new Ro(t, n, this) } transaction(t) { return new rf(t, this) } action(t, n) { return XA(this, Y(this, St), t, n) } request(t) { return gr(this, Y(this, St), t) } getUrl(t, n) { return s0(this, t, n) } getDataUrl(t, n) { return ns(this, t, n) } }; Ur = new WeakMap, St = new WeakMap; let Ng = df; var Hr, dt; const ff = class ff { constructor(t, n = Cl) { Se(this, "assets"); Se(this, "datasets"); Se(this, "live"); Se(this, "projects"); Se(this, "users"); Se(this, "observable"); Le(this, Hr); Le(this, dt); Se(this, "listen", ZA); this.config(n), Re(this, dt, t), this.assets = new TV(this, Y(this, dt)), this.datasets = new NV(this, Y(this, dt)), this.live = new tM(this), this.projects = new jV(this, Y(this, dt)), this.users = new DV(this, Y(this, dt)), this.observable = new Ng(t, n) } clone() { return new ff(Y(this, dt), this.config()) } config(t) { if (t === void 0) return { ...Y(this, Hr) }; if (Y(this, Hr) && Y(this, Hr).allowReconfigure === !1) throw new Error("Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client"); return this.observable && this.observable.config(t), Re(this, Hr, BA(t, Y(this, Hr) || {})), this } withConfig(t) { const n = this.config(); return new ff(Y(this, dt), { ...n, ...t, stega: { ...n.stega || {}, ...typeof (t == null ? void 0 : t.stega) == "boolean" ? { enabled: t.stega } : (t == null ? void 0 : t.stega) || {} } }) } fetch(t, n, r) { return At(HA(this, Y(this, dt), Y(this, Hr).stega, t, n, r)) } getDocument(t, n) { return At(WA(this, Y(this, dt), t, n)) } getDocuments(t, n) { return At(GA(this, Y(this, dt), t, n)) } create(t, n) { return At(ep(this, Y(this, dt), t, "create", n)) } createIfNotExists(t, n) { return At(KA(this, Y(this, dt), t, n)) } createOrReplace(t, n) { return At(qA(this, Y(this, dt), t, n)) } delete(t, n) { return At(YA(this, Y(this, dt), t, n)) } mutate(t, n) { return At(QA(this, Y(this, dt), t, n)) } patch(t, n) { return new Lo(t, n, this) } transaction(t) { return new nf(t, this) } action(t, n) { return At(XA(this, Y(this, dt), t, n)) } request(t) { return At(gr(this, Y(this, dt), t)) } dataRequest(t, n, r) { return At(xa(this, Y(this, dt), t, n, r)) } getUrl(t, n) { return s0(this, t, n) } getDataUrl(t, n) { return ns(this, t, n) } }; Hr = new WeakMap, dt = new WeakMap; let Og = ff; function FV(e, t) { const n = X9(e); return { requester: n, createClient: r => new t((i, o) => (o || n)({ maxRedirects: 0, maxRetries: r.maxRetries, retryDelay: r.retryDelay, ...i }), r) } } var zV = []; const VV = FV(zV, Og), BV = VV.createClient, nM = BV({ projectId: "zjsm6jfa", dataset: "production", apiVersion: "2022-03-07", useCdn: !0 }), a0 = (e = 1) => {
  const [t, n] = S.useState([]), [r, i] = S.useState(!0), [o, s] = S.useState(null), a = 6, l = (e - 1) * a, c = `*[_type == "post" ] | order(_createdAt desc) [${l}...${l + a - 1}]{
  _id,
  title,
  slug,
  excerpt,
  mainImage {
    asset-> {
      _id,
      url
    }
  },
  categories[]->{
    title
  }
}
`; return S.useEffect(() => { (async () => { try { const f = await nM.fetch(c); n(f) } catch (f) { s(f) } finally { i(!1) } })() }, []), { blogs: t, loading: r, error: o }
}, UV = e => { const [t, n] = S.useState(null), [r, i] = S.useState(!0); return S.useEffect(() => { (async () => { try { const s = await mt.get(`${hA}/api/blog/${e}`); n(s.data.data) } catch (s) { console.error(s) } finally { i(!1) } })() }, [e]), { blog: t, loading: r } }, HV = (e = 1) => { const [t, n] = S.useState([]), [r, i] = S.useState(!0); return S.useEffect(() => { (async () => { var s; i(!0); try { const a = await mt.get(`${hA}/api/blog?page=${e}`); n((s = a == null ? void 0 : a.data) == null ? void 0 : s.data) } catch (a) { console.error(a) } finally { i(!1) } })() }, [e]), { blogs: t, loading: r } };/**
 * @license lucide-react v0.429.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const WV = e => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), rM = (...e) => e.filter((t, n, r) => !!t && r.indexOf(t) === n).join(" ");/**
 * @license lucide-react v0.429.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var GV = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" };/**
 * @license lucide-react v0.429.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const KV = S.forwardRef(({ color: e = "currentColor", size: t = 24, strokeWidth: n = 2, absoluteStrokeWidth: r, className: i = "", children: o, iconNode: s, ...a }, l) => S.createElement("svg", { ref: l, ...GV, width: t, height: t, stroke: e, strokeWidth: r ? Number(n) * 24 / Number(t) : n, className: rM("lucide", i), ...a }, [...s.map(([u, c]) => S.createElement(u, c)), ...Array.isArray(o) ? o : [o]]));/**
 * @license lucide-react v0.429.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const iM = (e, t) => { const n = S.forwardRef(({ className: r, ...i }, o) => S.createElement(KV, { ref: o, iconNode: t, className: rM(`lucide-${WV(e)}`, r), ...i })); return n.displayName = `${e}`, n };/**
 * @license lucide-react v0.429.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const oM = iM("LoaderCircle", [["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]]);/**
 * @license lucide-react v0.429.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const qV = iM("TriangleAlert", [["path", { d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3", key: "wmoenq" }], ["path", { d: "M12 9v4", key: "juzpu7" }], ["path", { d: "M12 17h.01", key: "p32p05" }]]), Fu = () => w.jsx("div", { className: "flex items-center justify-center min-h-screen", children: w.jsx(oM, { className: "animate-spin text-blue-500", size: 48 }) }), YV = () => { const e = WF().id, { blog: t, loading: n } = UV(e), { blogs: r, loading: i } = a0(1); return n || i ? w.jsx(Fu, {}) : t ? w.jsxs("div", { className: "mt-10 w-[90%] md:w-[80%] mx-auto", children: [w.jsx(r8, { blog: t }), w.jsx(n8, { blog: t }), w.jsxs("div", { className: "flex flex-col gap-10 mt-20 w-full", children: [w.jsxs("div", { className: "flex justify-between items-center w-full", children: [w.jsx("h2", { className: "text-4xl font-extrabold", children: "Similar Articles" }), w.jsx(Lu, { toLink: "/hosts", text: "See All Hosts" })] }), w.jsx("div", { className: "grid lg:grid-cols-2 gap-4 w-full", children: r.data.slice(0, 2).map((o, s) => w.jsx(Wy, { blog: o }, s)) })] })] }) : w.jsxs("div", { className: "flex flex-col items-center justify-center mt-10 w-[90%] md:w-[80%] mx-auto text-center", children: [w.jsx(qV, { className: "text-red-500 mb-3", size: 40 }), w.jsxs("h1", { className: "text-xl font-semibold text-gray-500", children: ["Oops! 404 Error: Blog not found.", " "] })] }) }; function QV(e) { return vr({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "square", strokeMiterlimit: "10", strokeWidth: "48", d: "M328 112 184 256l144 144" }, child: [] }] })(e) } function XV(e) { return vr({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "square", strokeMiterlimit: "10", strokeWidth: "48", d: "m184 112 144 144-144 144" }, child: [] }] })(e) } function JV({ pages: e, page: t, setPage: n }) { const r = ({ ref: i, key: o, value: s, isActive: a, className: l }) => s === $t.NEXT ? t < e && w.jsx("button", { className: Jp(l, "min-w-9 w-9 h-9"), onClick: () => n(t + 1), children: w.jsx(XV, { size: 22, className: "text-mainText" }) }, o) : s === $t.PREV ? t > 1 && w.jsx("button", { className: Jp(l, "min-w-9 w-9 h-9"), onClick: () => n(t - 1), children: w.jsx(QV, { size: 22, className: "text-mainText" }) }, o) : s === $t.DOTS ? w.jsx("button", { className: `${l} text-mainText tracking-widest`, children: "..." }, o) : w.jsx("button", { ref: i, className: `text-mainText border-1 border-secondary rounded-full ${Jp(l, a && " bg-primary font-bold")}`, onClick: () => n(s), children: s }, o); return w.jsx(B5, { disableCursorAnimation: !0, showControls: !0, total: e, initialPage: t, className: "mt-8 flex justify-center border-2 border-gray-500 rounded-full mx-auto w-[90%] lg:w-[70%] md:w-[80%]", radius: "md", renderItem: r, variant: "light" }) } const ZV = "/assets/SubscribeImage-C68YNYAC.png", zu = () => w.jsxs(oi.div, { initial: { y: "50%" }, whileInView: { y: 0 }, transition: { duration: .8 }, className: "gap-8 mt-20 flex flex-col lg:flex-row bg-transparent w-[90%] lg:w-[70%] md:w-[80%] mx-auto", children: [w.jsx("div", { className: "pb-0 pt-2 px-4 flex-col h-[250px] md:w-[50%]", children: w.jsx("img", { alt: "Card background", className: "object-cover h-full w-full", src: ZV }) }), w.jsxs("div", { className: "flex flex-col gap-6", children: [w.jsxs("h3", { className: "text-4xl font-bold", children: ["Subscribe our ", w.jsx("br", {}), "YouTube Channel"] }), w.jsx("p", { className: "text-sm text-mainText", children: "Subscribe for update episodes" }), w.jsx(Dy, { className: "text-mainText rounded-full px-6 py-1 bg-primary", children: w.jsx("a", { target: "_blank", href: "https://www.youtube.com/channel/UCO0mVgRyCGWXOqmJ3UukIlg", rel: "noopener noreferrer", className: "text-center w-full", children: "Subscribe" }) })] })] }); function eB() { return w.jsxs(Fy, { className: "w-full space-y-5 p-4 bg-background shadow-none", children: [w.jsx(Sc, { className: "rounded-lg bg-secondary", children: w.jsx("div", { className: "h-60 rounded-lg bg-default-300" }) }), w.jsxs("div", { className: "space-y-3", children: [w.jsx(Sc, { className: "w-3/5 rounded-lg", children: w.jsx("div", { className: "h-4 w-3/5 rounded-lg bg-default-200" }) }), w.jsx(Sc, { className: "w-4/5 rounded-lg", children: w.jsx("div", { className: "h-4 w-4/5 rounded-lg bg-default-200" }) }), w.jsx(Sc, { className: "w-2/5 rounded-lg", children: w.jsx("div", { className: "h-4 w-2/5 rounded-lg bg-default-300" }) })] })] }) } function sM({ name: e, customMsg: t }) { return w.jsx("div", { className: "flex flex-col items-center justify-center mt-10 w-[90%] md:w-[80%] mx-auto text-center bg-gray-950 p-4 max-w-[1064px] ", children: w.jsx(oM, { className: "text-primary mb-3 animate-spin", size: 40 }) }) } const tB = () => { const [e, t] = S.useState(1), { blogs: n, loading: r } = a0(e); return !n || !n.data ? w.jsx(sM, { name: "blogs" }) : w.jsxs("div", { className: "min-h-[100vh] mt-5 mx-auto w-[90%] lg:w-[70%] md:w-[80%]", children: [w.jsxs("div", { className: "flex flex-col md:flex-row w-full md:w-[100%] gap-6", children: [w.jsx("h1", { className: "text-white text-4xl font-bold whitespace-nowrap", children: "All Articles" }), w.jsx("div", { className: "text-md", children: w.jsx("p", { className: "text-white", children: "We are a collective of passionate dedicated to delivering immersive audio experiences that resonate with your heart & mind." }) })] }), w.jsx("div", { className: "grid lg:grid-cols-2 gap-8 mt-4", children: r ? Array(6).fill().map((i, o) => w.jsx(eB, {}, o)) : n.data.map((i, o) => w.jsx(Wy, { blog: i }, o)) }), w.jsx(JV, { pages: n.pagination.pages, page: n.pagination.page, setPage: t }), w.jsx(zu, {})] }) }, nB = "/assets/customer-care-BXGMexqp.png", rB = () => { const [e, t] = S.useState(""), n = async r => { r.preventDefault(), t("Sending...."); const i = new FormData(r.target); i.append("access_key", _z); const s = await (await fetch("https://api.web3forms.com/submit", { method: "POST", body: i })).json(); s.success ? (t("Form Submitted Successfully"), r.target.reset()) : (console.log("Error", s), t(s.message)) }; return w.jsx("div", { className: "w-[90%] md:w-[80%] mx-auto flex gap-4", children: w.jsxs("div", { className: "flex gap-6 flex-col", children: [w.jsxs("div", { className: "flex flex-col md:flex-row gap-10 w-full", children: [w.jsx("h1", { className: "text-white text-4xl font-bold whitespace-nowrap", children: "Contact us" }), w.jsx("div", { className: "text-md", children: w.jsx("p", { className: "text-gray-300", children: "We are a collective of passionate individuals dedicated to delivering immersive audio experiences that resonate with your heart & mind." }) })] }), w.jsxs("div", { className: "grid md:grid-cols-[2fr_3fr] gap-3 rounded-md w-full overflow-hidden", children: [w.jsx("img", { src: nB, alt: "Contact us", loading: "lazy", className: "object-cover w-full h-[400px] md:h-full" }), w.jsxs("div", { className: "h-full flex flex-col gap-4 p-3", children: [w.jsx("h2", { className: "text-2xl font-bold text-white", children: "Contact details" }), w.jsxs("div", { className: "grid lg:grid-cols-2 gap-8 mt-4", children: [w.jsxs("div", { children: [w.jsx("h3", { className: "text-md text-gray-200", children: "Email" }), w.jsx("p", { className: "text-sm text-gray-400", children: "You can email us at ceo@journeystory.in" }), w.jsx("p", { className: "text-sm text-gray-400", children: "Whether you have inquiries about our podcasts or need technical support, feel free to reach out." })] }), w.jsxs("div", { children: [w.jsx("h3", { className: "text-md text-gray-200", children: "Customer Support" }), w.jsx("p", { className: "text-sm text-gray-400", children: "You can contact us at: +91 8530975857" })] })] }), w.jsxs("form", { className: "flex flex-col gap-4", onSubmit: n, children: [w.jsx(Hx, { type: "text", label: "Your name", placeholder: "Enter your name", className: "w-full text-white rounded-xl border border-gray-800", variant: "bordered" }), w.jsx(Hx, { type: "email", label: "Email", placeholder: "Enter your email", className: "w-full text-white rounded-xl border border-gray-800", variant: "bordered" }), w.jsx(a6, { label: "Message", placeholder: "Enter your message...", className: "w-full text-white rounded-xl border border-gray-800", variant: "bordered" }), w.jsx(Dy, { className: "bg-primary font-bold text-white", type: "submit", children: "Send" })] }), w.jsx("span", { children: e })] })] })] }) }) }, iB = () => w.jsx("div", { className: "bg-background text-white overflow-hidden", children: w.jsxs("div", { className: "min-h-[100vh] mt-5 w-full", children: [w.jsx(rB, {}), w.jsx(zu, {})] }) }), aM = (e = 1) => {
  const [t, n] = S.useState([]), [r, i] = S.useState(!0), [o, s] = S.useState(null), a = `*[_type == "episode"]{
  _id,
    
  title,
  categories[]->{
    title
  },
  url,
  duration,
  description,
  thumbnail {
    asset-> {
      _id,
      url
    }
  }
}

`; return S.useEffect(() => { (async () => { try { const u = await nM.fetch(a); n(u) } catch (u) { s(u) } finally { i(!1) } })() }, []), { episodes: t, loading: r, error: o }
}; function oB(e) { return vr({ tag: "svg", attr: { viewBox: "0 0 1024 1024" }, child: [{ tag: "path", attr: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm176.5 585.7l-28.6 39a7.99 7.99 0 0 1-11.2 1.7L483.3 569.8a7.92 7.92 0 0 1-3.3-6.5V288c0-4.4 3.6-8 8-8h48.1c4.4 0 8 3.6 8 8v247.5l142.6 103.1c3.6 2.5 4.4 7.5 1.8 11.1z" }, child: [] }] })(e) } function sB(e) { const t = S.useRef(null); return S.useImperativeHandle(e, () => t.current), t } function lM(e) { var t, n, r = ""; if (typeof e == "string" || typeof e == "number") r += e; else if (typeof e == "object") if (Array.isArray(e)) for (t = 0; t < e.length; t++)e[t] && (n = lM(e[t])) && (r && (r += " "), r += n); else for (t in e) e[t] && (r && (r += " "), r += t); return r } function uS(...e) { for (var t = 0, n, r, i = ""; t < e.length;)(n = e[t++]) && (r = lM(n)) && (i && (i += " "), i += r); return i } function aB(e) { if (!e || typeof e != "object") return ""; try { return JSON.stringify(e) } catch { return "" } } const l0 = typeof document < "u" ? se.useLayoutEffect : () => { }; function ms(e) { const t = S.useRef(null); return l0(() => { t.current = e }, [e]), S.useCallback((...n) => { const r = t.current; return r == null ? void 0 : r(...n) }, []) } let cS = new Map; function lB(e, t) { if (e === t) return e; let n = cS.get(e); if (n) return n(t), t; let r = cS.get(t); return r ? (r(e), e) : t } function uM(...e) { return (...t) => { for (let n of e) typeof n == "function" && n(...t) } } const Yn = e => { var t; return (t = e == null ? void 0 : e.ownerDocument) !== null && t !== void 0 ? t : document }, Pr = e => e && "window" in e && e.window === e ? e : Yn(e).defaultView || window; function cM(e) { var t, n, r = ""; if (typeof e == "string" || typeof e == "number") r += e; else if (typeof e == "object") if (Array.isArray(e)) { var i = e.length; for (t = 0; t < i; t++)e[t] && (n = cM(e[t])) && (r && (r += " "), r += n) } else for (n in e) e[n] && (r && (r += " "), r += n); return r } function uB() { for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++)(e = arguments[n]) && (t = cM(e)) && (r && (r += " "), r += t); return r } function u0(...e) { let t = { ...e[0] }; for (let n = 1; n < e.length; n++) { let r = e[n]; for (let i in r) { let o = t[i], s = r[i]; typeof o == "function" && typeof s == "function" && i[0] === "o" && i[1] === "n" && i.charCodeAt(2) >= 65 && i.charCodeAt(2) <= 90 ? t[i] = uM(o, s) : (i === "className" || i === "UNSAFE_className") && typeof o == "string" && typeof s == "string" ? t[i] = uB(o, s) : i === "id" && o && s ? t.id = lB(o, s) : t[i] = s !== void 0 ? s : o } } return t } function ul(e) { if (cB()) e.focus({ preventScroll: !0 }); else { let t = dB(e); e.focus(), fB(t) } } let Ac = null; function cB() { if (Ac == null) { Ac = !1; try { document.createElement("div").focus({ get preventScroll() { return Ac = !0, !0 } }) } catch { } } return Ac } function dB(e) { let t = e.parentNode, n = [], r = document.scrollingElement || document.documentElement; for (; t instanceof HTMLElement && t !== r;)(t.offsetHeight < t.scrollHeight || t.offsetWidth < t.scrollWidth) && n.push({ element: t, scrollTop: t.scrollTop, scrollLeft: t.scrollLeft }), t = t.parentNode; return r instanceof HTMLElement && n.push({ element: r, scrollTop: r.scrollTop, scrollLeft: r.scrollLeft }), n } function fB(e) { for (let { element: t, scrollTop: n, scrollLeft: r } of e) t.scrollTop = n, t.scrollLeft = r } function tp(e) { var t; return typeof window > "u" || window.navigator == null ? !1 : ((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.brands.some(n => e.test(n.brand))) || e.test(window.navigator.userAgent) } function c0(e) { var t; return typeof window < "u" && window.navigator != null ? e.test(((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.platform) || window.navigator.platform) : !1 } function ou() { return c0(/^Mac/i) } function pB() { return c0(/^iPhone/i) } function dM() { return c0(/^iPad/i) || ou() && navigator.maxTouchPoints > 1 } function fM() { return pB() || dM() } function hB() { return tp(/AppleWebKit/i) && !mB() } function mB() { return tp(/Chrome/i) } function pM() { return tp(/Android/i) } function gB() { return tp(/Firefox/i) } function su(e, t, n = !0) { var r, i; let { metaKey: o, ctrlKey: s, altKey: a, shiftKey: l } = t; gB() && (!((i = window.event) === null || i === void 0 || (r = i.type) === null || r === void 0) && r.startsWith("key")) && e.target === "_blank" && (ou() ? o = !0 : s = !0); let u = hB() && ou() && !dM() ? new KeyboardEvent("keydown", { keyIdentifier: "Enter", metaKey: o, ctrlKey: s, altKey: a, shiftKey: l }) : new MouseEvent("click", { metaKey: o, ctrlKey: s, altKey: a, shiftKey: l, bubbles: !0, cancelable: !0 }); su.isOpening = n, ul(e), e.dispatchEvent(u), su.isOpening = !1 } su.isOpening = !1; let gs = new Map, jg = new Set; function dS() { if (typeof window > "u") return; function e(r) { return "propertyName" in r } let t = r => { if (!e(r) || !r.target) return; let i = gs.get(r.target); i || (i = new Set, gs.set(r.target, i), r.target.addEventListener("transitioncancel", n, { once: !0 })), i.add(r.propertyName) }, n = r => { if (!e(r) || !r.target) return; let i = gs.get(r.target); if (i && (i.delete(r.propertyName), i.size === 0 && (r.target.removeEventListener("transitioncancel", n), gs.delete(r.target)), gs.size === 0)) { for (let o of jg) o(); jg.clear() } }; document.body.addEventListener("transitionrun", t), document.body.addEventListener("transitionend", n) } typeof document < "u" && (document.readyState !== "loading" ? dS() : document.addEventListener("DOMContentLoaded", dS)); function vB(e) { requestAnimationFrame(() => { gs.size === 0 ? e() : jg.add(e) }) } function yB() { let e = S.useRef(new Map), t = S.useCallback((i, o, s, a) => { let l = a != null && a.once ? (...u) => { e.current.delete(s), s(...u) } : s; e.current.set(s, { type: o, eventTarget: i, fn: l, options: a }), i.addEventListener(o, s, a) }, []), n = S.useCallback((i, o, s, a) => { var l; let u = ((l = e.current.get(s)) === null || l === void 0 ? void 0 : l.fn) || s; i.removeEventListener(o, u, a), e.current.delete(s) }, []), r = S.useCallback(() => { e.current.forEach((i, o) => { n(i.eventTarget, i.type, o, i.options) }) }, [n]); return S.useEffect(() => r, [r]), { addGlobalListener: t, removeGlobalListener: n, removeAllGlobalListeners: r } } function bB(e, t) { l0(() => { if (e && e.ref && t) return e.ref.current = t.current, () => { e.ref && (e.ref.current = null) } }) } function Ig(e) { return e.mozInputSource === 0 && e.isTrusted ? !0 : pM() && e.pointerType ? e.type === "click" && e.buttons === 1 : e.detail === 0 && !e.pointerType } function wB(e) { return !pM() && e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === "mouse" } function xB(e) { return S.forwardRef(e) } var SB = (e, t, n = !0) => { if (!t) return [e, {}]; const r = t.reduce((i, o) => o in e ? { ...i, [o]: e[o] } : i, {}); return n ? [Object.keys(e).filter(o => !t.includes(o)).reduce((o, s) => ({ ...o, [s]: e[s] }), {}), r] : [e, r] }; let js = "default", Dg = "", nd = new WeakMap; function fS(e) { if (fM()) { if (js === "default") { const t = Yn(e); Dg = t.documentElement.style.webkitUserSelect, t.documentElement.style.webkitUserSelect = "none" } js = "disabled" } else (e instanceof HTMLElement || e instanceof SVGElement) && (nd.set(e, e.style.userSelect), e.style.userSelect = "none") } function Mc(e) { if (fM()) { if (js !== "disabled") return; js = "restoring", setTimeout(() => { vB(() => { if (js === "restoring") { const t = Yn(e); t.documentElement.style.webkitUserSelect === "none" && (t.documentElement.style.webkitUserSelect = Dg || ""), Dg = "", js = "default" } }) }, 300) } else if ((e instanceof HTMLElement || e instanceof SVGElement) && e && nd.has(e)) { let t = nd.get(e); e.style.userSelect === "none" && (e.style.userSelect = t), e.getAttribute("style") === "" && e.removeAttribute("style"), nd.delete(e) } } const hM = se.createContext({ register: () => { } }); hM.displayName = "PressResponderContext"; function EB(e) { let t = S.useContext(hM); if (t) { let { register: n, ...r } = t; e = u0(r, e), n() } return bB(t, e.ref), e } var kc = new WeakMap; class _c { continuePropagation() { Md(this, kc, !1) } get shouldStopPropagation() { return hC(this, kc) } constructor(t, n, r) { XT(this, kc, { writable: !0, value: void 0 }), Md(this, kc, !0), this.type = t, this.pointerType = n, this.target = r.currentTarget, this.shiftKey = r.shiftKey, this.metaKey = r.metaKey, this.ctrlKey = r.ctrlKey, this.altKey = r.altKey } } const pS = Symbol("linkClicked"); function TB(e) { let { onPress: t, onPressChange: n, onPressStart: r, onPressEnd: i, onPressUp: o, isDisabled: s, isPressed: a, preventFocusOnPress: l, shouldCancelOnPointerExit: u, allowTextSelectionOnPress: c, ref: d, ...f } = EB(e), [p, m] = S.useState(!1), v = S.useRef({ isPressed: !1, ignoreEmulatedMouseEvents: !1, ignoreClickAfterPress: !1, didFirePressStart: !1, isTriggeringEvent: !1, activePointerId: null, target: null, isOverTarget: !1, pointerType: null }), { addGlobalListener: x, removeAllGlobalListeners: g } = yB(), h = ms((b, M) => { let R = v.current; if (s || R.didFirePressStart) return !1; let A = !0; if (R.isTriggeringEvent = !0, r) { let _ = new _c("pressstart", M, b); r(_), A = _.shouldStopPropagation } return n && n(!0), R.isTriggeringEvent = !1, R.didFirePressStart = !0, m(!0), A }), y = ms((b, M, R = !0) => { let A = v.current; if (!A.didFirePressStart) return !1; A.ignoreClickAfterPress = !0, A.didFirePressStart = !1, A.isTriggeringEvent = !0; let _ = !0; if (i) { let C = new _c("pressend", M, b); i(C), _ = C.shouldStopPropagation } if (n && n(!1), m(!1), t && R && !s) { let C = new _c("press", M, b); t(C), _ && (_ = C.shouldStopPropagation) } return A.isTriggeringEvent = !1, _ }), E = ms((b, M) => { let R = v.current; if (s) return !1; if (o) { R.isTriggeringEvent = !0; let A = new _c("pressup", M, b); return o(A), R.isTriggeringEvent = !1, A.shouldStopPropagation } return !0 }), P = ms(b => { let M = v.current; M.isPressed && M.target && (M.isOverTarget && M.pointerType != null && y(Dr(M.target, b), M.pointerType, !1), M.isPressed = !1, M.isOverTarget = !1, M.activePointerId = null, M.pointerType = null, g(), c || Mc(M.target)) }), $ = ms(b => { u && P(b) }), L = S.useMemo(() => { let b = v.current, M = { onKeyDown(A) { if (wh(A.nativeEvent, A.currentTarget) && A.currentTarget.contains(A.target)) { var _; mS(A.target, A.key) && A.preventDefault(); let C = !0; if (!b.isPressed && !A.repeat) { b.target = A.currentTarget, b.isPressed = !0, C = h(A, "keyboard"); let k = A.currentTarget, O = U => { wh(U, k) && !U.repeat && k.contains(U.target) && b.target && E(Dr(b.target, U), "keyboard") }; x(Yn(A.currentTarget), "keyup", uM(O, R), !0) } C && A.stopPropagation(), A.metaKey && ou() && ((_ = b.metaKeyEvents) === null || _ === void 0 || _.set(A.key, A.nativeEvent)) } else A.key === "Meta" && (b.metaKeyEvents = new Map) }, onClick(A) { if (!(A && !A.currentTarget.contains(A.target)) && A && A.button === 0 && !b.isTriggeringEvent && !su.isOpening) { let _ = !0; if (s && A.preventDefault(), !b.ignoreClickAfterPress && !b.ignoreEmulatedMouseEvents && !b.isPressed && (b.pointerType === "virtual" || Ig(A.nativeEvent))) { !s && !l && ul(A.currentTarget); let C = h(A, "virtual"), k = E(A, "virtual"), O = y(A, "virtual"); _ = C && k && O } b.ignoreEmulatedMouseEvents = !1, b.ignoreClickAfterPress = !1, _ && A.stopPropagation() } } }, R = A => { var _; if (b.isPressed && b.target && wh(A, b.target)) { var C; mS(A.target, A.key) && A.preventDefault(); let O = A.target; y(Dr(b.target, A), "keyboard", b.target.contains(O)), g(), A.key !== "Enter" && d0(b.target) && b.target.contains(O) && !A[pS] && (A[pS] = !0, su(b.target, A, !1)), b.isPressed = !1, (C = b.metaKeyEvents) === null || C === void 0 || C.delete(A.key) } else if (A.key === "Meta" && (!((_ = b.metaKeyEvents) === null || _ === void 0) && _.size)) { var k; let O = b.metaKeyEvents; b.metaKeyEvents = void 0; for (let U of O.values()) (k = b.target) === null || k === void 0 || k.dispatchEvent(new KeyboardEvent("keyup", U)) } }; if (typeof PointerEvent < "u") { M.onPointerDown = k => { if (k.button !== 0 || !k.currentTarget.contains(k.target)) return; if (wB(k.nativeEvent)) { b.pointerType = "virtual"; return } xh(k.currentTarget) && k.preventDefault(), b.pointerType = k.pointerType; let O = !0; b.isPressed || (b.isPressed = !0, b.isOverTarget = !0, b.activePointerId = k.pointerId, b.target = k.currentTarget, !s && !l && ul(k.currentTarget), c || fS(b.target), O = h(k, b.pointerType), x(Yn(k.currentTarget), "pointermove", A, !1), x(Yn(k.currentTarget), "pointerup", _, !1), x(Yn(k.currentTarget), "pointercancel", C, !1)), O && k.stopPropagation() }, M.onMouseDown = k => { k.currentTarget.contains(k.target) && k.button === 0 && (xh(k.currentTarget) && k.preventDefault(), k.stopPropagation()) }, M.onPointerUp = k => { !k.currentTarget.contains(k.target) || b.pointerType === "virtual" || k.button === 0 && ds(k, k.currentTarget) && E(k, b.pointerType || k.pointerType) }; let A = k => { k.pointerId === b.activePointerId && (b.target && ds(k, b.target) ? !b.isOverTarget && b.pointerType != null && (b.isOverTarget = !0, h(Dr(b.target, k), b.pointerType)) : b.target && b.isOverTarget && b.pointerType != null && (b.isOverTarget = !1, y(Dr(b.target, k), b.pointerType, !1), $(k))) }, _ = k => { k.pointerId === b.activePointerId && b.isPressed && k.button === 0 && b.target && (ds(k, b.target) && b.pointerType != null ? y(Dr(b.target, k), b.pointerType) : b.isOverTarget && b.pointerType != null && y(Dr(b.target, k), b.pointerType, !1), b.isPressed = !1, b.isOverTarget = !1, b.activePointerId = null, b.pointerType = null, g(), c || Mc(b.target)) }, C = k => { P(k) }; M.onDragStart = k => { k.currentTarget.contains(k.target) && P(k) } } else { M.onMouseDown = C => { if (C.button !== 0 || !C.currentTarget.contains(C.target)) return; if (xh(C.currentTarget) && C.preventDefault(), b.ignoreEmulatedMouseEvents) { C.stopPropagation(); return } b.isPressed = !0, b.isOverTarget = !0, b.target = C.currentTarget, b.pointerType = Ig(C.nativeEvent) ? "virtual" : "mouse", !s && !l && ul(C.currentTarget), h(C, b.pointerType) && C.stopPropagation(), x(Yn(C.currentTarget), "mouseup", A, !1) }, M.onMouseEnter = C => { if (!C.currentTarget.contains(C.target)) return; let k = !0; b.isPressed && !b.ignoreEmulatedMouseEvents && b.pointerType != null && (b.isOverTarget = !0, k = h(C, b.pointerType)), k && C.stopPropagation() }, M.onMouseLeave = C => { if (!C.currentTarget.contains(C.target)) return; let k = !0; b.isPressed && !b.ignoreEmulatedMouseEvents && b.pointerType != null && (b.isOverTarget = !1, k = y(C, b.pointerType, !1), $(C)), k && C.stopPropagation() }, M.onMouseUp = C => { C.currentTarget.contains(C.target) && !b.ignoreEmulatedMouseEvents && C.button === 0 && E(C, b.pointerType || "mouse") }; let A = C => { if (C.button === 0) { if (b.isPressed = !1, g(), b.ignoreEmulatedMouseEvents) { b.ignoreEmulatedMouseEvents = !1; return } b.target && ds(C, b.target) && b.pointerType != null ? y(Dr(b.target, C), b.pointerType) : b.target && b.isOverTarget && b.pointerType != null && y(Dr(b.target, C), b.pointerType, !1), b.isOverTarget = !1 } }; M.onTouchStart = C => { if (!C.currentTarget.contains(C.target)) return; let k = CB(C.nativeEvent); if (!k) return; b.activePointerId = k.identifier, b.ignoreEmulatedMouseEvents = !0, b.isOverTarget = !0, b.isPressed = !0, b.target = C.currentTarget, b.pointerType = "touch", !s && !l && ul(C.currentTarget), c || fS(b.target), h(C, b.pointerType) && C.stopPropagation(), x(Pr(C.currentTarget), "scroll", _, !0) }, M.onTouchMove = C => { if (!C.currentTarget.contains(C.target)) return; if (!b.isPressed) { C.stopPropagation(); return } let k = hS(C.nativeEvent, b.activePointerId), O = !0; k && ds(k, C.currentTarget) ? !b.isOverTarget && b.pointerType != null && (b.isOverTarget = !0, O = h(C, b.pointerType)) : b.isOverTarget && b.pointerType != null && (b.isOverTarget = !1, O = y(C, b.pointerType, !1), $(C)), O && C.stopPropagation() }, M.onTouchEnd = C => { if (!C.currentTarget.contains(C.target)) return; if (!b.isPressed) { C.stopPropagation(); return } let k = hS(C.nativeEvent, b.activePointerId), O = !0; k && ds(k, C.currentTarget) && b.pointerType != null ? (E(C, b.pointerType), O = y(C, b.pointerType)) : b.isOverTarget && b.pointerType != null && (O = y(C, b.pointerType, !1)), O && C.stopPropagation(), b.isPressed = !1, b.activePointerId = null, b.isOverTarget = !1, b.ignoreEmulatedMouseEvents = !0, b.target && !c && Mc(b.target), g() }, M.onTouchCancel = C => { C.currentTarget.contains(C.target) && (C.stopPropagation(), b.isPressed && P(C)) }; let _ = C => { b.isPressed && C.target.contains(b.target) && P({ currentTarget: b.target, shiftKey: !1, ctrlKey: !1, metaKey: !1, altKey: !1 }) }; M.onDragStart = C => { C.currentTarget.contains(C.target) && P(C) } } return M }, [x, s, l, g, c, P, $, y, h, E]); return S.useEffect(() => () => { var b; c || Mc((b = v.current.target) !== null && b !== void 0 ? b : void 0) }, [c]), { isPressed: a || p, pressProps: u0(f, L) } } function d0(e) { return e.tagName === "A" && e.hasAttribute("href") } function wh(e, t) { const { key: n, code: r } = e, i = t, o = i.getAttribute("role"); return (n === "Enter" || n === " " || n === "Spacebar" || r === "Space") && !(i instanceof Pr(i).HTMLInputElement && !mM(i, n) || i instanceof Pr(i).HTMLTextAreaElement || i.isContentEditable) && !((o === "link" || !o && d0(i)) && n !== "Enter") } function CB(e) { const { targetTouches: t } = e; return t.length > 0 ? t[0] : null } function hS(e, t) { const n = e.changedTouches; for (let r = 0; r < n.length; r++) { const i = n[r]; if (i.identifier === t) return i } return null } function Dr(e, t) { return { currentTarget: e, shiftKey: t.shiftKey, ctrlKey: t.ctrlKey, metaKey: t.metaKey, altKey: t.altKey } } function PB(e) { let t = 0, n = 0; return e.width !== void 0 ? t = e.width / 2 : e.radiusX !== void 0 && (t = e.radiusX), e.height !== void 0 ? n = e.height / 2 : e.radiusY !== void 0 && (n = e.radiusY), { top: e.clientY - n, right: e.clientX + t, bottom: e.clientY + n, left: e.clientX - t } } function $B(e, t) { return !(e.left > t.right || t.left > e.right || e.top > t.bottom || t.top > e.bottom) } function ds(e, t) { let n = t.getBoundingClientRect(), r = PB(e); return $B(n, r) } function xh(e) { return !(e instanceof HTMLElement) || !e.hasAttribute("draggable") } function mS(e, t) { return e instanceof HTMLInputElement ? !mM(e, t) : e instanceof HTMLButtonElement ? e.type !== "submit" && e.type !== "reset" : !d0(e) } const AB = new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]); function mM(e, t) { return e.type === "checkbox" || e.type === "radio" ? t === " " : AB.has(e.type) } class MB { isDefaultPrevented() { return this.nativeEvent.defaultPrevented } preventDefault() { this.defaultPrevented = !0, this.nativeEvent.preventDefault() } stopPropagation() { this.nativeEvent.stopPropagation(), this.isPropagationStopped = () => !0 } isPropagationStopped() { return !1 } persist() { } constructor(t, n) { this.nativeEvent = n, this.target = n.target, this.currentTarget = n.currentTarget, this.relatedTarget = n.relatedTarget, this.bubbles = n.bubbles, this.cancelable = n.cancelable, this.defaultPrevented = n.defaultPrevented, this.eventPhase = n.eventPhase, this.isTrusted = n.isTrusted, this.timeStamp = n.timeStamp, this.type = t } } function gM(e) { let t = S.useRef({ isFocused: !1, observer: null }); l0(() => { const r = t.current; return () => { r.observer && (r.observer.disconnect(), r.observer = null) } }, []); let n = ms(r => { e == null || e(r) }); return S.useCallback(r => { if (r.target instanceof HTMLButtonElement || r.target instanceof HTMLInputElement || r.target instanceof HTMLTextAreaElement || r.target instanceof HTMLSelectElement) { t.current.isFocused = !0; let i = r.target, o = s => { t.current.isFocused = !1, i.disabled && n(new MB("blur", s)), t.current.observer && (t.current.observer.disconnect(), t.current.observer = null) }; i.addEventListener("focusout", o, { once: !0 }), t.current.observer = new MutationObserver(() => { if (t.current.isFocused && i.disabled) { var s; (s = t.current.observer) === null || s === void 0 || s.disconnect(); let a = i === document.activeElement ? null : document.activeElement; i.dispatchEvent(new FocusEvent("blur", { relatedTarget: a })), i.dispatchEvent(new FocusEvent("focusout", { bubbles: !0, relatedTarget: a })) } }), t.current.observer.observe(i, { attributes: !0, attributeFilter: ["disabled"] }) } }, [n]) } function kB(e) { let { isDisabled: t, onFocus: n, onBlur: r, onFocusChange: i } = e; const o = S.useCallback(l => { if (l.target === l.currentTarget) return r && r(l), i && i(!1), !0 }, [r, i]), s = gM(o), a = S.useCallback(l => { const u = Yn(l.target); l.target === l.currentTarget && u.activeElement === l.target && (n && n(l), i && i(!0), s(l)) }, [i, n, s]); return { focusProps: { onFocus: !t && (n || i || r) ? a : void 0, onBlur: !t && (r || i) ? o : void 0 } } } let Vu = null, Fg = new Set, Pl = new Map, Wo = !1, zg = !1; const _B = { Tab: !0, Escape: !0 }; function f0(e, t) { for (let n of Fg) n(e, t) } function RB(e) { return !(e.metaKey || !ou() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta") } function of(e) { Wo = !0, RB(e) && (Vu = "keyboard", f0("keyboard", e)) } function Kn(e) { Vu = "pointer", (e.type === "mousedown" || e.type === "pointerdown") && (Wo = !0, f0("pointer", e)) } function vM(e) { Ig(e) && (Wo = !0, Vu = "virtual") } function yM(e) { e.target === window || e.target === document || (!Wo && !zg && (Vu = "virtual", f0("virtual", e)), Wo = !1, zg = !1) } function bM() { Wo = !1, zg = !0 } function Vg(e) { if (typeof window > "u" || Pl.get(Pr(e))) return; const t = Pr(e), n = Yn(e); let r = t.HTMLElement.prototype.focus; t.HTMLElement.prototype.focus = function () { Wo = !0, r.apply(this, arguments) }, n.addEventListener("keydown", of, !0), n.addEventListener("keyup", of, !0), n.addEventListener("click", vM, !0), t.addEventListener("focus", yM, !0), t.addEventListener("blur", bM, !1), typeof PointerEvent < "u" ? (n.addEventListener("pointerdown", Kn, !0), n.addEventListener("pointermove", Kn, !0), n.addEventListener("pointerup", Kn, !0)) : (n.addEventListener("mousedown", Kn, !0), n.addEventListener("mousemove", Kn, !0), n.addEventListener("mouseup", Kn, !0)), t.addEventListener("beforeunload", () => { wM(e) }, { once: !0 }), Pl.set(t, { focus: r }) } const wM = (e, t) => { const n = Pr(e), r = Yn(e); t && r.removeEventListener("DOMContentLoaded", t), Pl.has(n) && (n.HTMLElement.prototype.focus = Pl.get(n).focus, r.removeEventListener("keydown", of, !0), r.removeEventListener("keyup", of, !0), r.removeEventListener("click", vM, !0), n.removeEventListener("focus", yM, !0), n.removeEventListener("blur", bM, !1), typeof PointerEvent < "u" ? (r.removeEventListener("pointerdown", Kn, !0), r.removeEventListener("pointermove", Kn, !0), r.removeEventListener("pointerup", Kn, !0)) : (r.removeEventListener("mousedown", Kn, !0), r.removeEventListener("mousemove", Kn, !0), r.removeEventListener("mouseup", Kn, !0)), Pl.delete(n)) }; function LB(e) { const t = Yn(e); let n; return t.readyState !== "loading" ? Vg(e) : (n = () => { Vg(e) }, t.addEventListener("DOMContentLoaded", n)), () => wM(e, n) } typeof document < "u" && LB(); function xM() { return Vu !== "pointer" } const NB = new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]); function OB(e, t, n) { var r; const i = typeof window < "u" ? Pr(n == null ? void 0 : n.target).HTMLInputElement : HTMLInputElement, o = typeof window < "u" ? Pr(n == null ? void 0 : n.target).HTMLTextAreaElement : HTMLTextAreaElement, s = typeof window < "u" ? Pr(n == null ? void 0 : n.target).HTMLElement : HTMLElement, a = typeof window < "u" ? Pr(n == null ? void 0 : n.target).KeyboardEvent : KeyboardEvent; return e = e || (n == null ? void 0 : n.target) instanceof i && !NB.has(n == null || (r = n.target) === null || r === void 0 ? void 0 : r.type) || (n == null ? void 0 : n.target) instanceof o || (n == null ? void 0 : n.target) instanceof s && (n == null ? void 0 : n.target.isContentEditable), !(e && t === "keyboard" && n instanceof a && !_B[n.key]) } function jB(e, t, n) { Vg(), S.useEffect(() => { let r = (i, o) => { OB(!!(n != null && n.isTextInput), i, o) && e(xM()) }; return Fg.add(r), () => { Fg.delete(r) } }, t) } function IB(e) { let { isDisabled: t, onBlurWithin: n, onFocusWithin: r, onFocusWithinChange: i } = e, o = S.useRef({ isFocusWithin: !1 }), s = S.useCallback(u => { o.current.isFocusWithin && !u.currentTarget.contains(u.relatedTarget) && (o.current.isFocusWithin = !1, n && n(u), i && i(!1)) }, [n, i, o]), a = gM(s), l = S.useCallback(u => { !o.current.isFocusWithin && document.activeElement === u.target && (r && r(u), i && i(!0), o.current.isFocusWithin = !0, a(u)) }, [r, i, a]); return t ? { focusWithinProps: { onFocus: void 0, onBlur: void 0 } } : { focusWithinProps: { onFocus: l, onBlur: s } } } function DB(e = {}) { let { autoFocus: t = !1, isTextInput: n, within: r } = e, i = S.useRef({ isFocused: !1, isFocusVisible: t || xM() }), [o, s] = S.useState(!1), [a, l] = S.useState(() => i.current.isFocused && i.current.isFocusVisible), u = S.useCallback(() => l(i.current.isFocused && i.current.isFocusVisible), []), c = S.useCallback(p => { i.current.isFocused = p, s(p), u() }, [u]); jB(p => { i.current.isFocusVisible = p, u() }, [], { isTextInput: n }); let { focusProps: d } = kB({ isDisabled: r, onFocusChange: c }), { focusWithinProps: f } = IB({ isDisabled: !r, onFocusWithinChange: c }); return { isFocused: o, isFocusVisible: a, focusProps: r ? f : d } } function FB(e) { const [t, n] = SB(e, Vd.variantKeys), { ref: r, as: i, children: o, avatar: s, startContent: a, endContent: l, onClose: u, classNames: c, className: d, ...f } = t, p = i || "div", m = sB(r), v = uS(c == null ? void 0 : c.base, d), x = !!u, g = e.variant === "dot", { focusProps: h, isFocusVisible: y } = DB(), E = S.useMemo(() => typeof o == "string" && (o == null ? void 0 : o.length) === 1, [o]), P = S.useMemo(() => !!s || !!a, [s, a]), $ = S.useMemo(() => !!l || x, [l, x]), L = S.useMemo(() => Vd({ ...n, hasStartContent: P, hasEndContent: $, isOneChar: E, isCloseable: x, isCloseButtonFocusVisible: y }), [aB(n), y, P, $, E, x]), { pressProps: b } = TB({ isDisabled: !!(e != null && e.isDisabled), onPress: u }), M = () => ({ ref: m, className: L.base({ class: v }), ...f }), R = () => ({ role: "button", tabIndex: 0, className: L.closeButton({ class: c == null ? void 0 : c.closeButton }), "aria-label": "close chip", ...u0(b, h) }), A = C => S.isValidElement(C) ? S.cloneElement(C, { className: L.avatar({ class: c == null ? void 0 : c.avatar }) }) : null, _ = C => S.isValidElement(C) ? S.cloneElement(C, { className: uS("max-h-[80%]", C.props.className) }) : null; return { Component: p, children: o, slots: L, classNames: c, isDot: g, isCloseable: x, startContent: A(s) || _(a), endContent: _(l), getCloseButtonProps: R, getChipProps: M } } var zB = e => w.jsx("svg", { "aria-hidden": "true", focusable: "false", height: "1em", role: "presentation", viewBox: "0 0 24 24", width: "1em", ...e, children: w.jsx("path", { d: "M12 2a10 10 0 1010 10A10.016 10.016 0 0012 2zm3.36 12.3a.754.754 0 010 1.06.748.748 0 01-1.06 0l-2.3-2.3-2.3 2.3a.748.748 0 01-1.06 0 .754.754 0 010-1.06l2.3-2.3-2.3-2.3A.75.75 0 019.7 8.64l2.3 2.3 2.3-2.3a.75.75 0 011.06 1.06l-2.3 2.3z", fill: "currentColor" }) }), SM = xB((e, t) => { const { Component: n, children: r, slots: i, classNames: o, isDot: s, isCloseable: a, startContent: l, endContent: u, getCloseButtonProps: c, getChipProps: d } = FB({ ...e, ref: t }), f = S.useMemo(() => s && !l ? w.jsx("span", { className: i.dot({ class: o == null ? void 0 : o.dot }) }) : l, [i, l, s]), p = S.useMemo(() => a ? w.jsx("span", { ...c(), children: u || w.jsx(zB, {}) }) : u, [u, a, c]); return w.jsxs(n, { ...d(), children: [f, w.jsx("span", { className: i.content({ class: o == null ? void 0 : o.content }), children: r }), p] }) }); SM.displayName = "NextUI.Chip"; var VB = SM; const BB = ({ episode: e }) => w.jsx(oi.div, { initial: { opacity: 0, y: 30 }, whileInView: { opacity: 1, y: 0 }, transition: { duration: .5 }, className: "episode", children: w.jsx(Oi, { to: e == null ? void 0 : e.url, target: "_blank", rel: "noopener noreferrer", className: "group", children: w.jsxs("div", { className: "grid md:grid-cols-[1fr_4fr_4fr] gap-3 p-4 rounded-lg my-4", children: [w.jsx("div", { className: "flex flex-row md:flex-col justify-between md:justify-normal text-mainText text-lg bg-gradient-to-t from-background to-primary h-fit", children: w.jsxs("div", { className: "flex md:border-t-1 md:border-secondary items-center h-14 gap-2 md:bg-gradient-to-r md:from-background md:to-primary p-2", children: [w.jsx(oB, { className: "text-2xl text-mainText" }), e.duration, " mins"] }) }), w.jsx("div", { className: "flex items-start min-h-[200px] w-[100%] md:min-w-[300px] overflow-hidden relative ", children: w.jsx(qf, { src: e == null ? void 0 : e.thumbnail.asset.url, alt: "episode thumbnail", className: "w-full h-full object-cover transform group-hover:scale-105 transition-transform duration-500" }) }), w.jsxs("div", { className: "flex flex-col gap-4 py-1", children: [w.jsx("div", { className: "text-primary font-semibold text-md", children: e.categories.length > 0 && w.jsxs(VB, { color: "success", variant: "faded", size: "md", className: "mt-2", children: [e.categories[0].title, " "] }) }), w.jsx("p", { className: "text-xl md:text-2xl font-semibold", children: e == null ? void 0 : e.title }), (e == null ? void 0 : e.description) && w.jsxs("p", { className: "text-md ", children: [e == null ? void 0 : e.description.substr(0, 200), "..."] })] })] }) }) }), EM = S.memo(BB), UB = () => { const [e, t] = S.useState(1), { episodes: n, loading: r } = aM(e); return console.log(n), w.jsxs("div", { className: "min-h-[100vh] mt-5 w-[90%] lg:w-[70%] md:w-[80%] mx-auto", children: [w.jsxs("div", { className: "flex flex-col md:flex-row gap-6", children: [w.jsx("h1", { className: "text-white text-4xl font-semibold whitespace-nowrap", children: "All Episodes" }), w.jsx("div", { className: "text-md", children: w.jsx("p", { className: "text-white", children: "We are a collective of passionate dedicated to delivering immersive audio experiences that resonate with your heart & mind." }) })] }), w.jsx(S.Suspense, { fallback: w.jsx(Fu, {}), children: w.jsx("div", { className: "w-full", children: n.map(i => w.jsx(EM, { episode: i }, i._id)) }) }), w.jsx(zu, {})] }) }, HB = () => {
  const [e, t] = S.useState([]), [n, r] = S.useState(!0), [i, o] = S.useState(null), s = `*[_type == "team"] | order(index asc) {
    _id,
    index,
    name,
    slug,
    designation,
    email,
    linkedin,
    instagram,
    image {
      asset-> {
        _id,
        url
      }
    }
  }`; return S.useEffect(() => { (async () => { r(!0); try { const l = await client.fetch(s); t(l), console.log("teams", l) } catch (l) { o(l) } finally { r(!1) } })() }, []), { team: e, loading: n, error: i }
}; function WB(e) { return vr({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M208 32c0-17.7 14.3-32 32-32l32 0c17.7 0 32 14.3 32 32l0 140.9 122-70.4c15.3-8.8 34.9-3.6 43.7 11.7l16 27.7c8.8 15.3 3.6 34.9-11.7 43.7L352 256l122 70.4c15.3 8.8 20.6 28.4 11.7 43.7l-16 27.7c-8.8 15.3-28.4 20.6-43.7 11.7L304 339.1 304 480c0 17.7-14.3 32-32 32l-32 0c-17.7 0-32-14.3-32-32l0-140.9L86 409.6c-15.3 8.8-34.9 3.6-43.7-11.7l-16-27.7c-8.8-15.3-3.6-34.9 11.7-43.7L160 256 38 185.6c-15.3-8.8-20.5-28.4-11.7-43.7l16-27.7C51.1 98.8 70.7 93.6 86 102.4l122 70.4L208 32z" }, child: [] }] })(e) } const Sh = ["Lifestyles", "Technology", "Health", "Comedy", "Entertainment", "Business", "Politics", "Arts"], GB = () => w.jsx("div", { className: "my-10 h-20 flex items-center overflow-hidden bg-gradient-to-b from-primary to-background shadow-lg w-[90%] lg:w-[70%] md:w-[80%] mx-auto", children: w.jsx(oi.div, { className: "flex items-center space-x-4 whitespace-nowrap", animate: { x: ["0%", "-45%"] }, transition: { duration: 10, repeat: 1 / 0, ease: "linear" }, children: [...Sh, ...Sh].map((e, t) => w.jsxs(se.Fragment, { children: [w.jsx("span", { className: "py-2 px-3 text-center text-md font-normal min-w-max text-mainText", children: e }), t < Sh.length * 2 - 1 && w.jsx(WB, { className: "min-h-3 min-w-3 text-xs text-mainText" })] }, t)) }) }), KB = "/assets/hero-COkIRJEF.png", qB = "/assets/Spotify-fjNfHSsd.svg", YB = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2048%2048'%20width='48px'%20height='48px'%3e%3cpath%20fill='%23FF3D00'%20d='M43.2,33.9c-0.4,2.1-2.1,3.7-4.2,4c-3.3,0.5-8.8,1.1-15,1.1c-6.1,0-11.6-0.6-15-1.1c-2.1-0.3-3.8-1.9-4.2-4C4.4,31.6,4,28.2,4,24c0-4.2,0.4-7.6,0.8-9.9c0.4-2.1,2.1-3.7,4.2-4C12.3,9.6,17.8,9,24,9c6.2,0,11.6,0.6,15,1.1c2.1,0.3,3.8,1.9,4.2,4c0.4,2.3,0.9,5.7,0.9,9.9C44,28.2,43.6,31.6,43.2,33.9z'/%3e%3cpath%20fill='%23FFF'%20d='M20%2031L20%2017%2032%2024z'/%3e%3c/svg%3e", QB = () => w.jsxs("div", { className: "w-full mt-8", children: [w.jsx("img", { src: KB, className: "object-cover", alt: "Hero", loading: "lazy" }), w.jsxs("div", { className: "flex items-center justify-center mt-5 h-16", children: [w.jsx("h2", { className: "text-3xl font-bold", children: "Available on:" }), w.jsxs("div", { className: "ml-3 flex items-center justify-between gap-4", children: [w.jsx("a", { href: "https://open.spotify.com/show/1ZQE9AUhjChYhjKTgUr3ld", target: "_blank", rel: "noopener noreferrer", children: w.jsx("img", { src: qB, alt: "Spotify", loading: "lazy", className: "h-10 object-cover" }) }), w.jsx("a", { href: "https://www.youtube.com/@JourneyStoryHindi", target: "_blank", rel: "noopener noreferrer", children: w.jsx("img", { src: YB, alt: "YouTube", loading: "lazy", className: "h-10 object-cover" }) })] })] })] }), XB = ({ blogs: e, loading: t }) => w.jsxs("div", { className: "flex flex-col gap-10 mt-20 w-[90%] lg:w-[70%] md:w-[80%] mx-auto", children: [w.jsxs("div", { className: "flex justify-between items-center w-full", children: [w.jsx("h2", { className: "text-4xl font-extrabold", children: "Latest Articles" }), w.jsx(Lu, { toLink: "https://blogs.journeystory.in/", text: "See All Blogs" })] }), w.jsx(S.Suspense, { fallback: w.jsx(Fu, {}), children: w.jsx("div", { className: "grid lg:grid-cols-2 gap-4 w-full", children: e == null ? void 0 : e.slice(0, 2).map((n, r) => w.jsx(Wy, { blog: n }, r)) }) })] }), JB = () => { const { episodes: e, error: t } = aM(); return w.jsxs("section", { className: "mt-24 w-[90%] lg:w-[70%] md:w-[80%] mx-auto", children: [w.jsx("h2", { className: "text-4xl font-extrabold", children: "Latest Episodes" }), w.jsx(S.Suspense, { fallback: w.jsx(Fu, {}), children: w.jsx("div", { className: "w-full episode-list", initial: "hidden", animate: "visible", variants: { hidden: { opacity: 0 }, visible: { opacity: 1 } }, transition: { duration: .5 }, children: e.slice(0, 3).map(n => w.jsx(EM, { episode: n }, n._id)) }) }), w.jsx("div", { className: "w-full md:w-[40%] flex justify-center", children: w.jsx(Lu, { text: "View All episodes", toLink: "/episodes" }) })] }) }; function ZB(e) { return vr({ tag: "svg", attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { fill: "none", d: "M0 0h24v24H0V0z" }, child: [] }, { tag: "path", attr: { d: "M22 6c0-1.1-.9-2-2-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6zm-2 0-8 4.99L4 6h16zm0 12H4V8l8 5 8-5v10z" }, child: [] }] })(e) } const eU = ({ teamMember: e, index: t, hoverValue: n, handleHover: r }) => w.jsxs(oi.div, { initial: { opacity: 0, scale: .9 }, whileInView: { opacity: 1, scale: 1 }, transition: { duration: .8 }, className: "relative cursor-pointer overflow-hidden  w-full", onMouseEnter: () => r(t), onMouseLeave: () => r(null), children: [w.jsx("div", { className: "w-full overflow-hidden", children: w.jsx(qf, { src: e.imageUrl, alt: e.name, className: `h-[400px] w-full object-cover transition-transform duration-500 ${t === n ? "scale-110" : ""}` }) }), w.jsx("div", { className: `absolute h-full md:w-full bottom-0 left-0 right-0 flex justify-center items-end transition-all duration-500 z-10 ${t === n ? "translate-y-0 opacity-100 bg-gradient-to-b from-transparent to-primary bg-opacity-80" : "translate-y-[100%] opacity-100"}`, children: w.jsxs("div", { className: "flex justify-between gap-4 px-4 py-2 items-center m-4 h-fit w-full bg-secondary", children: [w.jsxs("div", { children: [w.jsx("p", { className: "text-mainText text-md font-bold mb-1 whitespace-nowrap", children: e.name }), w.jsx("p", { className: "text-mainText text-md", children: e.position })] }), w.jsxs("div", { className: "flex space-x-4", children: [w.jsx("a", { href: e.linkedin, target: "_blank", rel: "noopener noreferrer", className: "text-mainText", children: w.jsx(D2, { size: 25 }) }), w.jsx("a", { href: e.instagram, target: "_blank", rel: "noopener noreferrer", className: "text-mainText", children: w.jsx(O2, { size: 25 }) }), w.jsx("a", { href: `mailto:${e.email}`, target: "_blank", rel: "noopener noreferrer", className: "text-mainText", children: w.jsx(ZB, { size: 25 }) })] })] }) })] }, t); function gS(e) { return e !== null && typeof e == "object" && "constructor" in e && e.constructor === Object } function p0(e, t) { e === void 0 && (e = {}), t === void 0 && (t = {}), Object.keys(t).forEach(n => { typeof e[n] > "u" ? e[n] = t[n] : gS(t[n]) && gS(e[n]) && Object.keys(t[n]).length > 0 && p0(e[n], t[n]) }) } const TM = { body: {}, addEventListener() { }, removeEventListener() { }, activeElement: { blur() { }, nodeName: "" }, querySelector() { return null }, querySelectorAll() { return [] }, getElementById() { return null }, createEvent() { return { initEvent() { } } }, createElement() { return { children: [], childNodes: [], style: {}, setAttribute() { }, getElementsByTagName() { return [] } } }, createElementNS() { return {} }, importNode() { return null }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" } }; function Sa() { const e = typeof document < "u" ? document : {}; return p0(e, TM), e } const tU = { document: TM, navigator: { userAgent: "" }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" }, history: { replaceState() { }, pushState() { }, go() { }, back() { } }, CustomEvent: function () { return this }, addEventListener() { }, removeEventListener() { }, getComputedStyle() { return { getPropertyValue() { return "" } } }, Image() { }, Date() { }, screen: {}, setTimeout() { }, clearTimeout() { }, matchMedia() { return {} }, requestAnimationFrame(e) { return typeof setTimeout > "u" ? (e(), null) : setTimeout(e, 0) }, cancelAnimationFrame(e) { typeof setTimeout > "u" || clearTimeout(e) } }; function Dn() { const e = typeof window < "u" ? window : {}; return p0(e, tU), e } function nU(e) { return e === void 0 && (e = ""), e.trim().split(" ").filter(t => !!t.trim()) } function rU(e) { const t = e; Object.keys(t).forEach(n => { try { t[n] = null } catch { } try { delete t[n] } catch { } }) } function Bg(e, t) { return t === void 0 && (t = 0), setTimeout(e, t) } function sf() { return Date.now() } function iU(e) { const t = Dn(); let n; return t.getComputedStyle && (n = t.getComputedStyle(e, null)), !n && e.currentStyle && (n = e.currentStyle), n || (n = e.style), n } function oU(e, t) { t === void 0 && (t = "x"); const n = Dn(); let r, i, o; const s = iU(e); return n.WebKitCSSMatrix ? (i = s.transform || s.webkitTransform, i.split(",").length > 6 && (i = i.split(", ").map(a => a.replace(",", ".")).join(", ")), o = new n.WebKitCSSMatrix(i === "none" ? "" : i)) : (o = s.MozTransform || s.OTransform || s.MsTransform || s.msTransform || s.transform || s.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), r = o.toString().split(",")), t === "x" && (n.WebKitCSSMatrix ? i = o.m41 : r.length === 16 ? i = parseFloat(r[12]) : i = parseFloat(r[4])), t === "y" && (n.WebKitCSSMatrix ? i = o.m42 : r.length === 16 ? i = parseFloat(r[13]) : i = parseFloat(r[5])), i || 0 } function Rc(e) { return typeof e == "object" && e !== null && e.constructor && Object.prototype.toString.call(e).slice(8, -1) === "Object" } function sU(e) { return typeof window < "u" && typeof window.HTMLElement < "u" ? e instanceof HTMLElement : e && (e.nodeType === 1 || e.nodeType === 11) } function Cn() { const e = Object(arguments.length <= 0 ? void 0 : arguments[0]), t = ["__proto__", "constructor", "prototype"]; for (let n = 1; n < arguments.length; n += 1) { const r = n < 0 || arguments.length <= n ? void 0 : arguments[n]; if (r != null && !sU(r)) { const i = Object.keys(Object(r)).filter(o => t.indexOf(o) < 0); for (let o = 0, s = i.length; o < s; o += 1) { const a = i[o], l = Object.getOwnPropertyDescriptor(r, a); l !== void 0 && l.enumerable && (Rc(e[a]) && Rc(r[a]) ? r[a].__swiper__ ? e[a] = r[a] : Cn(e[a], r[a]) : !Rc(e[a]) && Rc(r[a]) ? (e[a] = {}, r[a].__swiper__ ? e[a] = r[a] : Cn(e[a], r[a])) : e[a] = r[a]) } } } return e } function Lc(e, t, n) { e.style.setProperty(t, n) } function CM(e) { let { swiper: t, targetPosition: n, side: r } = e; const i = Dn(), o = -t.translate; let s = null, a; const l = t.params.speed; t.wrapperEl.style.scrollSnapType = "none", i.cancelAnimationFrame(t.cssModeFrameID); const u = n > o ? "next" : "prev", c = (f, p) => u === "next" && f >= p || u === "prev" && f <= p, d = () => { a = new Date().getTime(), s === null && (s = a); const f = Math.max(Math.min((a - s) / l, 1), 0), p = .5 - Math.cos(f * Math.PI) / 2; let m = o + p * (n - o); if (c(m, n) && (m = n), t.wrapperEl.scrollTo({ [r]: m }), c(m, n)) { t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.scrollSnapType = "", setTimeout(() => { t.wrapperEl.style.overflow = "", t.wrapperEl.scrollTo({ [r]: m }) }), i.cancelAnimationFrame(t.cssModeFrameID); return } t.cssModeFrameID = i.requestAnimationFrame(d) }; d() } function $r(e, t) { t === void 0 && (t = ""); const n = [...e.children]; return e instanceof HTMLSlotElement && n.push(...e.assignedElements()), t ? n.filter(r => r.matches(t)) : n } function aU(e, t) { const n = t.contains(e); return !n && t instanceof HTMLSlotElement ? [...t.assignedElements()].includes(e) : n } function af(e) { try { console.warn(e); return } catch { } } function lf(e, t) { t === void 0 && (t = []); const n = document.createElement(e); return n.classList.add(...Array.isArray(t) ? t : nU(t)), n } function lU(e, t) { const n = []; for (; e.previousElementSibling;) { const r = e.previousElementSibling; t ? r.matches(t) && n.push(r) : n.push(r), e = r } return n } function uU(e, t) { const n = []; for (; e.nextElementSibling;) { const r = e.nextElementSibling; t ? r.matches(t) && n.push(r) : n.push(r), e = r } return n } function ji(e, t) { return Dn().getComputedStyle(e, null).getPropertyValue(t) } function uf(e) { let t = e, n; if (t) { for (n = 0; (t = t.previousSibling) !== null;)t.nodeType === 1 && (n += 1); return n } } function PM(e, t) { const n = []; let r = e.parentElement; for (; r;)t ? r.matches(t) && n.push(r) : n.push(r), r = r.parentElement; return n } function Ug(e, t, n) { const r = Dn(); return e[t === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(r.getComputedStyle(e, null).getPropertyValue(t === "width" ? "margin-right" : "margin-top")) + parseFloat(r.getComputedStyle(e, null).getPropertyValue(t === "width" ? "margin-left" : "margin-bottom")) } function Lt(e) { return (Array.isArray(e) ? e : [e]).filter(t => !!t) } let Eh; function cU() { const e = Dn(), t = Sa(); return { smoothScroll: t.documentElement && t.documentElement.style && "scrollBehavior" in t.documentElement.style, touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch) } } function $M() { return Eh || (Eh = cU()), Eh } let Th; function dU(e) { let { userAgent: t } = e === void 0 ? {} : e; const n = $M(), r = Dn(), i = r.navigator.platform, o = t || r.navigator.userAgent, s = { ios: !1, android: !1 }, a = r.screen.width, l = r.screen.height, u = o.match(/(Android);?[\s\/]+([\d.]+)?/); let c = o.match(/(iPad).*OS\s([\d_]+)/); const d = o.match(/(iPod)(.*OS\s([\d_]+))?/), f = !c && o.match(/(iPhone\sOS|iOS)\s([\d_]+)/), p = i === "Win32"; let m = i === "MacIntel"; const v = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"]; return !c && m && n.touch && v.indexOf(`${a}x${l}`) >= 0 && (c = o.match(/(Version)\/([\d.]+)/), c || (c = [0, 1, "13_0_0"]), m = !1), u && !p && (s.os = "android", s.android = !0), (c || f || d) && (s.os = "ios", s.ios = !0), s } function AM(e) { return e === void 0 && (e = {}), Th || (Th = dU(e)), Th } let Ch; function fU() { const e = Dn(), t = AM(); let n = !1; function r() { const a = e.navigator.userAgent.toLowerCase(); return a.indexOf("safari") >= 0 && a.indexOf("chrome") < 0 && a.indexOf("android") < 0 } if (r()) { const a = String(e.navigator.userAgent); if (a.includes("Version/")) { const [l, u] = a.split("Version/")[1].split(" ")[0].split(".").map(c => Number(c)); n = l < 16 || l === 16 && u < 2 } } const i = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent), o = r(), s = o || i && t.ios; return { isSafari: n || o, needPerspectiveFix: n, need3dFix: s, isWebView: i } } function pU() { return Ch || (Ch = fU()), Ch } function hU(e) { let { swiper: t, on: n, emit: r } = e; const i = Dn(); let o = null, s = null; const a = () => { !t || t.destroyed || !t.initialized || (r("beforeResize"), r("resize")) }, l = () => { !t || t.destroyed || !t.initialized || (o = new ResizeObserver(d => { s = i.requestAnimationFrame(() => { const { width: f, height: p } = t; let m = f, v = p; d.forEach(x => { let { contentBoxSize: g, contentRect: h, target: y } = x; y && y !== t.el || (m = h ? h.width : (g[0] || g).inlineSize, v = h ? h.height : (g[0] || g).blockSize) }), (m !== f || v !== p) && a() }) }), o.observe(t.el)) }, u = () => { s && i.cancelAnimationFrame(s), o && o.unobserve && t.el && (o.unobserve(t.el), o = null) }, c = () => { !t || t.destroyed || !t.initialized || r("orientationchange") }; n("init", () => { if (t.params.resizeObserver && typeof i.ResizeObserver < "u") { l(); return } i.addEventListener("resize", a), i.addEventListener("orientationchange", c) }), n("destroy", () => { u(), i.removeEventListener("resize", a), i.removeEventListener("orientationchange", c) }) } function mU(e) { let { swiper: t, extendParams: n, on: r, emit: i } = e; const o = [], s = Dn(), a = function (c, d) { d === void 0 && (d = {}); const f = s.MutationObserver || s.WebkitMutationObserver, p = new f(m => { if (t.__preventObserver__) return; if (m.length === 1) { i("observerUpdate", m[0]); return } const v = function () { i("observerUpdate", m[0]) }; s.requestAnimationFrame ? s.requestAnimationFrame(v) : s.setTimeout(v, 0) }); p.observe(c, { attributes: typeof d.attributes > "u" ? !0 : d.attributes, childList: t.isElement || (typeof d.childList > "u" ? !0 : d).childList, characterData: typeof d.characterData > "u" ? !0 : d.characterData }), o.push(p) }, l = () => { if (t.params.observer) { if (t.params.observeParents) { const c = PM(t.hostEl); for (let d = 0; d < c.length; d += 1)a(c[d]) } a(t.hostEl, { childList: t.params.observeSlideChildren }), a(t.wrapperEl, { attributes: !1 }) } }, u = () => { o.forEach(c => { c.disconnect() }), o.splice(0, o.length) }; n({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), r("init", l), r("destroy", u) } var gU = { on(e, t, n) { const r = this; if (!r.eventsListeners || r.destroyed || typeof t != "function") return r; const i = n ? "unshift" : "push"; return e.split(" ").forEach(o => { r.eventsListeners[o] || (r.eventsListeners[o] = []), r.eventsListeners[o][i](t) }), r }, once(e, t, n) { const r = this; if (!r.eventsListeners || r.destroyed || typeof t != "function") return r; function i() { r.off(e, i), i.__emitterProxy && delete i.__emitterProxy; for (var o = arguments.length, s = new Array(o), a = 0; a < o; a++)s[a] = arguments[a]; t.apply(r, s) } return i.__emitterProxy = t, r.on(e, i, n) }, onAny(e, t) { const n = this; if (!n.eventsListeners || n.destroyed || typeof e != "function") return n; const r = t ? "unshift" : "push"; return n.eventsAnyListeners.indexOf(e) < 0 && n.eventsAnyListeners[r](e), n }, offAny(e) { const t = this; if (!t.eventsListeners || t.destroyed || !t.eventsAnyListeners) return t; const n = t.eventsAnyListeners.indexOf(e); return n >= 0 && t.eventsAnyListeners.splice(n, 1), t }, off(e, t) { const n = this; return !n.eventsListeners || n.destroyed || !n.eventsListeners || e.split(" ").forEach(r => { typeof t > "u" ? n.eventsListeners[r] = [] : n.eventsListeners[r] && n.eventsListeners[r].forEach((i, o) => { (i === t || i.__emitterProxy && i.__emitterProxy === t) && n.eventsListeners[r].splice(o, 1) }) }), n }, emit() { const e = this; if (!e.eventsListeners || e.destroyed || !e.eventsListeners) return e; let t, n, r; for (var i = arguments.length, o = new Array(i), s = 0; s < i; s++)o[s] = arguments[s]; return typeof o[0] == "string" || Array.isArray(o[0]) ? (t = o[0], n = o.slice(1, o.length), r = e) : (t = o[0].events, n = o[0].data, r = o[0].context || e), n.unshift(r), (Array.isArray(t) ? t : t.split(" ")).forEach(l => { e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach(u => { u.apply(r, [l, ...n]) }), e.eventsListeners && e.eventsListeners[l] && e.eventsListeners[l].forEach(u => { u.apply(r, n) }) }), e } }; function vU() { const e = this; let t, n; const r = e.el; typeof e.params.width < "u" && e.params.width !== null ? t = e.params.width : t = r.clientWidth, typeof e.params.height < "u" && e.params.height !== null ? n = e.params.height : n = r.clientHeight, !(t === 0 && e.isHorizontal() || n === 0 && e.isVertical()) && (t = t - parseInt(ji(r, "padding-left") || 0, 10) - parseInt(ji(r, "padding-right") || 0, 10), n = n - parseInt(ji(r, "padding-top") || 0, 10) - parseInt(ji(r, "padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(n) && (n = 0), Object.assign(e, { width: t, height: n, size: e.isHorizontal() ? t : n })) } function yU() { const e = this; function t(R, A) { return parseFloat(R.getPropertyValue(e.getDirectionLabel(A)) || 0) } const n = e.params, { wrapperEl: r, slidesEl: i, size: o, rtlTranslate: s, wrongRTL: a } = e, l = e.virtual && n.virtual.enabled, u = l ? e.virtual.slides.length : e.slides.length, c = $r(i, `.${e.params.slideClass}, swiper-slide`), d = l ? e.virtual.slides.length : c.length; let f = []; const p = [], m = []; let v = n.slidesOffsetBefore; typeof v == "function" && (v = n.slidesOffsetBefore.call(e)); let x = n.slidesOffsetAfter; typeof x == "function" && (x = n.slidesOffsetAfter.call(e)); const g = e.snapGrid.length, h = e.slidesGrid.length; let y = n.spaceBetween, E = -v, P = 0, $ = 0; if (typeof o > "u") return; typeof y == "string" && y.indexOf("%") >= 0 ? y = parseFloat(y.replace("%", "")) / 100 * o : typeof y == "string" && (y = parseFloat(y)), e.virtualSize = -y, c.forEach(R => { s ? R.style.marginLeft = "" : R.style.marginRight = "", R.style.marginBottom = "", R.style.marginTop = "" }), n.centeredSlides && n.cssMode && (Lc(r, "--swiper-centered-offset-before", ""), Lc(r, "--swiper-centered-offset-after", "")); const L = n.grid && n.grid.rows > 1 && e.grid; L ? e.grid.initSlides(c) : e.grid && e.grid.unsetSlides(); let b; const M = n.slidesPerView === "auto" && n.breakpoints && Object.keys(n.breakpoints).filter(R => typeof n.breakpoints[R].slidesPerView < "u").length > 0; for (let R = 0; R < d; R += 1) { b = 0; let A; if (c[R] && (A = c[R]), L && e.grid.updateSlide(R, A, c), !(c[R] && ji(A, "display") === "none")) { if (n.slidesPerView === "auto") { M && (c[R].style[e.getDirectionLabel("width")] = ""); const _ = getComputedStyle(A), C = A.style.transform, k = A.style.webkitTransform; if (C && (A.style.transform = "none"), k && (A.style.webkitTransform = "none"), n.roundLengths) b = e.isHorizontal() ? Ug(A, "width") : Ug(A, "height"); else { const O = t(_, "width"), U = t(_, "padding-left"), z = t(_, "padding-right"), D = t(_, "margin-left"), V = t(_, "margin-right"), H = _.getPropertyValue("box-sizing"); if (H && H === "border-box") b = O + D + V; else { const { clientWidth: T, offsetWidth: N } = A; b = O + U + z + D + V + (N - T) } } C && (A.style.transform = C), k && (A.style.webkitTransform = k), n.roundLengths && (b = Math.floor(b)) } else b = (o - (n.slidesPerView - 1) * y) / n.slidesPerView, n.roundLengths && (b = Math.floor(b)), c[R] && (c[R].style[e.getDirectionLabel("width")] = `${b}px`); c[R] && (c[R].swiperSlideSize = b), m.push(b), n.centeredSlides ? (E = E + b / 2 + P / 2 + y, P === 0 && R !== 0 && (E = E - o / 2 - y), R === 0 && (E = E - o / 2 - y), Math.abs(E) < 1 / 1e3 && (E = 0), n.roundLengths && (E = Math.floor(E)), $ % n.slidesPerGroup === 0 && f.push(E), p.push(E)) : (n.roundLengths && (E = Math.floor(E)), ($ - Math.min(e.params.slidesPerGroupSkip, $)) % e.params.slidesPerGroup === 0 && f.push(E), p.push(E), E = E + b + y), e.virtualSize += b + y, P = b, $ += 1 } } if (e.virtualSize = Math.max(e.virtualSize, o) + x, s && a && (n.effect === "slide" || n.effect === "coverflow") && (r.style.width = `${e.virtualSize + y}px`), n.setWrapperSize && (r.style[e.getDirectionLabel("width")] = `${e.virtualSize + y}px`), L && e.grid.updateWrapperSize(b, f), !n.centeredSlides) { const R = []; for (let A = 0; A < f.length; A += 1) { let _ = f[A]; n.roundLengths && (_ = Math.floor(_)), f[A] <= e.virtualSize - o && R.push(_) } f = R, Math.floor(e.virtualSize - o) - Math.floor(f[f.length - 1]) > 1 && f.push(e.virtualSize - o) } if (l && n.loop) { const R = m[0] + y; if (n.slidesPerGroup > 1) { const A = Math.ceil((e.virtual.slidesBefore + e.virtual.slidesAfter) / n.slidesPerGroup), _ = R * n.slidesPerGroup; for (let C = 0; C < A; C += 1)f.push(f[f.length - 1] + _) } for (let A = 0; A < e.virtual.slidesBefore + e.virtual.slidesAfter; A += 1)n.slidesPerGroup === 1 && f.push(f[f.length - 1] + R), p.push(p[p.length - 1] + R), e.virtualSize += R } if (f.length === 0 && (f = [0]), y !== 0) { const R = e.isHorizontal() && s ? "marginLeft" : e.getDirectionLabel("marginRight"); c.filter((A, _) => !n.cssMode || n.loop ? !0 : _ !== c.length - 1).forEach(A => { A.style[R] = `${y}px` }) } if (n.centeredSlides && n.centeredSlidesBounds) { let R = 0; m.forEach(_ => { R += _ + (y || 0) }), R -= y; const A = R > o ? R - o : 0; f = f.map(_ => _ <= 0 ? -v : _ > A ? A + x : _) } if (n.centerInsufficientSlides) { let R = 0; m.forEach(_ => { R += _ + (y || 0) }), R -= y; const A = (n.slidesOffsetBefore || 0) + (n.slidesOffsetAfter || 0); if (R + A < o) { const _ = (o - R - A) / 2; f.forEach((C, k) => { f[k] = C - _ }), p.forEach((C, k) => { p[k] = C + _ }) } } if (Object.assign(e, { slides: c, snapGrid: f, slidesGrid: p, slidesSizesGrid: m }), n.centeredSlides && n.cssMode && !n.centeredSlidesBounds) { Lc(r, "--swiper-centered-offset-before", `${-f[0]}px`), Lc(r, "--swiper-centered-offset-after", `${e.size / 2 - m[m.length - 1] / 2}px`); const R = -e.snapGrid[0], A = -e.slidesGrid[0]; e.snapGrid = e.snapGrid.map(_ => _ + R), e.slidesGrid = e.slidesGrid.map(_ => _ + A) } if (d !== u && e.emit("slidesLengthChange"), f.length !== g && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), p.length !== h && e.emit("slidesGridLengthChange"), n.watchSlidesProgress && e.updateSlidesOffset(), e.emit("slidesUpdated"), !l && !n.cssMode && (n.effect === "slide" || n.effect === "fade")) { const R = `${n.containerModifierClass}backface-hidden`, A = e.el.classList.contains(R); d <= n.maxBackfaceHiddenSlides ? A || e.el.classList.add(R) : A && e.el.classList.remove(R) } } function bU(e) { const t = this, n = [], r = t.virtual && t.params.virtual.enabled; let i = 0, o; typeof e == "number" ? t.setTransition(e) : e === !0 && t.setTransition(t.params.speed); const s = a => r ? t.slides[t.getSlideIndexByData(a)] : t.slides[a]; if (t.params.slidesPerView !== "auto" && t.params.slidesPerView > 1) if (t.params.centeredSlides) (t.visibleSlides || []).forEach(a => { n.push(a) }); else for (o = 0; o < Math.ceil(t.params.slidesPerView); o += 1) { const a = t.activeIndex + o; if (a > t.slides.length && !r) break; n.push(s(a)) } else n.push(s(t.activeIndex)); for (o = 0; o < n.length; o += 1)if (typeof n[o] < "u") { const a = n[o].offsetHeight; i = a > i ? a : i } (i || i === 0) && (t.wrapperEl.style.height = `${i}px`) } function wU() { const e = this, t = e.slides, n = e.isElement ? e.isHorizontal() ? e.wrapperEl.offsetLeft : e.wrapperEl.offsetTop : 0; for (let r = 0; r < t.length; r += 1)t[r].swiperSlideOffset = (e.isHorizontal() ? t[r].offsetLeft : t[r].offsetTop) - n - e.cssOverflowAdjustment() } const vS = (e, t, n) => { t && !e.classList.contains(n) ? e.classList.add(n) : !t && e.classList.contains(n) && e.classList.remove(n) }; function xU(e) { e === void 0 && (e = this && this.translate || 0); const t = this, n = t.params, { slides: r, rtlTranslate: i, snapGrid: o } = t; if (r.length === 0) return; typeof r[0].swiperSlideOffset > "u" && t.updateSlidesOffset(); let s = -e; i && (s = e), t.visibleSlidesIndexes = [], t.visibleSlides = []; let a = n.spaceBetween; typeof a == "string" && a.indexOf("%") >= 0 ? a = parseFloat(a.replace("%", "")) / 100 * t.size : typeof a == "string" && (a = parseFloat(a)); for (let l = 0; l < r.length; l += 1) { const u = r[l]; let c = u.swiperSlideOffset; n.cssMode && n.centeredSlides && (c -= r[0].swiperSlideOffset); const d = (s + (n.centeredSlides ? t.minTranslate() : 0) - c) / (u.swiperSlideSize + a), f = (s - o[0] + (n.centeredSlides ? t.minTranslate() : 0) - c) / (u.swiperSlideSize + a), p = -(s - c), m = p + t.slidesSizesGrid[l], v = p >= 0 && p <= t.size - t.slidesSizesGrid[l], x = p >= 0 && p < t.size - 1 || m > 1 && m <= t.size || p <= 0 && m >= t.size; x && (t.visibleSlides.push(u), t.visibleSlidesIndexes.push(l)), vS(u, x, n.slideVisibleClass), vS(u, v, n.slideFullyVisibleClass), u.progress = i ? -d : d, u.originalProgress = i ? -f : f } } function SU(e) { const t = this; if (typeof e > "u") { const c = t.rtlTranslate ? -1 : 1; e = t && t.translate && t.translate * c || 0 } const n = t.params, r = t.maxTranslate() - t.minTranslate(); let { progress: i, isBeginning: o, isEnd: s, progressLoop: a } = t; const l = o, u = s; if (r === 0) i = 0, o = !0, s = !0; else { i = (e - t.minTranslate()) / r; const c = Math.abs(e - t.minTranslate()) < 1, d = Math.abs(e - t.maxTranslate()) < 1; o = c || i <= 0, s = d || i >= 1, c && (i = 0), d && (i = 1) } if (n.loop) { const c = t.getSlideIndexByData(0), d = t.getSlideIndexByData(t.slides.length - 1), f = t.slidesGrid[c], p = t.slidesGrid[d], m = t.slidesGrid[t.slidesGrid.length - 1], v = Math.abs(e); v >= f ? a = (v - f) / m : a = (v + m - p) / m, a > 1 && (a -= 1) } Object.assign(t, { progress: i, progressLoop: a, isBeginning: o, isEnd: s }), (n.watchSlidesProgress || n.centeredSlides && n.autoHeight) && t.updateSlidesProgress(e), o && !l && t.emit("reachBeginning toEdge"), s && !u && t.emit("reachEnd toEdge"), (l && !o || u && !s) && t.emit("fromEdge"), t.emit("progress", i) } const Ph = (e, t, n) => { t && !e.classList.contains(n) ? e.classList.add(n) : !t && e.classList.contains(n) && e.classList.remove(n) }; function EU() { const e = this, { slides: t, params: n, slidesEl: r, activeIndex: i } = e, o = e.virtual && n.virtual.enabled, s = e.grid && n.grid && n.grid.rows > 1, a = d => $r(r, `.${n.slideClass}${d}, swiper-slide${d}`)[0]; let l, u, c; if (o) if (n.loop) { let d = i - e.virtual.slidesBefore; d < 0 && (d = e.virtual.slides.length + d), d >= e.virtual.slides.length && (d -= e.virtual.slides.length), l = a(`[data-swiper-slide-index="${d}"]`) } else l = a(`[data-swiper-slide-index="${i}"]`); else s ? (l = t.filter(d => d.column === i)[0], c = t.filter(d => d.column === i + 1)[0], u = t.filter(d => d.column === i - 1)[0]) : l = t[i]; l && (s || (c = uU(l, `.${n.slideClass}, swiper-slide`)[0], n.loop && !c && (c = t[0]), u = lU(l, `.${n.slideClass}, swiper-slide`)[0], n.loop && !u === 0 && (u = t[t.length - 1]))), t.forEach(d => { Ph(d, d === l, n.slideActiveClass), Ph(d, d === c, n.slideNextClass), Ph(d, d === u, n.slidePrevClass) }), e.emitSlidesClasses() } const rd = (e, t) => { if (!e || e.destroyed || !e.params) return; const n = () => e.isElement ? "swiper-slide" : `.${e.params.slideClass}`, r = t.closest(n()); if (r) { let i = r.querySelector(`.${e.params.lazyPreloaderClass}`); !i && e.isElement && (r.shadowRoot ? i = r.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`) : requestAnimationFrame(() => { r.shadowRoot && (i = r.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`), i && i.remove()) })), i && i.remove() } }, $h = (e, t) => { if (!e.slides[t]) return; const n = e.slides[t].querySelector('[loading="lazy"]'); n && n.removeAttribute("loading") }, Hg = e => { if (!e || e.destroyed || !e.params) return; let t = e.params.lazyPreloadPrevNext; const n = e.slides.length; if (!n || !t || t < 0) return; t = Math.min(t, n); const r = e.params.slidesPerView === "auto" ? e.slidesPerViewDynamic() : Math.ceil(e.params.slidesPerView), i = e.activeIndex; if (e.params.grid && e.params.grid.rows > 1) { const s = i, a = [s - t]; a.push(...Array.from({ length: t }).map((l, u) => s + r + u)), e.slides.forEach((l, u) => { a.includes(l.column) && $h(e, u) }); return } const o = i + r - 1; if (e.params.rewind || e.params.loop) for (let s = i - t; s <= o + t; s += 1) { const a = (s % n + n) % n; (a < i || a > o) && $h(e, a) } else for (let s = Math.max(i - t, 0); s <= Math.min(o + t, n - 1); s += 1)s !== i && (s > o || s < i) && $h(e, s) }; function TU(e) { const { slidesGrid: t, params: n } = e, r = e.rtlTranslate ? e.translate : -e.translate; let i; for (let o = 0; o < t.length; o += 1)typeof t[o + 1] < "u" ? r >= t[o] && r < t[o + 1] - (t[o + 1] - t[o]) / 2 ? i = o : r >= t[o] && r < t[o + 1] && (i = o + 1) : r >= t[o] && (i = o); return n.normalizeSlideIndex && (i < 0 || typeof i > "u") && (i = 0), i } function CU(e) { const t = this, n = t.rtlTranslate ? t.translate : -t.translate, { snapGrid: r, params: i, activeIndex: o, realIndex: s, snapIndex: a } = t; let l = e, u; const c = p => { let m = p - t.virtual.slidesBefore; return m < 0 && (m = t.virtual.slides.length + m), m >= t.virtual.slides.length && (m -= t.virtual.slides.length), m }; if (typeof l > "u" && (l = TU(t)), r.indexOf(n) >= 0) u = r.indexOf(n); else { const p = Math.min(i.slidesPerGroupSkip, l); u = p + Math.floor((l - p) / i.slidesPerGroup) } if (u >= r.length && (u = r.length - 1), l === o && !t.params.loop) { u !== a && (t.snapIndex = u, t.emit("snapIndexChange")); return } if (l === o && t.params.loop && t.virtual && t.params.virtual.enabled) { t.realIndex = c(l); return } const d = t.grid && i.grid && i.grid.rows > 1; let f; if (t.virtual && i.virtual.enabled && i.loop) f = c(l); else if (d) { const p = t.slides.filter(v => v.column === l)[0]; let m = parseInt(p.getAttribute("data-swiper-slide-index"), 10); Number.isNaN(m) && (m = Math.max(t.slides.indexOf(p), 0)), f = Math.floor(m / i.grid.rows) } else if (t.slides[l]) { const p = t.slides[l].getAttribute("data-swiper-slide-index"); p ? f = parseInt(p, 10) : f = l } else f = l; Object.assign(t, { previousSnapIndex: a, snapIndex: u, previousRealIndex: s, realIndex: f, previousIndex: o, activeIndex: l }), t.initialized && Hg(t), t.emit("activeIndexChange"), t.emit("snapIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && (s !== f && t.emit("realIndexChange"), t.emit("slideChange")) } function PU(e, t) { const n = this, r = n.params; let i = e.closest(`.${r.slideClass}, swiper-slide`); !i && n.isElement && t && t.length > 1 && t.includes(e) && [...t.slice(t.indexOf(e) + 1, t.length)].forEach(a => { !i && a.matches && a.matches(`.${r.slideClass}, swiper-slide`) && (i = a) }); let o = !1, s; if (i) { for (let a = 0; a < n.slides.length; a += 1)if (n.slides[a] === i) { o = !0, s = a; break } } if (i && o) n.clickedSlide = i, n.virtual && n.params.virtual.enabled ? n.clickedIndex = parseInt(i.getAttribute("data-swiper-slide-index"), 10) : n.clickedIndex = s; else { n.clickedSlide = void 0, n.clickedIndex = void 0; return } r.slideToClickedSlide && n.clickedIndex !== void 0 && n.clickedIndex !== n.activeIndex && n.slideToClickedSlide() } var $U = { updateSize: vU, updateSlides: yU, updateAutoHeight: bU, updateSlidesOffset: wU, updateSlidesProgress: xU, updateProgress: SU, updateSlidesClasses: EU, updateActiveIndex: CU, updateClickedSlide: PU }; function AU(e) { e === void 0 && (e = this.isHorizontal() ? "x" : "y"); const t = this, { params: n, rtlTranslate: r, translate: i, wrapperEl: o } = t; if (n.virtualTranslate) return r ? -i : i; if (n.cssMode) return i; let s = oU(o, e); return s += t.cssOverflowAdjustment(), r && (s = -s), s || 0 } function MU(e, t) { const n = this, { rtlTranslate: r, params: i, wrapperEl: o, progress: s } = n; let a = 0, l = 0; const u = 0; n.isHorizontal() ? a = r ? -e : e : l = e, i.roundLengths && (a = Math.floor(a), l = Math.floor(l)), n.previousTranslate = n.translate, n.translate = n.isHorizontal() ? a : l, i.cssMode ? o[n.isHorizontal() ? "scrollLeft" : "scrollTop"] = n.isHorizontal() ? -a : -l : i.virtualTranslate || (n.isHorizontal() ? a -= n.cssOverflowAdjustment() : l -= n.cssOverflowAdjustment(), o.style.transform = `translate3d(${a}px, ${l}px, ${u}px)`); let c; const d = n.maxTranslate() - n.minTranslate(); d === 0 ? c = 0 : c = (e - n.minTranslate()) / d, c !== s && n.updateProgress(e), n.emit("setTranslate", n.translate, t) } function kU() { return -this.snapGrid[0] } function _U() { return -this.snapGrid[this.snapGrid.length - 1] } function RU(e, t, n, r, i) { e === void 0 && (e = 0), t === void 0 && (t = this.params.speed), n === void 0 && (n = !0), r === void 0 && (r = !0); const o = this, { params: s, wrapperEl: a } = o; if (o.animating && s.preventInteractionOnTransition) return !1; const l = o.minTranslate(), u = o.maxTranslate(); let c; if (r && e > l ? c = l : r && e < u ? c = u : c = e, o.updateProgress(c), s.cssMode) { const d = o.isHorizontal(); if (t === 0) a[d ? "scrollLeft" : "scrollTop"] = -c; else { if (!o.support.smoothScroll) return CM({ swiper: o, targetPosition: -c, side: d ? "left" : "top" }), !0; a.scrollTo({ [d ? "left" : "top"]: -c, behavior: "smooth" }) } return !0 } return t === 0 ? (o.setTransition(0), o.setTranslate(c), n && (o.emit("beforeTransitionStart", t, i), o.emit("transitionEnd"))) : (o.setTransition(t), o.setTranslate(c), n && (o.emit("beforeTransitionStart", t, i), o.emit("transitionStart")), o.animating || (o.animating = !0, o.onTranslateToWrapperTransitionEnd || (o.onTranslateToWrapperTransitionEnd = function (f) { !o || o.destroyed || f.target === this && (o.wrapperEl.removeEventListener("transitionend", o.onTranslateToWrapperTransitionEnd), o.onTranslateToWrapperTransitionEnd = null, delete o.onTranslateToWrapperTransitionEnd, o.animating = !1, n && o.emit("transitionEnd")) }), o.wrapperEl.addEventListener("transitionend", o.onTranslateToWrapperTransitionEnd))), !0 } var LU = { getTranslate: AU, setTranslate: MU, minTranslate: kU, maxTranslate: _U, translateTo: RU }; function NU(e, t) { const n = this; n.params.cssMode || (n.wrapperEl.style.transitionDuration = `${e}ms`, n.wrapperEl.style.transitionDelay = e === 0 ? "0ms" : ""), n.emit("setTransition", e, t) } function MM(e) { let { swiper: t, runCallbacks: n, direction: r, step: i } = e; const { activeIndex: o, previousIndex: s } = t; let a = r; if (a || (o > s ? a = "next" : o < s ? a = "prev" : a = "reset"), t.emit(`transition${i}`), n && o !== s) { if (a === "reset") { t.emit(`slideResetTransition${i}`); return } t.emit(`slideChangeTransition${i}`), a === "next" ? t.emit(`slideNextTransition${i}`) : t.emit(`slidePrevTransition${i}`) } } function OU(e, t) { e === void 0 && (e = !0); const n = this, { params: r } = n; r.cssMode || (r.autoHeight && n.updateAutoHeight(), MM({ swiper: n, runCallbacks: e, direction: t, step: "Start" })) } function jU(e, t) { e === void 0 && (e = !0); const n = this, { params: r } = n; n.animating = !1, !r.cssMode && (n.setTransition(0), MM({ swiper: n, runCallbacks: e, direction: t, step: "End" })) } var IU = { setTransition: NU, transitionStart: OU, transitionEnd: jU }; function DU(e, t, n, r, i) { e === void 0 && (e = 0), n === void 0 && (n = !0), typeof e == "string" && (e = parseInt(e, 10)); const o = this; let s = e; s < 0 && (s = 0); const { params: a, snapGrid: l, slidesGrid: u, previousIndex: c, activeIndex: d, rtlTranslate: f, wrapperEl: p, enabled: m } = o; if (!m && !r && !i || o.destroyed || o.animating && a.preventInteractionOnTransition) return !1; typeof t > "u" && (t = o.params.speed); const v = Math.min(o.params.slidesPerGroupSkip, s); let x = v + Math.floor((s - v) / o.params.slidesPerGroup); x >= l.length && (x = l.length - 1); const g = -l[x]; if (a.normalizeSlideIndex) for (let P = 0; P < u.length; P += 1) { const $ = -Math.floor(g * 100), L = Math.floor(u[P] * 100), b = Math.floor(u[P + 1] * 100); typeof u[P + 1] < "u" ? $ >= L && $ < b - (b - L) / 2 ? s = P : $ >= L && $ < b && (s = P + 1) : $ >= L && (s = P) } if (o.initialized && s !== d && (!o.allowSlideNext && (f ? g > o.translate && g > o.minTranslate() : g < o.translate && g < o.minTranslate()) || !o.allowSlidePrev && g > o.translate && g > o.maxTranslate() && (d || 0) !== s)) return !1; s !== (c || 0) && n && o.emit("beforeSlideChangeStart"), o.updateProgress(g); let h; s > d ? h = "next" : s < d ? h = "prev" : h = "reset"; const y = o.virtual && o.params.virtual.enabled; if (!(y && i) && (f && -g === o.translate || !f && g === o.translate)) return o.updateActiveIndex(s), a.autoHeight && o.updateAutoHeight(), o.updateSlidesClasses(), a.effect !== "slide" && o.setTranslate(g), h !== "reset" && (o.transitionStart(n, h), o.transitionEnd(n, h)), !1; if (a.cssMode) { const P = o.isHorizontal(), $ = f ? g : -g; if (t === 0) y && (o.wrapperEl.style.scrollSnapType = "none", o._immediateVirtual = !0), y && !o._cssModeVirtualInitialSet && o.params.initialSlide > 0 ? (o._cssModeVirtualInitialSet = !0, requestAnimationFrame(() => { p[P ? "scrollLeft" : "scrollTop"] = $ })) : p[P ? "scrollLeft" : "scrollTop"] = $, y && requestAnimationFrame(() => { o.wrapperEl.style.scrollSnapType = "", o._immediateVirtual = !1 }); else { if (!o.support.smoothScroll) return CM({ swiper: o, targetPosition: $, side: P ? "left" : "top" }), !0; p.scrollTo({ [P ? "left" : "top"]: $, behavior: "smooth" }) } return !0 } return o.setTransition(t), o.setTranslate(g), o.updateActiveIndex(s), o.updateSlidesClasses(), o.emit("beforeTransitionStart", t, r), o.transitionStart(n, h), t === 0 ? o.transitionEnd(n, h) : o.animating || (o.animating = !0, o.onSlideToWrapperTransitionEnd || (o.onSlideToWrapperTransitionEnd = function ($) { !o || o.destroyed || $.target === this && (o.wrapperEl.removeEventListener("transitionend", o.onSlideToWrapperTransitionEnd), o.onSlideToWrapperTransitionEnd = null, delete o.onSlideToWrapperTransitionEnd, o.transitionEnd(n, h)) }), o.wrapperEl.addEventListener("transitionend", o.onSlideToWrapperTransitionEnd)), !0 } function FU(e, t, n, r) { e === void 0 && (e = 0), n === void 0 && (n = !0), typeof e == "string" && (e = parseInt(e, 10)); const i = this; if (i.destroyed) return; typeof t > "u" && (t = i.params.speed); const o = i.grid && i.params.grid && i.params.grid.rows > 1; let s = e; if (i.params.loop) if (i.virtual && i.params.virtual.enabled) s = s + i.virtual.slidesBefore; else { let a; if (o) { const f = s * i.params.grid.rows; a = i.slides.filter(p => p.getAttribute("data-swiper-slide-index") * 1 === f)[0].column } else a = i.getSlideIndexByData(s); const l = o ? Math.ceil(i.slides.length / i.params.grid.rows) : i.slides.length, { centeredSlides: u } = i.params; let c = i.params.slidesPerView; c === "auto" ? c = i.slidesPerViewDynamic() : (c = Math.ceil(parseFloat(i.params.slidesPerView, 10)), u && c % 2 === 0 && (c = c + 1)); let d = l - a < c; if (u && (d = d || a < Math.ceil(c / 2)), r && u && i.params.slidesPerView !== "auto" && !o && (d = !1), d) { const f = u ? a < i.activeIndex ? "prev" : "next" : a - i.activeIndex - 1 < i.params.slidesPerView ? "next" : "prev"; i.loopFix({ direction: f, slideTo: !0, activeSlideIndex: f === "next" ? a + 1 : a - l + 1, slideRealIndex: f === "next" ? i.realIndex : void 0 }) } if (o) { const f = s * i.params.grid.rows; s = i.slides.filter(p => p.getAttribute("data-swiper-slide-index") * 1 === f)[0].column } else s = i.getSlideIndexByData(s) } return requestAnimationFrame(() => { i.slideTo(s, t, n, r) }), i } function zU(e, t, n) { t === void 0 && (t = !0); const r = this, { enabled: i, params: o, animating: s } = r; if (!i || r.destroyed) return r; typeof e > "u" && (e = r.params.speed); let a = o.slidesPerGroup; o.slidesPerView === "auto" && o.slidesPerGroup === 1 && o.slidesPerGroupAuto && (a = Math.max(r.slidesPerViewDynamic("current", !0), 1)); const l = r.activeIndex < o.slidesPerGroupSkip ? 1 : a, u = r.virtual && o.virtual.enabled; if (o.loop) { if (s && !u && o.loopPreventsSliding) return !1; if (r.loopFix({ direction: "next" }), r._clientLeft = r.wrapperEl.clientLeft, r.activeIndex === r.slides.length - 1 && o.cssMode) return requestAnimationFrame(() => { r.slideTo(r.activeIndex + l, e, t, n) }), !0 } return o.rewind && r.isEnd ? r.slideTo(0, e, t, n) : r.slideTo(r.activeIndex + l, e, t, n) } function VU(e, t, n) { t === void 0 && (t = !0); const r = this, { params: i, snapGrid: o, slidesGrid: s, rtlTranslate: a, enabled: l, animating: u } = r; if (!l || r.destroyed) return r; typeof e > "u" && (e = r.params.speed); const c = r.virtual && i.virtual.enabled; if (i.loop) { if (u && !c && i.loopPreventsSliding) return !1; r.loopFix({ direction: "prev" }), r._clientLeft = r.wrapperEl.clientLeft } const d = a ? r.translate : -r.translate; function f(g) { return g < 0 ? -Math.floor(Math.abs(g)) : Math.floor(g) } const p = f(d), m = o.map(g => f(g)); let v = o[m.indexOf(p) - 1]; if (typeof v > "u" && i.cssMode) { let g; o.forEach((h, y) => { p >= h && (g = y) }), typeof g < "u" && (v = o[g > 0 ? g - 1 : g]) } let x = 0; if (typeof v < "u" && (x = s.indexOf(v), x < 0 && (x = r.activeIndex - 1), i.slidesPerView === "auto" && i.slidesPerGroup === 1 && i.slidesPerGroupAuto && (x = x - r.slidesPerViewDynamic("previous", !0) + 1, x = Math.max(x, 0))), i.rewind && r.isBeginning) { const g = r.params.virtual && r.params.virtual.enabled && r.virtual ? r.virtual.slides.length - 1 : r.slides.length - 1; return r.slideTo(g, e, t, n) } else if (i.loop && r.activeIndex === 0 && i.cssMode) return requestAnimationFrame(() => { r.slideTo(x, e, t, n) }), !0; return r.slideTo(x, e, t, n) } function BU(e, t, n) { t === void 0 && (t = !0); const r = this; if (!r.destroyed) return typeof e > "u" && (e = r.params.speed), r.slideTo(r.activeIndex, e, t, n) } function UU(e, t, n, r) { t === void 0 && (t = !0), r === void 0 && (r = .5); const i = this; if (i.destroyed) return; typeof e > "u" && (e = i.params.speed); let o = i.activeIndex; const s = Math.min(i.params.slidesPerGroupSkip, o), a = s + Math.floor((o - s) / i.params.slidesPerGroup), l = i.rtlTranslate ? i.translate : -i.translate; if (l >= i.snapGrid[a]) { const u = i.snapGrid[a], c = i.snapGrid[a + 1]; l - u > (c - u) * r && (o += i.params.slidesPerGroup) } else { const u = i.snapGrid[a - 1], c = i.snapGrid[a]; l - u <= (c - u) * r && (o -= i.params.slidesPerGroup) } return o = Math.max(o, 0), o = Math.min(o, i.slidesGrid.length - 1), i.slideTo(o, e, t, n) } function HU() { const e = this; if (e.destroyed) return; const { params: t, slidesEl: n } = e, r = t.slidesPerView === "auto" ? e.slidesPerViewDynamic() : t.slidesPerView; let i = e.clickedIndex, o; const s = e.isElement ? "swiper-slide" : `.${t.slideClass}`; if (t.loop) { if (e.animating) return; o = parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10), t.centeredSlides ? i < e.loopedSlides - r / 2 || i > e.slides.length - e.loopedSlides + r / 2 ? (e.loopFix(), i = e.getSlideIndex($r(n, `${s}[data-swiper-slide-index="${o}"]`)[0]), Bg(() => { e.slideTo(i) })) : e.slideTo(i) : i > e.slides.length - r ? (e.loopFix(), i = e.getSlideIndex($r(n, `${s}[data-swiper-slide-index="${o}"]`)[0]), Bg(() => { e.slideTo(i) })) : e.slideTo(i) } else e.slideTo(i) } var WU = { slideTo: DU, slideToLoop: FU, slideNext: zU, slidePrev: VU, slideReset: BU, slideToClosest: UU, slideToClickedSlide: HU }; function GU(e) { const t = this, { params: n, slidesEl: r } = t; if (!n.loop || t.virtual && t.params.virtual.enabled) return; const i = () => { $r(r, `.${n.slideClass}, swiper-slide`).forEach((d, f) => { d.setAttribute("data-swiper-slide-index", f) }) }, o = t.grid && n.grid && n.grid.rows > 1, s = n.slidesPerGroup * (o ? n.grid.rows : 1), a = t.slides.length % s !== 0, l = o && t.slides.length % n.grid.rows !== 0, u = c => { for (let d = 0; d < c; d += 1) { const f = t.isElement ? lf("swiper-slide", [n.slideBlankClass]) : lf("div", [n.slideClass, n.slideBlankClass]); t.slidesEl.append(f) } }; if (a) { if (n.loopAddBlankSlides) { const c = s - t.slides.length % s; u(c), t.recalcSlides(), t.updateSlides() } else af("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"); i() } else if (l) { if (n.loopAddBlankSlides) { const c = n.grid.rows - t.slides.length % n.grid.rows; u(c), t.recalcSlides(), t.updateSlides() } else af("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"); i() } else i(); t.loopFix({ slideRealIndex: e, direction: n.centeredSlides ? void 0 : "next" }) } function KU(e) { let { slideRealIndex: t, slideTo: n = !0, direction: r, setTranslate: i, activeSlideIndex: o, byController: s, byMousewheel: a } = e === void 0 ? {} : e; const l = this; if (!l.params.loop) return; l.emit("beforeLoopFix"); const { slides: u, allowSlidePrev: c, allowSlideNext: d, slidesEl: f, params: p } = l, { centeredSlides: m } = p; if (l.allowSlidePrev = !0, l.allowSlideNext = !0, l.virtual && p.virtual.enabled) { n && (!p.centeredSlides && l.snapIndex === 0 ? l.slideTo(l.virtual.slides.length, 0, !1, !0) : p.centeredSlides && l.snapIndex < p.slidesPerView ? l.slideTo(l.virtual.slides.length + l.snapIndex, 0, !1, !0) : l.snapIndex === l.snapGrid.length - 1 && l.slideTo(l.virtual.slidesBefore, 0, !1, !0)), l.allowSlidePrev = c, l.allowSlideNext = d, l.emit("loopFix"); return } let v = p.slidesPerView; v === "auto" ? v = l.slidesPerViewDynamic() : (v = Math.ceil(parseFloat(p.slidesPerView, 10)), m && v % 2 === 0 && (v = v + 1)); const x = p.slidesPerGroupAuto ? v : p.slidesPerGroup; let g = x; g % x !== 0 && (g += x - g % x), g += p.loopAdditionalSlides, l.loopedSlides = g; const h = l.grid && p.grid && p.grid.rows > 1; u.length < v + g ? af("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : h && p.grid.fill === "row" && af("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`"); const y = [], E = []; let P = l.activeIndex; typeof o > "u" ? o = l.getSlideIndex(u.filter(C => C.classList.contains(p.slideActiveClass))[0]) : P = o; const $ = r === "next" || !r, L = r === "prev" || !r; let b = 0, M = 0; const R = h ? Math.ceil(u.length / p.grid.rows) : u.length, _ = (h ? u[o].column : o) + (m && typeof i > "u" ? -v / 2 + .5 : 0); if (_ < g) { b = Math.max(g - _, x); for (let C = 0; C < g - _; C += 1) { const k = C - Math.floor(C / R) * R; if (h) { const O = R - k - 1; for (let U = u.length - 1; U >= 0; U -= 1)u[U].column === O && y.push(U) } else y.push(R - k - 1) } } else if (_ + v > R - g) { M = Math.max(_ - (R - g * 2), x); for (let C = 0; C < M; C += 1) { const k = C - Math.floor(C / R) * R; h ? u.forEach((O, U) => { O.column === k && E.push(U) }) : E.push(k) } } if (l.__preventObserver__ = !0, requestAnimationFrame(() => { l.__preventObserver__ = !1 }), L && y.forEach(C => { u[C].swiperLoopMoveDOM = !0, f.prepend(u[C]), u[C].swiperLoopMoveDOM = !1 }), $ && E.forEach(C => { u[C].swiperLoopMoveDOM = !0, f.append(u[C]), u[C].swiperLoopMoveDOM = !1 }), l.recalcSlides(), p.slidesPerView === "auto" ? l.updateSlides() : h && (y.length > 0 && L || E.length > 0 && $) && l.slides.forEach((C, k) => { l.grid.updateSlide(k, C, l.slides) }), p.watchSlidesProgress && l.updateSlidesOffset(), n) { if (y.length > 0 && L) { if (typeof t > "u") { const C = l.slidesGrid[P], O = l.slidesGrid[P + b] - C; a ? l.setTranslate(l.translate - O) : (l.slideTo(P + Math.ceil(b), 0, !1, !0), i && (l.touchEventsData.startTranslate = l.touchEventsData.startTranslate - O, l.touchEventsData.currentTranslate = l.touchEventsData.currentTranslate - O)) } else if (i) { const C = h ? y.length / p.grid.rows : y.length; l.slideTo(l.activeIndex + C, 0, !1, !0), l.touchEventsData.currentTranslate = l.translate } } else if (E.length > 0 && $) if (typeof t > "u") { const C = l.slidesGrid[P], O = l.slidesGrid[P - M] - C; a ? l.setTranslate(l.translate - O) : (l.slideTo(P - M, 0, !1, !0), i && (l.touchEventsData.startTranslate = l.touchEventsData.startTranslate - O, l.touchEventsData.currentTranslate = l.touchEventsData.currentTranslate - O)) } else { const C = h ? E.length / p.grid.rows : E.length; l.slideTo(l.activeIndex - C, 0, !1, !0) } } if (l.allowSlidePrev = c, l.allowSlideNext = d, l.controller && l.controller.control && !s) { const C = { slideRealIndex: t, direction: r, setTranslate: i, activeSlideIndex: o, byController: !0 }; Array.isArray(l.controller.control) ? l.controller.control.forEach(k => { !k.destroyed && k.params.loop && k.loopFix({ ...C, slideTo: k.params.slidesPerView === p.slidesPerView ? n : !1 }) }) : l.controller.control instanceof l.constructor && l.controller.control.params.loop && l.controller.control.loopFix({ ...C, slideTo: l.controller.control.params.slidesPerView === p.slidesPerView ? n : !1 }) } l.emit("loopFix") } function qU() { const e = this, { params: t, slidesEl: n } = e; if (!t.loop || e.virtual && e.params.virtual.enabled) return; e.recalcSlides(); const r = []; e.slides.forEach(i => { const o = typeof i.swiperSlideIndex > "u" ? i.getAttribute("data-swiper-slide-index") * 1 : i.swiperSlideIndex; r[o] = i }), e.slides.forEach(i => { i.removeAttribute("data-swiper-slide-index") }), r.forEach(i => { n.append(i) }), e.recalcSlides(), e.slideTo(e.realIndex, 0) } var YU = { loopCreate: GU, loopFix: KU, loopDestroy: qU }; function QU(e) { const t = this; if (!t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return; const n = t.params.touchEventsTarget === "container" ? t.el : t.wrapperEl; t.isElement && (t.__preventObserver__ = !0), n.style.cursor = "move", n.style.cursor = e ? "grabbing" : "grab", t.isElement && requestAnimationFrame(() => { t.__preventObserver__ = !1 }) } function XU() { const e = this; e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.isElement && (e.__preventObserver__ = !0), e[e.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "", e.isElement && requestAnimationFrame(() => { e.__preventObserver__ = !1 })) } var JU = { setGrabCursor: QU, unsetGrabCursor: XU }; function ZU(e, t) { t === void 0 && (t = this); function n(r) { if (!r || r === Sa() || r === Dn()) return null; r.assignedSlot && (r = r.assignedSlot); const i = r.closest(e); return !i && !r.getRootNode ? null : i || n(r.getRootNode().host) } return n(t) } function yS(e, t, n) { const r = Dn(), { params: i } = e, o = i.edgeSwipeDetection, s = i.edgeSwipeThreshold; return o && (n <= s || n >= r.innerWidth - s) ? o === "prevent" ? (t.preventDefault(), !0) : !1 : !0 } function eH(e) { const t = this, n = Sa(); let r = e; r.originalEvent && (r = r.originalEvent); const i = t.touchEventsData; if (r.type === "pointerdown") { if (i.pointerId !== null && i.pointerId !== r.pointerId) return; i.pointerId = r.pointerId } else r.type === "touchstart" && r.targetTouches.length === 1 && (i.touchId = r.targetTouches[0].identifier); if (r.type === "touchstart") { yS(t, r, r.targetTouches[0].pageX); return } const { params: o, touches: s, enabled: a } = t; if (!a || !o.simulateTouch && r.pointerType === "mouse" || t.animating && o.preventInteractionOnTransition) return; !t.animating && o.cssMode && o.loop && t.loopFix(); let l = r.target; if (o.touchEventsTarget === "wrapper" && !aU(l, t.wrapperEl) || "which" in r && r.which === 3 || "button" in r && r.button > 0 || i.isTouched && i.isMoved) return; const u = !!o.noSwipingClass && o.noSwipingClass !== "", c = r.composedPath ? r.composedPath() : r.path; u && r.target && r.target.shadowRoot && c && (l = c[0]); const d = o.noSwipingSelector ? o.noSwipingSelector : `.${o.noSwipingClass}`, f = !!(r.target && r.target.shadowRoot); if (o.noSwiping && (f ? ZU(d, l) : l.closest(d))) { t.allowClick = !0; return } if (o.swipeHandler && !l.closest(o.swipeHandler)) return; s.currentX = r.pageX, s.currentY = r.pageY; const p = s.currentX, m = s.currentY; if (!yS(t, r, p)) return; Object.assign(i, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), s.startX = p, s.startY = m, i.touchStartTime = sf(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, o.threshold > 0 && (i.allowThresholdMove = !1); let v = !0; l.matches(i.focusableElements) && (v = !1, l.nodeName === "SELECT" && (i.isTouched = !1)), n.activeElement && n.activeElement.matches(i.focusableElements) && n.activeElement !== l && n.activeElement.blur(); const x = v && t.allowTouchMove && o.touchStartPreventDefault; (o.touchStartForcePreventDefault || x) && !l.isContentEditable && r.preventDefault(), o.freeMode && o.freeMode.enabled && t.freeMode && t.animating && !o.cssMode && t.freeMode.onTouchStart(), t.emit("touchStart", r) } function tH(e) { const t = Sa(), n = this, r = n.touchEventsData, { params: i, touches: o, rtlTranslate: s, enabled: a } = n; if (!a || !i.simulateTouch && e.pointerType === "mouse") return; let l = e; if (l.originalEvent && (l = l.originalEvent), l.type === "pointermove" && (r.touchId !== null || l.pointerId !== r.pointerId)) return; let u; if (l.type === "touchmove") { if (u = [...l.changedTouches].filter($ => $.identifier === r.touchId)[0], !u || u.identifier !== r.touchId) return } else u = l; if (!r.isTouched) { r.startMoving && r.isScrolling && n.emit("touchMoveOpposite", l); return } const c = u.pageX, d = u.pageY; if (l.preventedByNestedSwiper) { o.startX = c, o.startY = d; return } if (!n.allowTouchMove) { l.target.matches(r.focusableElements) || (n.allowClick = !1), r.isTouched && (Object.assign(o, { startX: c, startY: d, currentX: c, currentY: d }), r.touchStartTime = sf()); return } if (i.touchReleaseOnEdges && !i.loop) { if (n.isVertical()) { if (d < o.startY && n.translate <= n.maxTranslate() || d > o.startY && n.translate >= n.minTranslate()) { r.isTouched = !1, r.isMoved = !1; return } } else if (c < o.startX && n.translate <= n.maxTranslate() || c > o.startX && n.translate >= n.minTranslate()) return } if (t.activeElement && l.target === t.activeElement && l.target.matches(r.focusableElements)) { r.isMoved = !0, n.allowClick = !1; return } r.allowTouchCallbacks && n.emit("touchMove", l), o.previousX = o.currentX, o.previousY = o.currentY, o.currentX = c, o.currentY = d; const f = o.currentX - o.startX, p = o.currentY - o.startY; if (n.params.threshold && Math.sqrt(f ** 2 + p ** 2) < n.params.threshold) return; if (typeof r.isScrolling > "u") { let $; n.isHorizontal() && o.currentY === o.startY || n.isVertical() && o.currentX === o.startX ? r.isScrolling = !1 : f * f + p * p >= 25 && ($ = Math.atan2(Math.abs(p), Math.abs(f)) * 180 / Math.PI, r.isScrolling = n.isHorizontal() ? $ > i.touchAngle : 90 - $ > i.touchAngle) } if (r.isScrolling && n.emit("touchMoveOpposite", l), typeof r.startMoving > "u" && (o.currentX !== o.startX || o.currentY !== o.startY) && (r.startMoving = !0), r.isScrolling || l.type === "touchmove" && r.preventTouchMoveFromPointerMove) { r.isTouched = !1; return } if (!r.startMoving) return; n.allowClick = !1, !i.cssMode && l.cancelable && l.preventDefault(), i.touchMoveStopPropagation && !i.nested && l.stopPropagation(); let m = n.isHorizontal() ? f : p, v = n.isHorizontal() ? o.currentX - o.previousX : o.currentY - o.previousY; i.oneWayMovement && (m = Math.abs(m) * (s ? 1 : -1), v = Math.abs(v) * (s ? 1 : -1)), o.diff = m, m *= i.touchRatio, s && (m = -m, v = -v); const x = n.touchesDirection; n.swipeDirection = m > 0 ? "prev" : "next", n.touchesDirection = v > 0 ? "prev" : "next"; const g = n.params.loop && !i.cssMode, h = n.touchesDirection === "next" && n.allowSlideNext || n.touchesDirection === "prev" && n.allowSlidePrev; if (!r.isMoved) { if (g && h && n.loopFix({ direction: n.swipeDirection }), r.startTranslate = n.getTranslate(), n.setTransition(0), n.animating) { const $ = new window.CustomEvent("transitionend", { bubbles: !0, cancelable: !0, detail: { bySwiperTouchMove: !0 } }); n.wrapperEl.dispatchEvent($) } r.allowMomentumBounce = !1, i.grabCursor && (n.allowSlideNext === !0 || n.allowSlidePrev === !0) && n.setGrabCursor(!0), n.emit("sliderFirstMove", l) } let y; if (new Date().getTime(), r.isMoved && r.allowThresholdMove && x !== n.touchesDirection && g && h && Math.abs(m) >= 1) { Object.assign(o, { startX: c, startY: d, currentX: c, currentY: d, startTranslate: r.currentTranslate }), r.loopSwapReset = !0, r.startTranslate = r.currentTranslate; return } n.emit("sliderMove", l), r.isMoved = !0, r.currentTranslate = m + r.startTranslate; let E = !0, P = i.resistanceRatio; if (i.touchReleaseOnEdges && (P = 0), m > 0 ? (g && h && !y && r.allowThresholdMove && r.currentTranslate > (i.centeredSlides ? n.minTranslate() - n.slidesSizesGrid[n.activeIndex + 1] - (i.slidesPerView !== "auto" && n.slides.length - i.slidesPerView >= 2 ? n.slidesSizesGrid[n.activeIndex + 1] + n.params.spaceBetween : 0) - n.params.spaceBetween : n.minTranslate()) && n.loopFix({ direction: "prev", setTranslate: !0, activeSlideIndex: 0 }), r.currentTranslate > n.minTranslate() && (E = !1, i.resistance && (r.currentTranslate = n.minTranslate() - 1 + (-n.minTranslate() + r.startTranslate + m) ** P))) : m < 0 && (g && h && !y && r.allowThresholdMove && r.currentTranslate < (i.centeredSlides ? n.maxTranslate() + n.slidesSizesGrid[n.slidesSizesGrid.length - 1] + n.params.spaceBetween + (i.slidesPerView !== "auto" && n.slides.length - i.slidesPerView >= 2 ? n.slidesSizesGrid[n.slidesSizesGrid.length - 1] + n.params.spaceBetween : 0) : n.maxTranslate()) && n.loopFix({ direction: "next", setTranslate: !0, activeSlideIndex: n.slides.length - (i.slidesPerView === "auto" ? n.slidesPerViewDynamic() : Math.ceil(parseFloat(i.slidesPerView, 10))) }), r.currentTranslate < n.maxTranslate() && (E = !1, i.resistance && (r.currentTranslate = n.maxTranslate() + 1 - (n.maxTranslate() - r.startTranslate - m) ** P))), E && (l.preventedByNestedSwiper = !0), !n.allowSlideNext && n.swipeDirection === "next" && r.currentTranslate < r.startTranslate && (r.currentTranslate = r.startTranslate), !n.allowSlidePrev && n.swipeDirection === "prev" && r.currentTranslate > r.startTranslate && (r.currentTranslate = r.startTranslate), !n.allowSlidePrev && !n.allowSlideNext && (r.currentTranslate = r.startTranslate), i.threshold > 0) if (Math.abs(m) > i.threshold || r.allowThresholdMove) { if (!r.allowThresholdMove) { r.allowThresholdMove = !0, o.startX = o.currentX, o.startY = o.currentY, r.currentTranslate = r.startTranslate, o.diff = n.isHorizontal() ? o.currentX - o.startX : o.currentY - o.startY; return } } else { r.currentTranslate = r.startTranslate; return } !i.followFinger || i.cssMode || ((i.freeMode && i.freeMode.enabled && n.freeMode || i.watchSlidesProgress) && (n.updateActiveIndex(), n.updateSlidesClasses()), i.freeMode && i.freeMode.enabled && n.freeMode && n.freeMode.onTouchMove(), n.updateProgress(r.currentTranslate), n.setTranslate(r.currentTranslate)) } function nH(e) { const t = this, n = t.touchEventsData; let r = e; r.originalEvent && (r = r.originalEvent); let i; if (r.type === "touchend" || r.type === "touchcancel") { if (i = [...r.changedTouches].filter(P => P.identifier === n.touchId)[0], !i || i.identifier !== n.touchId) return } else { if (n.touchId !== null || r.pointerId !== n.pointerId) return; i = r } if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(r.type) && !(["pointercancel", "contextmenu"].includes(r.type) && (t.browser.isSafari || t.browser.isWebView))) return; n.pointerId = null, n.touchId = null; const { params: s, touches: a, rtlTranslate: l, slidesGrid: u, enabled: c } = t; if (!c || !s.simulateTouch && r.pointerType === "mouse") return; if (n.allowTouchCallbacks && t.emit("touchEnd", r), n.allowTouchCallbacks = !1, !n.isTouched) { n.isMoved && s.grabCursor && t.setGrabCursor(!1), n.isMoved = !1, n.startMoving = !1; return } s.grabCursor && n.isMoved && n.isTouched && (t.allowSlideNext === !0 || t.allowSlidePrev === !0) && t.setGrabCursor(!1); const d = sf(), f = d - n.touchStartTime; if (t.allowClick) { const P = r.path || r.composedPath && r.composedPath(); t.updateClickedSlide(P && P[0] || r.target, P), t.emit("tap click", r), f < 300 && d - n.lastClickTime < 300 && t.emit("doubleTap doubleClick", r) } if (n.lastClickTime = sf(), Bg(() => { t.destroyed || (t.allowClick = !0) }), !n.isTouched || !n.isMoved || !t.swipeDirection || a.diff === 0 && !n.loopSwapReset || n.currentTranslate === n.startTranslate && !n.loopSwapReset) { n.isTouched = !1, n.isMoved = !1, n.startMoving = !1; return } n.isTouched = !1, n.isMoved = !1, n.startMoving = !1; let p; if (s.followFinger ? p = l ? t.translate : -t.translate : p = -n.currentTranslate, s.cssMode) return; if (s.freeMode && s.freeMode.enabled) { t.freeMode.onTouchEnd({ currentPos: p }); return } const m = p >= -t.maxTranslate() && !t.params.loop; let v = 0, x = t.slidesSizesGrid[0]; for (let P = 0; P < u.length; P += P < s.slidesPerGroupSkip ? 1 : s.slidesPerGroup) { const $ = P < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup; typeof u[P + $] < "u" ? (m || p >= u[P] && p < u[P + $]) && (v = P, x = u[P + $] - u[P]) : (m || p >= u[P]) && (v = P, x = u[u.length - 1] - u[u.length - 2]) } let g = null, h = null; s.rewind && (t.isBeginning ? h = s.virtual && s.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (g = 0)); const y = (p - u[v]) / x, E = v < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup; if (f > s.longSwipesMs) { if (!s.longSwipes) { t.slideTo(t.activeIndex); return } t.swipeDirection === "next" && (y >= s.longSwipesRatio ? t.slideTo(s.rewind && t.isEnd ? g : v + E) : t.slideTo(v)), t.swipeDirection === "prev" && (y > 1 - s.longSwipesRatio ? t.slideTo(v + E) : h !== null && y < 0 && Math.abs(y) > s.longSwipesRatio ? t.slideTo(h) : t.slideTo(v)) } else { if (!s.shortSwipes) { t.slideTo(t.activeIndex); return } t.navigation && (r.target === t.navigation.nextEl || r.target === t.navigation.prevEl) ? r.target === t.navigation.nextEl ? t.slideTo(v + E) : t.slideTo(v) : (t.swipeDirection === "next" && t.slideTo(g !== null ? g : v + E), t.swipeDirection === "prev" && t.slideTo(h !== null ? h : v)) } } function bS() { const e = this, { params: t, el: n } = e; if (n && n.offsetWidth === 0) return; t.breakpoints && e.setBreakpoint(); const { allowSlideNext: r, allowSlidePrev: i, snapGrid: o } = e, s = e.virtual && e.params.virtual.enabled; e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(); const a = s && t.loop; (t.slidesPerView === "auto" || t.slidesPerView > 1) && e.isEnd && !e.isBeginning && !e.params.centeredSlides && !a ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.params.loop && !s ? e.slideToLoop(e.realIndex, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && (clearTimeout(e.autoplay.resizeTimeout), e.autoplay.resizeTimeout = setTimeout(() => { e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.resume() }, 500)), e.allowSlidePrev = i, e.allowSlideNext = r, e.params.watchOverflow && o !== e.snapGrid && e.checkOverflow() } function rH(e) { const t = this; t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation()))) } function iH() { const e = this, { wrapperEl: t, rtlTranslate: n, enabled: r } = e; if (!r) return; e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, e.translate === 0 && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses(); let i; const o = e.maxTranslate() - e.minTranslate(); o === 0 ? i = 0 : i = (e.translate - e.minTranslate()) / o, i !== e.progress && e.updateProgress(n ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1) } function oH(e) { const t = this; rd(t, e.target), !(t.params.cssMode || t.params.slidesPerView !== "auto" && !t.params.autoHeight) && t.update() } function sH() { const e = this; e.documentTouchHandlerProceeded || (e.documentTouchHandlerProceeded = !0, e.params.touchReleaseOnEdges && (e.el.style.touchAction = "auto")) } const kM = (e, t) => { const n = Sa(), { params: r, el: i, wrapperEl: o, device: s } = e, a = !!r.nested, l = t === "on" ? "addEventListener" : "removeEventListener", u = t; !i || typeof i == "string" || (n[l]("touchstart", e.onDocumentTouchStart, { passive: !1, capture: a }), i[l]("touchstart", e.onTouchStart, { passive: !1 }), i[l]("pointerdown", e.onTouchStart, { passive: !1 }), n[l]("touchmove", e.onTouchMove, { passive: !1, capture: a }), n[l]("pointermove", e.onTouchMove, { passive: !1, capture: a }), n[l]("touchend", e.onTouchEnd, { passive: !0 }), n[l]("pointerup", e.onTouchEnd, { passive: !0 }), n[l]("pointercancel", e.onTouchEnd, { passive: !0 }), n[l]("touchcancel", e.onTouchEnd, { passive: !0 }), n[l]("pointerout", e.onTouchEnd, { passive: !0 }), n[l]("pointerleave", e.onTouchEnd, { passive: !0 }), n[l]("contextmenu", e.onTouchEnd, { passive: !0 }), (r.preventClicks || r.preventClicksPropagation) && i[l]("click", e.onClick, !0), r.cssMode && o[l]("scroll", e.onScroll), r.updateOnWindowResize ? e[u](s.ios || s.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", bS, !0) : e[u]("observerUpdate", bS, !0), i[l]("load", e.onLoad, { capture: !0 })) }; function aH() { const e = this, { params: t } = e; e.onTouchStart = eH.bind(e), e.onTouchMove = tH.bind(e), e.onTouchEnd = nH.bind(e), e.onDocumentTouchStart = sH.bind(e), t.cssMode && (e.onScroll = iH.bind(e)), e.onClick = rH.bind(e), e.onLoad = oH.bind(e), kM(e, "on") } function lH() { kM(this, "off") } var uH = { attachEvents: aH, detachEvents: lH }; const wS = (e, t) => e.grid && t.grid && t.grid.rows > 1; function cH() { const e = this, { realIndex: t, initialized: n, params: r, el: i } = e, o = r.breakpoints; if (!o || o && Object.keys(o).length === 0) return; const s = e.getBreakpoint(o, e.params.breakpointsBase, e.el); if (!s || e.currentBreakpoint === s) return; const l = (s in o ? o[s] : void 0) || e.originalParams, u = wS(e, r), c = wS(e, l), d = e.params.grabCursor, f = l.grabCursor, p = r.enabled; u && !c ? (i.classList.remove(`${r.containerModifierClass}grid`, `${r.containerModifierClass}grid-column`), e.emitContainerClasses()) : !u && c && (i.classList.add(`${r.containerModifierClass}grid`), (l.grid.fill && l.grid.fill === "column" || !l.grid.fill && r.grid.fill === "column") && i.classList.add(`${r.containerModifierClass}grid-column`), e.emitContainerClasses()), d && !f ? e.unsetGrabCursor() : !d && f && e.setGrabCursor(), ["navigation", "pagination", "scrollbar"].forEach(y => { if (typeof l[y] > "u") return; const E = r[y] && r[y].enabled, P = l[y] && l[y].enabled; E && !P && e[y].disable(), !E && P && e[y].enable() }); const m = l.direction && l.direction !== r.direction, v = r.loop && (l.slidesPerView !== r.slidesPerView || m), x = r.loop; m && n && e.changeDirection(), Cn(e.params, l); const g = e.params.enabled, h = e.params.loop; Object.assign(e, { allowTouchMove: e.params.allowTouchMove, allowSlideNext: e.params.allowSlideNext, allowSlidePrev: e.params.allowSlidePrev }), p && !g ? e.disable() : !p && g && e.enable(), e.currentBreakpoint = s, e.emit("_beforeBreakpoint", l), n && (v ? (e.loopDestroy(), e.loopCreate(t), e.updateSlides()) : !x && h ? (e.loopCreate(t), e.updateSlides()) : x && !h && e.loopDestroy()), e.emit("breakpoint", l) } function dH(e, t, n) { if (t === void 0 && (t = "window"), !e || t === "container" && !n) return; let r = !1; const i = Dn(), o = t === "window" ? i.innerHeight : n.clientHeight, s = Object.keys(e).map(a => { if (typeof a == "string" && a.indexOf("@") === 0) { const l = parseFloat(a.substr(1)); return { value: o * l, point: a } } return { value: a, point: a } }); s.sort((a, l) => parseInt(a.value, 10) - parseInt(l.value, 10)); for (let a = 0; a < s.length; a += 1) { const { point: l, value: u } = s[a]; t === "window" ? i.matchMedia(`(min-width: ${u}px)`).matches && (r = l) : u <= n.clientWidth && (r = l) } return r || "max" } var fH = { setBreakpoint: cH, getBreakpoint: dH }; function pH(e, t) { const n = []; return e.forEach(r => { typeof r == "object" ? Object.keys(r).forEach(i => { r[i] && n.push(t + i) }) : typeof r == "string" && n.push(t + r) }), n } function hH() { const e = this, { classNames: t, params: n, rtl: r, el: i, device: o } = e, s = pH(["initialized", n.direction, { "free-mode": e.params.freeMode && n.freeMode.enabled }, { autoheight: n.autoHeight }, { rtl: r }, { grid: n.grid && n.grid.rows > 1 }, { "grid-column": n.grid && n.grid.rows > 1 && n.grid.fill === "column" }, { android: o.android }, { ios: o.ios }, { "css-mode": n.cssMode }, { centered: n.cssMode && n.centeredSlides }, { "watch-progress": n.watchSlidesProgress }], n.containerModifierClass); t.push(...s), i.classList.add(...t), e.emitContainerClasses() } function mH() { const e = this, { el: t, classNames: n } = e; !t || typeof t == "string" || (t.classList.remove(...n), e.emitContainerClasses()) } var gH = { addClasses: hH, removeClasses: mH }; function vH() { const e = this, { isLocked: t, params: n } = e, { slidesOffsetBefore: r } = n; if (r) { const i = e.slides.length - 1, o = e.slidesGrid[i] + e.slidesSizesGrid[i] + r * 2; e.isLocked = e.size > o } else e.isLocked = e.snapGrid.length === 1; n.allowSlideNext === !0 && (e.allowSlideNext = !e.isLocked), n.allowSlidePrev === !0 && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock") } var yH = { checkOverflow: vH }, Wg = { init: !0, direction: "horizontal", oneWayMovement: !1, swiperElementNodeName: "SWIPER-CONTAINER", touchEventsTarget: "wrapper", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, eventsPrefix: "swiper", enabled: !0, focusableElements: "input, select, option, textarea, button, video, label", width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, breakpointsBase: "window", spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 5, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, loop: !1, loopAddBlankSlides: !0, loopAdditionalSlides: 0, loopPreventsSliding: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, maxBackfaceHiddenSlides: 10, containerModifierClass: "swiper-", slideClass: "swiper-slide", slideBlankClass: "swiper-slide-blank", slideActiveClass: "swiper-slide-active", slideVisibleClass: "swiper-slide-visible", slideFullyVisibleClass: "swiper-slide-fully-visible", slideNextClass: "swiper-slide-next", slidePrevClass: "swiper-slide-prev", wrapperClass: "swiper-wrapper", lazyPreloaderClass: "swiper-lazy-preloader", lazyPreloadPrevNext: 0, runCallbacksOnInit: !0, _emitClasses: !1 }; function bH(e, t) { return function (r) { r === void 0 && (r = {}); const i = Object.keys(r)[0], o = r[i]; if (typeof o != "object" || o === null) { Cn(t, r); return } if (e[i] === !0 && (e[i] = { enabled: !0 }), i === "navigation" && e[i] && e[i].enabled && !e[i].prevEl && !e[i].nextEl && (e[i].auto = !0), ["pagination", "scrollbar"].indexOf(i) >= 0 && e[i] && e[i].enabled && !e[i].el && (e[i].auto = !0), !(i in e && "enabled" in o)) { Cn(t, r); return } typeof e[i] == "object" && !("enabled" in e[i]) && (e[i].enabled = !0), e[i] || (e[i] = { enabled: !1 }), Cn(t, r) } } const Ah = { eventsEmitter: gU, update: $U, translate: LU, transition: IU, slide: WU, loop: YU, grabCursor: JU, events: uH, breakpoints: fH, checkOverflow: yH, classes: gH }, Mh = {}; let h0 = class Fr { constructor() { let t, n; for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; i.length === 1 && i[0].constructor && Object.prototype.toString.call(i[0]).slice(8, -1) === "Object" ? n = i[0] : [t, n] = i, n || (n = {}), n = Cn({}, n), t && !n.el && (n.el = t); const s = Sa(); if (n.el && typeof n.el == "string" && s.querySelectorAll(n.el).length > 1) { const c = []; return s.querySelectorAll(n.el).forEach(d => { const f = Cn({}, n, { el: d }); c.push(new Fr(f)) }), c } const a = this; a.__swiper__ = !0, a.support = $M(), a.device = AM({ userAgent: n.userAgent }), a.browser = pU(), a.eventsListeners = {}, a.eventsAnyListeners = [], a.modules = [...a.__modules__], n.modules && Array.isArray(n.modules) && a.modules.push(...n.modules); const l = {}; a.modules.forEach(c => { c({ params: n, swiper: a, extendParams: bH(n, l), on: a.on.bind(a), once: a.once.bind(a), off: a.off.bind(a), emit: a.emit.bind(a) }) }); const u = Cn({}, Wg, l); return a.params = Cn({}, u, Mh, n), a.originalParams = Cn({}, a.params), a.passedParams = Cn({}, n), a.params && a.params.on && Object.keys(a.params.on).forEach(c => { a.on(c, a.params.on[c]) }), a.params && a.params.onAny && a.onAny(a.params.onAny), Object.assign(a, { enabled: a.params.enabled, el: t, classNames: [], slides: [], slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal() { return a.params.direction === "horizontal" }, isVertical() { return a.params.direction === "vertical" }, activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, cssOverflowAdjustment() { return Math.trunc(this.translate / 2 ** 23) * 2 ** 23 }, allowSlideNext: a.params.allowSlideNext, allowSlidePrev: a.params.allowSlidePrev, touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: a.params.focusableElements, lastClickTime: 0, clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, startMoving: void 0, pointerId: null, touchId: null }, allowClick: !0, allowTouchMove: a.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), a.emit("_swiper"), a.params.init && a.init(), a } getDirectionLabel(t) { return this.isHorizontal() ? t : { width: "height", "margin-top": "margin-left", "margin-bottom ": "margin-right", "margin-left": "margin-top", "margin-right": "margin-bottom", "padding-left": "padding-top", "padding-right": "padding-bottom", marginRight: "marginBottom" }[t] } getSlideIndex(t) { const { slidesEl: n, params: r } = this, i = $r(n, `.${r.slideClass}, swiper-slide`), o = uf(i[0]); return uf(t) - o } getSlideIndexByData(t) { return this.getSlideIndex(this.slides.filter(n => n.getAttribute("data-swiper-slide-index") * 1 === t)[0]) } recalcSlides() { const t = this, { slidesEl: n, params: r } = t; t.slides = $r(n, `.${r.slideClass}, swiper-slide`) } enable() { const t = this; t.enabled || (t.enabled = !0, t.params.grabCursor && t.setGrabCursor(), t.emit("enable")) } disable() { const t = this; t.enabled && (t.enabled = !1, t.params.grabCursor && t.unsetGrabCursor(), t.emit("disable")) } setProgress(t, n) { const r = this; t = Math.min(Math.max(t, 0), 1); const i = r.minTranslate(), s = (r.maxTranslate() - i) * t + i; r.translateTo(s, typeof n > "u" ? 0 : n), r.updateActiveIndex(), r.updateSlidesClasses() } emitContainerClasses() { const t = this; if (!t.params._emitClasses || !t.el) return; const n = t.el.className.split(" ").filter(r => r.indexOf("swiper") === 0 || r.indexOf(t.params.containerModifierClass) === 0); t.emit("_containerClasses", n.join(" ")) } getSlideClasses(t) { const n = this; return n.destroyed ? "" : t.className.split(" ").filter(r => r.indexOf("swiper-slide") === 0 || r.indexOf(n.params.slideClass) === 0).join(" ") } emitSlidesClasses() { const t = this; if (!t.params._emitClasses || !t.el) return; const n = []; t.slides.forEach(r => { const i = t.getSlideClasses(r); n.push({ slideEl: r, classNames: i }), t.emit("_slideClass", r, i) }), t.emit("_slideClasses", n) } slidesPerViewDynamic(t, n) { t === void 0 && (t = "current"), n === void 0 && (n = !1); const r = this, { params: i, slides: o, slidesGrid: s, slidesSizesGrid: a, size: l, activeIndex: u } = r; let c = 1; if (typeof i.slidesPerView == "number") return i.slidesPerView; if (i.centeredSlides) { let d = o[u] ? Math.ceil(o[u].swiperSlideSize) : 0, f; for (let p = u + 1; p < o.length; p += 1)o[p] && !f && (d += Math.ceil(o[p].swiperSlideSize), c += 1, d > l && (f = !0)); for (let p = u - 1; p >= 0; p -= 1)o[p] && !f && (d += o[p].swiperSlideSize, c += 1, d > l && (f = !0)) } else if (t === "current") for (let d = u + 1; d < o.length; d += 1)(n ? s[d] + a[d] - s[u] < l : s[d] - s[u] < l) && (c += 1); else for (let d = u - 1; d >= 0; d -= 1)s[u] - s[d] < l && (c += 1); return c } update() { const t = this; if (!t || t.destroyed) return; const { snapGrid: n, params: r } = t; r.breakpoints && t.setBreakpoint(), [...t.el.querySelectorAll('[loading="lazy"]')].forEach(s => { s.complete && rd(t, s) }), t.updateSize(), t.updateSlides(), t.updateProgress(), t.updateSlidesClasses(); function i() { const s = t.rtlTranslate ? t.translate * -1 : t.translate, a = Math.min(Math.max(s, t.maxTranslate()), t.minTranslate()); t.setTranslate(a), t.updateActiveIndex(), t.updateSlidesClasses() } let o; if (r.freeMode && r.freeMode.enabled && !r.cssMode) i(), r.autoHeight && t.updateAutoHeight(); else { if ((r.slidesPerView === "auto" || r.slidesPerView > 1) && t.isEnd && !r.centeredSlides) { const s = t.virtual && r.virtual.enabled ? t.virtual.slides : t.slides; o = t.slideTo(s.length - 1, 0, !1, !0) } else o = t.slideTo(t.activeIndex, 0, !1, !0); o || i() } r.watchOverflow && n !== t.snapGrid && t.checkOverflow(), t.emit("update") } changeDirection(t, n) { n === void 0 && (n = !0); const r = this, i = r.params.direction; return t || (t = i === "horizontal" ? "vertical" : "horizontal"), t === i || t !== "horizontal" && t !== "vertical" || (r.el.classList.remove(`${r.params.containerModifierClass}${i}`), r.el.classList.add(`${r.params.containerModifierClass}${t}`), r.emitContainerClasses(), r.params.direction = t, r.slides.forEach(o => { t === "vertical" ? o.style.width = "" : o.style.height = "" }), r.emit("changeDirection"), n && r.update()), r } changeLanguageDirection(t) { const n = this; n.rtl && t === "rtl" || !n.rtl && t === "ltr" || (n.rtl = t === "rtl", n.rtlTranslate = n.params.direction === "horizontal" && n.rtl, n.rtl ? (n.el.classList.add(`${n.params.containerModifierClass}rtl`), n.el.dir = "rtl") : (n.el.classList.remove(`${n.params.containerModifierClass}rtl`), n.el.dir = "ltr"), n.update()) } mount(t) { const n = this; if (n.mounted) return !0; let r = t || n.params.el; if (typeof r == "string" && (r = document.querySelector(r)), !r) return !1; r.swiper = n, r.parentNode && r.parentNode.host && r.parentNode.host.nodeName === n.params.swiperElementNodeName.toUpperCase() && (n.isElement = !0); const i = () => `.${(n.params.wrapperClass || "").trim().split(" ").join(".")}`; let s = r && r.shadowRoot && r.shadowRoot.querySelector ? r.shadowRoot.querySelector(i()) : $r(r, i())[0]; return !s && n.params.createElements && (s = lf("div", n.params.wrapperClass), r.append(s), $r(r, `.${n.params.slideClass}`).forEach(a => { s.append(a) })), Object.assign(n, { el: r, wrapperEl: s, slidesEl: n.isElement && !r.parentNode.host.slideSlots ? r.parentNode.host : s, hostEl: n.isElement ? r.parentNode.host : r, mounted: !0, rtl: r.dir.toLowerCase() === "rtl" || ji(r, "direction") === "rtl", rtlTranslate: n.params.direction === "horizontal" && (r.dir.toLowerCase() === "rtl" || ji(r, "direction") === "rtl"), wrongRTL: ji(s, "display") === "-webkit-box" }), !0 } init(t) { const n = this; if (n.initialized || n.mount(t) === !1) return n; n.emit("beforeInit"), n.params.breakpoints && n.setBreakpoint(), n.addClasses(), n.updateSize(), n.updateSlides(), n.params.watchOverflow && n.checkOverflow(), n.params.grabCursor && n.enabled && n.setGrabCursor(), n.params.loop && n.virtual && n.params.virtual.enabled ? n.slideTo(n.params.initialSlide + n.virtual.slidesBefore, 0, n.params.runCallbacksOnInit, !1, !0) : n.slideTo(n.params.initialSlide, 0, n.params.runCallbacksOnInit, !1, !0), n.params.loop && n.loopCreate(), n.attachEvents(); const i = [...n.el.querySelectorAll('[loading="lazy"]')]; return n.isElement && i.push(...n.hostEl.querySelectorAll('[loading="lazy"]')), i.forEach(o => { o.complete ? rd(n, o) : o.addEventListener("load", s => { rd(n, s.target) }) }), Hg(n), n.initialized = !0, Hg(n), n.emit("init"), n.emit("afterInit"), n } destroy(t, n) { t === void 0 && (t = !0), n === void 0 && (n = !0); const r = this, { params: i, el: o, wrapperEl: s, slides: a } = r; return typeof r.params > "u" || r.destroyed || (r.emit("beforeDestroy"), r.initialized = !1, r.detachEvents(), i.loop && r.loopDestroy(), n && (r.removeClasses(), o && typeof o != "string" && o.removeAttribute("style"), s && s.removeAttribute("style"), a && a.length && a.forEach(l => { l.classList.remove(i.slideVisibleClass, i.slideFullyVisibleClass, i.slideActiveClass, i.slideNextClass, i.slidePrevClass), l.removeAttribute("style"), l.removeAttribute("data-swiper-slide-index") })), r.emit("destroy"), Object.keys(r.eventsListeners).forEach(l => { r.off(l) }), t !== !1 && (r.el && typeof r.el != "string" && (r.el.swiper = null), rU(r)), r.destroyed = !0), null } static extendDefaults(t) { Cn(Mh, t) } static get extendedDefaults() { return Mh } static get defaults() { return Wg } static installModule(t) { Fr.prototype.__modules__ || (Fr.prototype.__modules__ = []); const n = Fr.prototype.__modules__; typeof t == "function" && n.indexOf(t) < 0 && n.push(t) } static use(t) { return Array.isArray(t) ? (t.forEach(n => Fr.installModule(n)), Fr) : (Fr.installModule(t), Fr) } }; Object.keys(Ah).forEach(e => { Object.keys(Ah[e]).forEach(t => { h0.prototype[t] = Ah[e][t] }) }); h0.use([hU, mU]); const _M = ["eventsPrefix", "injectStyles", "injectStylesUrls", "modules", "init", "_direction", "oneWayMovement", "swiperElementNodeName", "touchEventsTarget", "initialSlide", "_speed", "cssMode", "updateOnWindowResize", "resizeObserver", "nested", "focusableElements", "_enabled", "_width", "_height", "preventInteractionOnTransition", "userAgent", "url", "_edgeSwipeDetection", "_edgeSwipeThreshold", "_freeMode", "_autoHeight", "setWrapperSize", "virtualTranslate", "_effect", "breakpoints", "breakpointsBase", "_spaceBetween", "_slidesPerView", "maxBackfaceHiddenSlides", "_grid", "_slidesPerGroup", "_slidesPerGroupSkip", "_slidesPerGroupAuto", "_centeredSlides", "_centeredSlidesBounds", "_slidesOffsetBefore", "_slidesOffsetAfter", "normalizeSlideIndex", "_centerInsufficientSlides", "_watchOverflow", "roundLengths", "touchRatio", "touchAngle", "simulateTouch", "_shortSwipes", "_longSwipes", "longSwipesRatio", "longSwipesMs", "_followFinger", "allowTouchMove", "_threshold", "touchMoveStopPropagation", "touchStartPreventDefault", "touchStartForcePreventDefault", "touchReleaseOnEdges", "uniqueNavElements", "_resistance", "_resistanceRatio", "_watchSlidesProgress", "_grabCursor", "preventClicks", "preventClicksPropagation", "_slideToClickedSlide", "_loop", "loopAdditionalSlides", "loopAddBlankSlides", "loopPreventsSliding", "_rewind", "_allowSlidePrev", "_allowSlideNext", "_swipeHandler", "_noSwiping", "noSwipingClass", "noSwipingSelector", "passiveListeners", "containerModifierClass", "slideClass", "slideActiveClass", "slideVisibleClass", "slideFullyVisibleClass", "slideNextClass", "slidePrevClass", "slideBlankClass", "wrapperClass", "lazyPreloaderClass", "lazyPreloadPrevNext", "runCallbacksOnInit", "observer", "observeParents", "observeSlideChildren", "a11y", "_autoplay", "_controller", "coverflowEffect", "cubeEffect", "fadeEffect", "flipEffect", "creativeEffect", "cardsEffect", "hashNavigation", "history", "keyboard", "mousewheel", "_navigation", "_pagination", "parallax", "_scrollbar", "_thumbs", "virtual", "zoom", "control"]; function Go(e) { return typeof e == "object" && e !== null && e.constructor && Object.prototype.toString.call(e).slice(8, -1) === "Object" && !e.__swiper__ } function Gs(e, t) { const n = ["__proto__", "constructor", "prototype"]; Object.keys(t).filter(r => n.indexOf(r) < 0).forEach(r => { typeof e[r] > "u" ? e[r] = t[r] : Go(t[r]) && Go(e[r]) && Object.keys(t[r]).length > 0 ? t[r].__swiper__ ? e[r] = t[r] : Gs(e[r], t[r]) : e[r] = t[r] }) } function RM(e) { return e === void 0 && (e = {}), e.navigation && typeof e.navigation.nextEl > "u" && typeof e.navigation.prevEl > "u" } function LM(e) { return e === void 0 && (e = {}), e.pagination && typeof e.pagination.el > "u" } function NM(e) { return e === void 0 && (e = {}), e.scrollbar && typeof e.scrollbar.el > "u" } function OM(e) { e === void 0 && (e = ""); const t = e.split(" ").map(r => r.trim()).filter(r => !!r), n = []; return t.forEach(r => { n.indexOf(r) < 0 && n.push(r) }), n.join(" ") } function wH(e) { return e === void 0 && (e = ""), e ? e.includes("swiper-wrapper") ? e : `swiper-wrapper ${e}` : "swiper-wrapper" } function xH(e) { let { swiper: t, slides: n, passedParams: r, changedParams: i, nextEl: o, prevEl: s, scrollbarEl: a, paginationEl: l } = e; const u = i.filter(M => M !== "children" && M !== "direction" && M !== "wrapperClass"), { params: c, pagination: d, navigation: f, scrollbar: p, virtual: m, thumbs: v } = t; let x, g, h, y, E, P, $, L; i.includes("thumbs") && r.thumbs && r.thumbs.swiper && c.thumbs && !c.thumbs.swiper && (x = !0), i.includes("controller") && r.controller && r.controller.control && c.controller && !c.controller.control && (g = !0), i.includes("pagination") && r.pagination && (r.pagination.el || l) && (c.pagination || c.pagination === !1) && d && !d.el && (h = !0), i.includes("scrollbar") && r.scrollbar && (r.scrollbar.el || a) && (c.scrollbar || c.scrollbar === !1) && p && !p.el && (y = !0), i.includes("navigation") && r.navigation && (r.navigation.prevEl || s) && (r.navigation.nextEl || o) && (c.navigation || c.navigation === !1) && f && !f.prevEl && !f.nextEl && (E = !0); const b = M => { t[M] && (t[M].destroy(), M === "navigation" ? (t.isElement && (t[M].prevEl.remove(), t[M].nextEl.remove()), c[M].prevEl = void 0, c[M].nextEl = void 0, t[M].prevEl = void 0, t[M].nextEl = void 0) : (t.isElement && t[M].el.remove(), c[M].el = void 0, t[M].el = void 0)) }; i.includes("loop") && t.isElement && (c.loop && !r.loop ? P = !0 : !c.loop && r.loop ? $ = !0 : L = !0), u.forEach(M => { if (Go(c[M]) && Go(r[M])) Object.assign(c[M], r[M]), (M === "navigation" || M === "pagination" || M === "scrollbar") && "enabled" in r[M] && !r[M].enabled && b(M); else { const R = r[M]; (R === !0 || R === !1) && (M === "navigation" || M === "pagination" || M === "scrollbar") ? R === !1 && b(M) : c[M] = r[M] } }), u.includes("controller") && !g && t.controller && t.controller.control && c.controller && c.controller.control && (t.controller.control = c.controller.control), i.includes("children") && n && m && c.virtual.enabled ? (m.slides = n, m.update(!0)) : i.includes("virtual") && m && c.virtual.enabled && (n && (m.slides = n), m.update(!0)), i.includes("children") && n && c.loop && (L = !0), x && v.init() && v.update(!0), g && (t.controller.control = c.controller.control), h && (t.isElement && (!l || typeof l == "string") && (l = document.createElement("div"), l.classList.add("swiper-pagination"), l.part.add("pagination"), t.el.appendChild(l)), l && (c.pagination.el = l), d.init(), d.render(), d.update()), y && (t.isElement && (!a || typeof a == "string") && (a = document.createElement("div"), a.classList.add("swiper-scrollbar"), a.part.add("scrollbar"), t.el.appendChild(a)), a && (c.scrollbar.el = a), p.init(), p.updateSize(), p.setTranslate()), E && (t.isElement && ((!o || typeof o == "string") && (o = document.createElement("div"), o.classList.add("swiper-button-next"), o.innerHTML = t.hostEl.constructor.nextButtonSvg, o.part.add("button-next"), t.el.appendChild(o)), (!s || typeof s == "string") && (s = document.createElement("div"), s.classList.add("swiper-button-prev"), s.innerHTML = t.hostEl.constructor.prevButtonSvg, s.part.add("button-prev"), t.el.appendChild(s))), o && (c.navigation.nextEl = o), s && (c.navigation.prevEl = s), f.init(), f.update()), i.includes("allowSlideNext") && (t.allowSlideNext = r.allowSlideNext), i.includes("allowSlidePrev") && (t.allowSlidePrev = r.allowSlidePrev), i.includes("direction") && t.changeDirection(r.direction, !1), (P || L) && t.loopDestroy(), ($ || L) && t.loopCreate(), t.update() } function SH(e, t) { e === void 0 && (e = {}), t === void 0 && (t = !0); const n = { on: {} }, r = {}, i = {}; Gs(n, Wg), n._emitClasses = !0, n.init = !1; const o = {}, s = _M.map(l => l.replace(/_/, "")), a = Object.assign({}, e); return Object.keys(a).forEach(l => { typeof e[l] > "u" || (s.indexOf(l) >= 0 ? Go(e[l]) ? (n[l] = {}, i[l] = {}, Gs(n[l], e[l]), Gs(i[l], e[l])) : (n[l] = e[l], i[l] = e[l]) : l.search(/on[A-Z]/) === 0 && typeof e[l] == "function" ? t ? r[`${l[2].toLowerCase()}${l.substr(3)}`] = e[l] : n.on[`${l[2].toLowerCase()}${l.substr(3)}`] = e[l] : o[l] = e[l]) }), ["navigation", "pagination", "scrollbar"].forEach(l => { n[l] === !0 && (n[l] = {}), n[l] === !1 && delete n[l] }), { params: n, passedParams: i, rest: o, events: r } } function EH(e, t) { let { el: n, nextEl: r, prevEl: i, paginationEl: o, scrollbarEl: s, swiper: a } = e; RM(t) && r && i && (a.params.navigation.nextEl = r, a.originalParams.navigation.nextEl = r, a.params.navigation.prevEl = i, a.originalParams.navigation.prevEl = i), LM(t) && o && (a.params.pagination.el = o, a.originalParams.pagination.el = o), NM(t) && s && (a.params.scrollbar.el = s, a.originalParams.scrollbar.el = s), a.init(n) } function TH(e, t, n, r, i) { const o = []; if (!t) return o; const s = l => { o.indexOf(l) < 0 && o.push(l) }; if (n && r) { const l = r.map(i), u = n.map(i); l.join("") !== u.join("") && s("children"), r.length !== n.length && s("children") } return _M.filter(l => l[0] === "_").map(l => l.replace(/_/, "")).forEach(l => { if (l in e && l in t) if (Go(e[l]) && Go(t[l])) { const u = Object.keys(e[l]), c = Object.keys(t[l]); u.length !== c.length ? s(l) : (u.forEach(d => { e[l][d] !== t[l][d] && s(l) }), c.forEach(d => { e[l][d] !== t[l][d] && s(l) })) } else e[l] !== t[l] && s(l) }), o } const CH = e => { !e || e.destroyed || !e.params.virtual || e.params.virtual && !e.params.virtual.enabled || (e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.parallax && e.params.parallax && e.params.parallax.enabled && e.parallax.setTranslate()) }; function cf() { return cf = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, cf.apply(this, arguments) } function jM(e) { return e.type && e.type.displayName && e.type.displayName.includes("SwiperSlide") } function IM(e) { const t = []; return se.Children.toArray(e).forEach(n => { jM(n) ? t.push(n) : n.props && n.props.children && IM(n.props.children).forEach(r => t.push(r)) }), t } function PH(e) { const t = [], n = { "container-start": [], "container-end": [], "wrapper-start": [], "wrapper-end": [] }; return se.Children.toArray(e).forEach(r => { if (jM(r)) t.push(r); else if (r.props && r.props.slot && n[r.props.slot]) n[r.props.slot].push(r); else if (r.props && r.props.children) { const i = IM(r.props.children); i.length > 0 ? i.forEach(o => t.push(o)) : n["container-end"].push(r) } else n["container-end"].push(r) }), { slides: t, slots: n } } function $H(e, t, n) { if (!n) return null; const r = c => { let d = c; return c < 0 ? d = t.length + c : d >= t.length && (d = d - t.length), d }, i = e.isHorizontal() ? { [e.rtlTranslate ? "right" : "left"]: `${n.offset}px` } : { top: `${n.offset}px` }, { from: o, to: s } = n, a = e.params.loop ? -t.length : 0, l = e.params.loop ? t.length * 2 : t.length, u = []; for (let c = a; c < l; c += 1)c >= o && c <= s && u.push(t[r(c)]); return u.map((c, d) => se.cloneElement(c, { swiper: e, style: i, key: c.props.virtualIndex || c.key || `slide-${d}` })) } function $l(e, t) { return typeof window > "u" ? S.useEffect(e, t) : S.useLayoutEffect(e, t) } const xS = S.createContext(null), AH = S.createContext(null), DM = S.forwardRef(function (e, t) { let { className: n, tag: r = "div", wrapperTag: i = "div", children: o, onSwiper: s, ...a } = e === void 0 ? {} : e, l = !1; const [u, c] = S.useState("swiper"), [d, f] = S.useState(null), [p, m] = S.useState(!1), v = S.useRef(!1), x = S.useRef(null), g = S.useRef(null), h = S.useRef(null), y = S.useRef(null), E = S.useRef(null), P = S.useRef(null), $ = S.useRef(null), L = S.useRef(null), { params: b, passedParams: M, rest: R, events: A } = SH(a), { slides: _, slots: C } = PH(o), k = () => { m(!p) }; Object.assign(b.on, { _containerClasses(V, H) { c(H) } }); const O = () => { Object.assign(b.on, A), l = !0; const V = { ...b }; if (delete V.wrapperClass, g.current = new h0(V), g.current.virtual && g.current.params.virtual.enabled) { g.current.virtual.slides = _; const H = { cache: !1, slides: _, renderExternal: f, renderExternalUpdate: !1 }; Gs(g.current.params.virtual, H), Gs(g.current.originalParams.virtual, H) } }; x.current || O(), g.current && g.current.on("_beforeBreakpoint", k); const U = () => { l || !A || !g.current || Object.keys(A).forEach(V => { g.current.on(V, A[V]) }) }, z = () => { !A || !g.current || Object.keys(A).forEach(V => { g.current.off(V, A[V]) }) }; S.useEffect(() => () => { g.current && g.current.off("_beforeBreakpoint", k) }), S.useEffect(() => { !v.current && g.current && (g.current.emitSlidesClasses(), v.current = !0) }), $l(() => { if (t && (t.current = x.current), !!x.current) return g.current.destroyed && O(), EH({ el: x.current, nextEl: E.current, prevEl: P.current, paginationEl: $.current, scrollbarEl: L.current, swiper: g.current }, b), s && !g.current.destroyed && s(g.current), () => { g.current && !g.current.destroyed && g.current.destroy(!0, !1) } }, []), $l(() => { U(); const V = TH(M, h.current, _, y.current, H => H.key); return h.current = M, y.current = _, V.length && g.current && !g.current.destroyed && xH({ swiper: g.current, slides: _, passedParams: M, changedParams: V, nextEl: E.current, prevEl: P.current, scrollbarEl: L.current, paginationEl: $.current }), () => { z() } }), $l(() => { CH(g.current) }, [d]); function D() { return b.virtual ? $H(g.current, _, d) : _.map((V, H) => se.cloneElement(V, { swiper: g.current, swiperSlideIndex: H })) } return se.createElement(r, cf({ ref: x, className: OM(`${u}${n ? ` ${n}` : ""}`) }, R), se.createElement(AH.Provider, { value: g.current }, C["container-start"], se.createElement(i, { className: wH(b.wrapperClass) }, C["wrapper-start"], D(), C["wrapper-end"]), RM(b) && se.createElement(se.Fragment, null, se.createElement("div", { ref: P, className: "swiper-button-prev" }), se.createElement("div", { ref: E, className: "swiper-button-next" })), NM(b) && se.createElement("div", { ref: L, className: "swiper-scrollbar" }), LM(b) && se.createElement("div", { ref: $, className: "swiper-pagination" }), C["container-end"])) }); DM.displayName = "Swiper"; const FM = S.forwardRef(function (e, t) { let { tag: n = "div", children: r, className: i = "", swiper: o, zoom: s, lazy: a, virtualIndex: l, swiperSlideIndex: u, ...c } = e === void 0 ? {} : e; const d = S.useRef(null), [f, p] = S.useState("swiper-slide"), [m, v] = S.useState(!1); function x(E, P, $) { P === d.current && p($) } $l(() => { if (typeof u < "u" && (d.current.swiperSlideIndex = u), t && (t.current = d.current), !(!d.current || !o)) { if (o.destroyed) { f !== "swiper-slide" && p("swiper-slide"); return } return o.on("_slideClass", x), () => { o && o.off("_slideClass", x) } } }), $l(() => { o && d.current && !o.destroyed && p(o.getSlideClasses(d.current)) }, [o]); const g = { isActive: f.indexOf("swiper-slide-active") >= 0, isVisible: f.indexOf("swiper-slide-visible") >= 0, isPrev: f.indexOf("swiper-slide-prev") >= 0, isNext: f.indexOf("swiper-slide-next") >= 0 }, h = () => typeof r == "function" ? r(g) : r, y = () => { v(!0) }; return se.createElement(n, cf({ ref: d, className: OM(`${f}${i ? ` ${i}` : ""}`), "data-swiper-slide-index": l, onLoad: y }, c), s && se.createElement(xS.Provider, { value: g }, se.createElement("div", { className: "swiper-zoom-container", "data-swiper-zoom": typeof s == "number" ? s : void 0 }, h(), a && !m && se.createElement("div", { className: "swiper-lazy-preloader" }))), !s && se.createElement(xS.Provider, { value: g }, h(), a && !m && se.createElement("div", { className: "swiper-lazy-preloader" }))) }); FM.displayName = "SwiperSlide"; function zM(e, t, n, r) { return e.params.createElements && Object.keys(r).forEach(i => { if (!n[i] && n.auto === !0) { let o = $r(e.el, `.${r[i]}`)[0]; o || (o = lf("div", r[i]), o.className = r[i], e.el.append(o)), n[i] = o, t[i] = o } }), n } function MH(e) { let { swiper: t, extendParams: n, on: r, emit: i } = e; n({ navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: "swiper-button-disabled", hiddenClass: "swiper-button-hidden", lockClass: "swiper-button-lock", navigationDisabledClass: "swiper-navigation-disabled" } }), t.navigation = { nextEl: null, prevEl: null }; function o(m) { let v; return m && typeof m == "string" && t.isElement && (v = t.el.querySelector(m), v) ? v : (m && (typeof m == "string" && (v = [...document.querySelectorAll(m)]), t.params.uniqueNavElements && typeof m == "string" && v && v.length > 1 && t.el.querySelectorAll(m).length === 1 ? v = t.el.querySelector(m) : v && v.length === 1 && (v = v[0])), m && !v ? m : v) } function s(m, v) { const x = t.params.navigation; m = Lt(m), m.forEach(g => { g && (g.classList[v ? "add" : "remove"](...x.disabledClass.split(" ")), g.tagName === "BUTTON" && (g.disabled = v), t.params.watchOverflow && t.enabled && g.classList[t.isLocked ? "add" : "remove"](x.lockClass)) }) } function a() { const { nextEl: m, prevEl: v } = t.navigation; if (t.params.loop) { s(v, !1), s(m, !1); return } s(v, t.isBeginning && !t.params.rewind), s(m, t.isEnd && !t.params.rewind) } function l(m) { m.preventDefault(), !(t.isBeginning && !t.params.loop && !t.params.rewind) && (t.slidePrev(), i("navigationPrev")) } function u(m) { m.preventDefault(), !(t.isEnd && !t.params.loop && !t.params.rewind) && (t.slideNext(), i("navigationNext")) } function c() { const m = t.params.navigation; if (t.params.navigation = zM(t, t.originalParams.navigation, t.params.navigation, { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }), !(m.nextEl || m.prevEl)) return; let v = o(m.nextEl), x = o(m.prevEl); Object.assign(t.navigation, { nextEl: v, prevEl: x }), v = Lt(v), x = Lt(x); const g = (h, y) => { h && h.addEventListener("click", y === "next" ? u : l), !t.enabled && h && h.classList.add(...m.lockClass.split(" ")) }; v.forEach(h => g(h, "next")), x.forEach(h => g(h, "prev")) } function d() { let { nextEl: m, prevEl: v } = t.navigation; m = Lt(m), v = Lt(v); const x = (g, h) => { g.removeEventListener("click", h === "next" ? u : l), g.classList.remove(...t.params.navigation.disabledClass.split(" ")) }; m.forEach(g => x(g, "next")), v.forEach(g => x(g, "prev")) } r("init", () => { t.params.navigation.enabled === !1 ? p() : (c(), a()) }), r("toEdge fromEdge lock unlock", () => { a() }), r("destroy", () => { d() }), r("enable disable", () => { let { nextEl: m, prevEl: v } = t.navigation; if (m = Lt(m), v = Lt(v), t.enabled) { a(); return } [...m, ...v].filter(x => !!x).forEach(x => x.classList.add(t.params.navigation.lockClass)) }), r("click", (m, v) => { let { nextEl: x, prevEl: g } = t.navigation; x = Lt(x), g = Lt(g); const h = v.target; let y = g.includes(h) || x.includes(h); if (t.isElement && !y) { const E = v.path || v.composedPath && v.composedPath(); E && (y = E.find(P => x.includes(P) || g.includes(P))) } if (t.params.navigation.hideOnClick && !y) { if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === h || t.pagination.el.contains(h))) return; let E; x.length ? E = x[0].classList.contains(t.params.navigation.hiddenClass) : g.length && (E = g[0].classList.contains(t.params.navigation.hiddenClass)), i(E === !0 ? "navigationShow" : "navigationHide"), [...x, ...g].filter(P => !!P).forEach(P => P.classList.toggle(t.params.navigation.hiddenClass)) } }); const f = () => { t.el.classList.remove(...t.params.navigation.navigationDisabledClass.split(" ")), c(), a() }, p = () => { t.el.classList.add(...t.params.navigation.navigationDisabledClass.split(" ")), d() }; Object.assign(t.navigation, { enable: f, disable: p, update: a, init: c, destroy: d }) } function Ya(e) { return e === void 0 && (e = ""), `.${e.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}` } function kH(e) { let { swiper: t, extendParams: n, on: r, emit: i } = e; const o = "swiper-pagination"; n({ pagination: { el: null, bulletElement: "span", clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: "bullets", dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent: h => h, formatFractionTotal: h => h, bulletClass: `${o}-bullet`, bulletActiveClass: `${o}-bullet-active`, modifierClass: `${o}-`, currentClass: `${o}-current`, totalClass: `${o}-total`, hiddenClass: `${o}-hidden`, progressbarFillClass: `${o}-progressbar-fill`, progressbarOppositeClass: `${o}-progressbar-opposite`, clickableClass: `${o}-clickable`, lockClass: `${o}-lock`, horizontalClass: `${o}-horizontal`, verticalClass: `${o}-vertical`, paginationDisabledClass: `${o}-disabled` } }), t.pagination = { el: null, bullets: [] }; let s, a = 0; function l() { return !t.params.pagination.el || !t.pagination.el || Array.isArray(t.pagination.el) && t.pagination.el.length === 0 } function u(h, y) { const { bulletActiveClass: E } = t.params.pagination; h && (h = h[`${y === "prev" ? "previous" : "next"}ElementSibling`], h && (h.classList.add(`${E}-${y}`), h = h[`${y === "prev" ? "previous" : "next"}ElementSibling`], h && h.classList.add(`${E}-${y}-${y}`))) } function c(h, y, E) { if (h = h % E, y = y % E, y === h + 1) return "next"; if (y === h - 1) return "previous" } function d(h) { const y = h.target.closest(Ya(t.params.pagination.bulletClass)); if (!y) return; h.preventDefault(); const E = uf(y) * t.params.slidesPerGroup; if (t.params.loop) { if (t.realIndex === E) return; const P = c(t.realIndex, E, t.slides.length); P === "next" ? t.slideNext() : P === "previous" ? t.slidePrev() : t.slideToLoop(E) } else t.slideTo(E) } function f() { const h = t.rtl, y = t.params.pagination; if (l()) return; let E = t.pagination.el; E = Lt(E); let P, $; const L = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length, b = t.params.loop ? Math.ceil(L / t.params.slidesPerGroup) : t.snapGrid.length; if (t.params.loop ? ($ = t.previousRealIndex || 0, P = t.params.slidesPerGroup > 1 ? Math.floor(t.realIndex / t.params.slidesPerGroup) : t.realIndex) : typeof t.snapIndex < "u" ? (P = t.snapIndex, $ = t.previousSnapIndex) : ($ = t.previousIndex || 0, P = t.activeIndex || 0), y.type === "bullets" && t.pagination.bullets && t.pagination.bullets.length > 0) { const M = t.pagination.bullets; let R, A, _; if (y.dynamicBullets && (s = Ug(M[0], t.isHorizontal() ? "width" : "height"), E.forEach(C => { C.style[t.isHorizontal() ? "width" : "height"] = `${s * (y.dynamicMainBullets + 4)}px` }), y.dynamicMainBullets > 1 && $ !== void 0 && (a += P - ($ || 0), a > y.dynamicMainBullets - 1 ? a = y.dynamicMainBullets - 1 : a < 0 && (a = 0)), R = Math.max(P - a, 0), A = R + (Math.min(M.length, y.dynamicMainBullets) - 1), _ = (A + R) / 2), M.forEach(C => { const k = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(O => `${y.bulletActiveClass}${O}`)].map(O => typeof O == "string" && O.includes(" ") ? O.split(" ") : O).flat(); C.classList.remove(...k) }), E.length > 1) M.forEach(C => { const k = uf(C); k === P ? C.classList.add(...y.bulletActiveClass.split(" ")) : t.isElement && C.setAttribute("part", "bullet"), y.dynamicBullets && (k >= R && k <= A && C.classList.add(...`${y.bulletActiveClass}-main`.split(" ")), k === R && u(C, "prev"), k === A && u(C, "next")) }); else { const C = M[P]; if (C && C.classList.add(...y.bulletActiveClass.split(" ")), t.isElement && M.forEach((k, O) => { k.setAttribute("part", O === P ? "bullet-active" : "bullet") }), y.dynamicBullets) { const k = M[R], O = M[A]; for (let U = R; U <= A; U += 1)M[U] && M[U].classList.add(...`${y.bulletActiveClass}-main`.split(" ")); u(k, "prev"), u(O, "next") } } if (y.dynamicBullets) { const C = Math.min(M.length, y.dynamicMainBullets + 4), k = (s * C - s) / 2 - _ * s, O = h ? "right" : "left"; M.forEach(U => { U.style[t.isHorizontal() ? O : "top"] = `${k}px` }) } } E.forEach((M, R) => { if (y.type === "fraction" && (M.querySelectorAll(Ya(y.currentClass)).forEach(A => { A.textContent = y.formatFractionCurrent(P + 1) }), M.querySelectorAll(Ya(y.totalClass)).forEach(A => { A.textContent = y.formatFractionTotal(b) })), y.type === "progressbar") { let A; y.progressbarOpposite ? A = t.isHorizontal() ? "vertical" : "horizontal" : A = t.isHorizontal() ? "horizontal" : "vertical"; const _ = (P + 1) / b; let C = 1, k = 1; A === "horizontal" ? C = _ : k = _, M.querySelectorAll(Ya(y.progressbarFillClass)).forEach(O => { O.style.transform = `translate3d(0,0,0) scaleX(${C}) scaleY(${k})`, O.style.transitionDuration = `${t.params.speed}ms` }) } y.type === "custom" && y.renderCustom ? (M.innerHTML = y.renderCustom(t, P + 1, b), R === 0 && i("paginationRender", M)) : (R === 0 && i("paginationRender", M), i("paginationUpdate", M)), t.params.watchOverflow && t.enabled && M.classList[t.isLocked ? "add" : "remove"](y.lockClass) }) } function p() { const h = t.params.pagination; if (l()) return; const y = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.grid && t.params.grid.rows > 1 ? t.slides.length / Math.ceil(t.params.grid.rows) : t.slides.length; let E = t.pagination.el; E = Lt(E); let P = ""; if (h.type === "bullets") { let $ = t.params.loop ? Math.ceil(y / t.params.slidesPerGroup) : t.snapGrid.length; t.params.freeMode && t.params.freeMode.enabled && $ > y && ($ = y); for (let L = 0; L < $; L += 1)h.renderBullet ? P += h.renderBullet.call(t, L, h.bulletClass) : P += `<${h.bulletElement} ${t.isElement ? 'part="bullet"' : ""} class="${h.bulletClass}"></${h.bulletElement}>` } h.type === "fraction" && (h.renderFraction ? P = h.renderFraction.call(t, h.currentClass, h.totalClass) : P = `<span class="${h.currentClass}"></span> / <span class="${h.totalClass}"></span>`), h.type === "progressbar" && (h.renderProgressbar ? P = h.renderProgressbar.call(t, h.progressbarFillClass) : P = `<span class="${h.progressbarFillClass}"></span>`), t.pagination.bullets = [], E.forEach($ => { h.type !== "custom" && ($.innerHTML = P || ""), h.type === "bullets" && t.pagination.bullets.push(...$.querySelectorAll(Ya(h.bulletClass))) }), h.type !== "custom" && i("paginationRender", E[0]) } function m() { t.params.pagination = zM(t, t.originalParams.pagination, t.params.pagination, { el: "swiper-pagination" }); const h = t.params.pagination; if (!h.el) return; let y; typeof h.el == "string" && t.isElement && (y = t.el.querySelector(h.el)), !y && typeof h.el == "string" && (y = [...document.querySelectorAll(h.el)]), y || (y = h.el), !(!y || y.length === 0) && (t.params.uniqueNavElements && typeof h.el == "string" && Array.isArray(y) && y.length > 1 && (y = [...t.el.querySelectorAll(h.el)], y.length > 1 && (y = y.filter(E => PM(E, ".swiper")[0] === t.el)[0])), Array.isArray(y) && y.length === 1 && (y = y[0]), Object.assign(t.pagination, { el: y }), y = Lt(y), y.forEach(E => { h.type === "bullets" && h.clickable && E.classList.add(...(h.clickableClass || "").split(" ")), E.classList.add(h.modifierClass + h.type), E.classList.add(t.isHorizontal() ? h.horizontalClass : h.verticalClass), h.type === "bullets" && h.dynamicBullets && (E.classList.add(`${h.modifierClass}${h.type}-dynamic`), a = 0, h.dynamicMainBullets < 1 && (h.dynamicMainBullets = 1)), h.type === "progressbar" && h.progressbarOpposite && E.classList.add(h.progressbarOppositeClass), h.clickable && E.addEventListener("click", d), t.enabled || E.classList.add(h.lockClass) })) } function v() { const h = t.params.pagination; if (l()) return; let y = t.pagination.el; y && (y = Lt(y), y.forEach(E => { E.classList.remove(h.hiddenClass), E.classList.remove(h.modifierClass + h.type), E.classList.remove(t.isHorizontal() ? h.horizontalClass : h.verticalClass), h.clickable && (E.classList.remove(...(h.clickableClass || "").split(" ")), E.removeEventListener("click", d)) })), t.pagination.bullets && t.pagination.bullets.forEach(E => E.classList.remove(...h.bulletActiveClass.split(" "))) } r("changeDirection", () => { if (!t.pagination || !t.pagination.el) return; const h = t.params.pagination; let { el: y } = t.pagination; y = Lt(y), y.forEach(E => { E.classList.remove(h.horizontalClass, h.verticalClass), E.classList.add(t.isHorizontal() ? h.horizontalClass : h.verticalClass) }) }), r("init", () => { t.params.pagination.enabled === !1 ? g() : (m(), p(), f()) }), r("activeIndexChange", () => { typeof t.snapIndex > "u" && f() }), r("snapIndexChange", () => { f() }), r("snapGridLengthChange", () => { p(), f() }), r("destroy", () => { v() }), r("enable disable", () => { let { el: h } = t.pagination; h && (h = Lt(h), h.forEach(y => y.classList[t.enabled ? "remove" : "add"](t.params.pagination.lockClass))) }), r("lock unlock", () => { f() }), r("click", (h, y) => { const E = y.target, P = Lt(t.pagination.el); if (t.params.pagination.el && t.params.pagination.hideOnClick && P && P.length > 0 && !E.classList.contains(t.params.pagination.bulletClass)) { if (t.navigation && (t.navigation.nextEl && E === t.navigation.nextEl || t.navigation.prevEl && E === t.navigation.prevEl)) return; const $ = P[0].classList.contains(t.params.pagination.hiddenClass); i($ === !0 ? "paginationShow" : "paginationHide"), P.forEach(L => L.classList.toggle(t.params.pagination.hiddenClass)) } }); const x = () => { t.el.classList.remove(t.params.pagination.paginationDisabledClass); let { el: h } = t.pagination; h && (h = Lt(h), h.forEach(y => y.classList.remove(t.params.pagination.paginationDisabledClass))), m(), p(), f() }, g = () => { t.el.classList.add(t.params.pagination.paginationDisabledClass); let { el: h } = t.pagination; h && (h = Lt(h), h.forEach(y => y.classList.add(t.params.pagination.paginationDisabledClass))), v() }; Object.assign(t.pagination, { enable: x, disable: g, render: p, update: f, init: m, destroy: v }) } const _H = ({ teamMembers: e, loading: t }) => { const [n, r] = S.useState(null); if (!e) return w.jsx(sM, { name: "Team Members" }); const i = o => { r(o) }; return w.jsxs("div", { className: "flex flex-col gap-10 mt-20 w-[90%] lg:w-[70%] md:w-[80%] mx-auto", id: "team", children: [w.jsx("div", { className: "flex justify-between items-center w-full", children: w.jsx("h2", { className: "text-4xl font-extrabold", children: "Our Team" }) }), w.jsx(S.Suspense, { fallback: w.jsx(Fu, {}), children: w.jsx(DM, { slidesPerView: 3, spaceBetween: 30, pagination: { type: "fraction" }, navigation: !0, modules: [kH, MH], breakpoints: { 320: { slidesPerView: 1 }, 640: { slidesPerView: 2 }, 1024: { slidesPerView: 3 } }, className: "mySwiper h-fit w-full", children: e.map((o, s) => w.jsx(FM, { className: "h-fit w-full", children: w.jsx(eU, { teamMember: o, index: s, hoverValue: n, handleHover: i }) }, o._id)) }) })] }) }; function kh(e) { return vr({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { d: "M5.566 4.657A4.505 4.505 0 0 1 6.75 4.5h10.5c.41 0 .806.055 1.183.157A3 3 0 0 0 15.75 3h-7.5a3 3 0 0 0-2.684 1.657ZM2.25 12a3 3 0 0 1 3-3h13.5a3 3 0 0 1 3 3v6a3 3 0 0 1-3 3H5.25a3 3 0 0 1-3-3v-6ZM5.25 7.5c-.41 0-.806.055-1.184.157A3 3 0 0 1 6.75 6h10.5a3 3 0 0 1 2.683 1.657A4.505 4.505 0 0 0 18.75 7.5H5.25Z" }, child: [] }] })(e) } const RH = "/assets/AryanImage-BbQ1hd9N.png", LH = () => w.jsxs(oi.div, { className: "grid lg:grid-cols-[1fr_2fr] gap-4 mt-24 w-[90%] lg:w-[70%] md:w-[80%] mx-auto", id: "about", initial: { y: "15%" }, whileInView: { y: 0 }, transition: { duration: .8 }, children: [w.jsxs("div", { className: "grid md:grid-cols-[3fr_2fr_3fr] lg:grid-cols-1 gap-3", children: [w.jsxs("h2", { className: "text-4xl font-extrabold", children: ["The ", w.jsx("br", {}), "Journey ", w.jsx("br", {}), "has a story"] }), w.jsx("p", { className: "text-md text-mainText", children: "Journey Story was created to inspire through real-life experiences of entrepreneurs and leaders, offering insights and motivation for personal and professional growth." }), w.jsxs("ol", { className: "text-md text-mainText", children: [w.jsx("li", { children: "1. Navigating Audio Excellence" }), w.jsx("li", { children: "2. Where Stories Set Sail" }), w.jsx("li", { children: "3. Podcast Pioneers in Action" })] })] }), w.jsxs("div", { className: "flex flex-col md:flex-row gap-6 h-full", children: [w.jsx("div", { className: "w-full h-[450px] md:h-[100%] overflow-hidden", children: w.jsx("img", { loading: "lazy", src: RH, className: "object-cover w-full h-full" }) }), w.jsxs("div", { className: "flex flex-col gap-6 justify-center", children: [w.jsxs("div", { className: "flex gap-4 w-full", children: [w.jsx(kh, { className: "min-w-8 min-h-8 text-primary rounded-full p-1" }), w.jsxs("div", { children: [w.jsx("h3", { className: "text-md font-semibold", children: "Inspirational Interviews" }), w.jsx("p", { className: "text-md text-mainText", children: "Dive into exclusive interviews with top entrepreneurs, CEOs, and industry leaders, uncovering the secrets behind their success stories." })] })] }), w.jsxs("div", { className: "flex gap-4", children: [w.jsx(kh, { className: "min-w-8 min-h-8 text-primary rounded-full p-1" }), w.jsxs("div", { children: [w.jsx("h3", { className: "text-md font-semibold", children: "Diverse Perspectives" }), w.jsx("p", { className: "text-md text-mainText", children: "Explore a wide range of journeys from individuals across different sectors, offering unique insights and strategies that cater to all walks of life." })] })] }), w.jsxs("div", { className: "flex gap-4", children: [w.jsx(kh, { className: "min-w-8 min-h-8 text-primary rounded-full p-1" }), w.jsxs("div", { children: [w.jsx("h3", { className: "text-md font-semibold", children: "Growing Community" }), w.jsx("p", { className: "text-md text-mainText", children: "Join over 50,000 listeners who are part of a thriving community, continuously inspired and motivated by the wealth of knowledge shared on our platform." })] })] })] })] })] }), NH = "/assets/TopPodcast-P4s8bb5c.png", OH = () => w.jsxs(Fy, { className: "py-4 mx-auto bg-transparent text-mainText grid lg:grid-cols-[2fr_3fr] gap-6 w-[90%] lg:w-[70%] md:w-[80%] shadow-none", children: [w.jsx(oi.div, { initial: { x: "-100%" }, animate: { x: 0 }, transition: { duration: 1 }, className: "flex space-x-4", children: w.jsx(j$, { className: "pb-0 pt-2 px-4 flex-col items-start", children: w.jsx("h4", { className: "font-bold text-3xl", children: "A platform which inspires millions" }) }) }), w.jsx(oi.div, { initial: { x: "100%" }, animate: { x: 0 }, transition: { duration: .8 }, className: "flex flex-col md:flex-row justify-center gap-2 flex-1", children: w.jsxs("div", { className: "flex flex-col md:flex-row justify-center gap-2 flex-1 h-full", children: [w.jsx(dg, { className: "overflow-hidden py-2 flex justify-center md:justify-start h-[600px] md:h-[100%]", children: w.jsx("img", { loading: "lazy", alt: "Card background", className: "object-cover w-full h-full", src: NH }) }), w.jsxs(dg, { className: "overflow-visible py-1 flex flex-row md:flex-col gap-8", children: [w.jsxs("div", { className: "font-semibold", children: ["Total Listeners", w.jsx("h2", { className: "text-4xl font-bold text-primary", children: "50K" })] }), w.jsxs("div", { children: [w.jsx("div", { className: "font-normal text-md", children: "Journey Story has a growing community of over 50,000 listeners who tune in for unparalleled insights, inspiration, and wisdom. Be part of the movement and learn from the best in the industry." }), w.jsx("div", { className: "my-5", children: w.jsxs("ul", { className: "list-disc pl-6", children: [w.jsx("li", { children: "Inspiration Hub" }), w.jsx("li", { children: "Diverse Journeys" }), w.jsx("li", { children: "Expert Insights" }), w.jsx("li", { children: "Entrepreneurial Wisdom" })] }) }), w.jsx("div", { children: w.jsx(Lu, { text: "Explore Episodes", toLink: "/episodes" }) })] })] })] }) })] }), jH = () => { const { blogs: e, loading: t } = a0(); HV(); const { team: n, loading: r, error: i } = HB(); return w.jsx("div", { className: "bg-background text-white overflow-hidden", children: w.jsxs("div", { className: "mt-5", children: [w.jsx(QB, {}), w.jsx(GB, {}), w.jsx(OH, {}), w.jsx(XB, { blogs: e, loading: t }), w.jsx(LH, {}), w.jsx(_H, { teamMembers: n, loading: r }), w.jsx(JB, {}), w.jsx(zu, {})] }) }) }, IH = ({ review: e }) => w.jsxs("div", { className: "flex flex-col justify-between gap-4 w-full md:min-w-[300px] p-3 shadow-sm bg-gradient-to-b from-primary to-background min-h-[450px] min-w-[200px]", children: [w.jsx("div", { className: "text-mainText font-semibold text-md p-2", children: e.category }), w.jsx("div", { className: "text-md font-semibold text-mainText", children: e.content }), w.jsx(Q$, { name: e.user.name, description: e.user.description, className: "flex items-start gap-2 text-lg w-full", avatarProps: { src: e.user.avatar, alt: e.user.name, className: "rounded-full" } })] }), _h = [{ category: "Technology", content: "The ultimate platform for storytelling innovation. JS, a hidden gem of innovation, deserves more appreciation.", user: { name: "Pryank Agrawal", description: "Founder & CEO, Housewise.in | IIT Alumni", avatar: "" } }, { category: "Technology", content: "Unlock creativity with Journeystory, the premier storytelling platform. JS's groundbreaking innovation often goes unnoticed, but its brilliance shines through.", user: { name: "Ajay Kalantri", description: "Founder & CEO, bookdoctorstime.com | BITS Pilani", avatar: "" } }, { category: "Technology", content: "Experience storytelling excellence on Journeystory  unmatched innovation. JS, an underappreciated marvel, redefines the art of storytelling.", user: { name: "Ashwin Srivastva", description: "Forbes 30 under 30 | IIT Bombay Alumni", avatar: "" } }], DH = () => { const e = _h.length * 300; return w.jsxs("section", { className: "flex flex-col gap-4 overflow-hidden  mx-auto w-[100%] mt-20", children: [w.jsx("h2", { className: "text-4xl font-extrabold text-center", children: "Customer Reviews" }), w.jsx("div", { className: "relative w-full overflow-hidden", children: w.jsx(oi.div, { className: "flex gap-4", style: { width: `${e * 2}px` }, animate: { x: [0, -(e * (50 / 100))] }, transition: { repeat: 1 / 0, duration: 50, ease: "linear" }, children: _h.concat(_h).map((t, n) => w.jsx(IH, { review: t }, n)) }) })] }) }, FH = () => w.jsx("div", { className: "bg-background text-white overflow-hidden", children: w.jsxs("div", { className: "min-h-[100vh] mt-5 w-full", children: [w.jsx(DH, {}), w.jsx(zu, {})] }) }), VM = ({ story: e, onView: t }) => w.jsxs("div", { className: "relative bg-black rounded-lg shadow-lg overflow-hidden cursor-pointer w-full mx-auto mb-6", onClick: () => t(e), children: [e.imageUrl && w.jsx("img", { src: e.imageUrl, alt: "Story", className: "w-full h-[20rem] md:h-[25rem] object-cover object-center" }), w.jsx("div", { className: "absolute top-[19rem] sm:top-[24rem] left-2 sm:left-4 bg-white py-1 px-2 sm:px-3 rounded-full shadow-lg", children: w.jsx("span", { className: "text-black font-semibold text-xs sm:text-sm", children: "JourneyStory" }) }), w.jsxs("div", { className: "relative p-4 gap-2", children: [e.title && w.jsx("h2", { className: "text-lg md:text-xl font-bold text-white h-[3rem] pt-4", children: e.title }), e.content && w.jsxs("p", { className: "text-sm md:text-base text-gray-300 mt-4", children: [e.content.slice(0, 100), "..."] })] })] }), SS = e => { let t; const n = new Set, r = (u, c) => { const d = typeof u == "function" ? u(t) : u; if (!Object.is(d, t)) { const f = t; t = c ?? (typeof d != "object" || d === null) ? d : Object.assign({}, t, d), n.forEach(p => p(t, f)) } }, i = () => t, a = { setState: r, getState: i, getInitialState: () => l, subscribe: u => (n.add(u), () => n.delete(u)) }, l = t = e(r, i, a); return a }, zH = e => e ? SS(e) : SS, VH = e => e; function BH(e, t = VH) { const n = se.useSyncExternalStore(e.subscribe, () => t(e.getState()), () => t(e.getInitialState())); return se.useDebugValue(n), n } const ES = e => { const t = zH(e), n = r => BH(t, r); return Object.assign(n, t), n }, UH = e => e ? ES(e) : ES, HH = "https://fullstack-3-j490.onrender.com", np = UH((e, t) => ({ authUser: null, stories: null, getBaseUrl: () => HH, checkAuth: async () => { try { const n = t().getBaseUrl() + "/auth/checkAuth", r = await fetch(n, { method: "GET", headers: { "Content-type": "application/json" }, credentials: "include" }), i = await r.json(); return r.ok && e({ authUser: i.user }), i } catch (n) { console.log("error", n.message) } }, login: async n => { try { const r = t().getBaseUrl() + "/auth/login", i = await fetch(r, { method: "POST", headers: { "Content-type": "application/json" }, body: JSON.stringify(n), credentials: "include" }); if (!i.ok) { const s = await i.json(); return console.log(s.success), s } const o = await i.json(); return e({ authUser: o.user }), console.log("Authuser from store: ", o.user), o } catch (r) { console.log("Error", r.message) } }, logout: async () => { try { const n = t().getBaseUrl() + "/auth/logout", r = await fetch(n, { method: "POST", headers: { "Content-type": "application/json" }, credentials: "include" }); if (!r.ok) return await r.json(); const i = await r.json(); return e({ authUser: null }), i } catch (n) { console.log("error", n.message) } }, signup: async n => { console.log("details in authstore", n); try { const r = t().getBaseUrl() + "/auth/signup", i = await fetch(r, { method: "POST", headers: { "Content-type": "application/json" }, body: JSON.stringify(n), credentials: "include" }); return i.ok ? await i.json() : await i.json() } catch (r) { console.log("Error", r.message) } }, publishStory: async n => { try { const r = t().getBaseUrl() + "/stories/publish", i = await fetch(r, { method: "POST", headers: { "Content-type": "application/json" }, body: JSON.stringify(n), credentials: "include" }); if (!i.ok) { const s = await i.json(); return console.log(s.message), s } const o = await i.json(); console.log(o.message) } catch (r) { console.log("error while publishing story", r.message) } }, approvedStory: async () => { try { const n = t().getBaseUrl() + "/stories/approved", r = await fetch(n, { method: "GET", headers: { "Content-type": "application/json" }, credentials: "include" }); if (!r.ok) return await r.json(); const i = await r.json(); return e({ stories: i.approvedStories }), console.log("data stories", i), i } catch (n) { console.log("error while approved fetching story", n.message) } } })), WH = () => { const e = ts(), { stories: t, approvedStory: n } = np(), r = o => { console.log("Navigating to story-detail with story:", o), e("/story-detail", { state: { story: o } }) }; S.useEffect(() => { (async () => { n() })() }, [n]); const i = () => { e("/login") }; return w.jsxs("div", { className: "bg-black min-h-screen p-8", children: [w.jsx("h2", { className: "text-3xl font-bold text-white mb-6 text-center text-[3rem]", children: "Stories" }), w.jsx("div", { className: "flex justify-center mb-8", children: w.jsx("button", { onClick: i, className: "text-gray-300 bg-blue-600 font-semibold text-[1.3rem] cursor-pointer w-[12rem] rounded-md h-11", children: "Publish a Story" }) }), t && t.length > 0 ? w.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-10 px-4 sm:px-8 py-10", children: t.map((o, s) => w.jsx(VM, { story: o, onView: r }, s)) }) : w.jsx("p", { className: "text-gray-400 text-center text-[1.8rem]", children: "No stories published yet." })] }) }; function BM(e) { return vr({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "m15 18-.722-3.25" }, child: [] }, { tag: "path", attr: { d: "M2 8a10.645 10.645 0 0 0 20 0" }, child: [] }, { tag: "path", attr: { d: "m20 15-1.726-2.05" }, child: [] }, { tag: "path", attr: { d: "m4 15 1.726-2.05" }, child: [] }, { tag: "path", attr: { d: "m9 18 .722-3.25" }, child: [] }] })(e) } function GH() { const [e, t] = S.useState(""), [n, r] = S.useState(""), [i, o] = S.useState(""), [s, a] = S.useState(!1), [l, u] = S.useState(!0), { login: c, signup: d } = np(), f = ts(), p = async m => { if (m.preventDefault(), !l && !i) { console.log("Full Name is required!"); return } const v = { email: e, password: n, fullName: i }; let x; l ? x = await c(v) : x = await d(v), x.success ? (console.log(`${l ? "Login" : "Signup"} successful: `, x.message), f("/publish")) : console.log(`${l ? "Login" : "Signup"} failed: `, x.message) }; return w.jsx("div", { className: "w-full h-[calc(100vh-112px)] flex justify-center items-center", children: w.jsxs("form", { onSubmit: p, className: "flex flex-col bg-black p-4 w-[350px] h-[400px] rounded-md", children: [w.jsx("h4", { className: "text-center text-2xl mb-4", children: l ? "LOGIN" : "SIGNUP" }), !l && w.jsx("input", { type: "text", value: i, className: "w-full border-2 rounded-md mb-4 p-2 text-black", onChange: m => o(m.target.value), placeholder: "Full Name", required: !l }), w.jsx("input", { type: "email", value: e, className: "w-full border-2 rounded-md mb-4 p-2 text-black", onChange: m => t(m.target.value), placeholder: "example@gmail.com", required: !0 }), w.jsxs("div", { className: "relative", children: [w.jsx("input", { type: s ? "text" : "password", value: n, className: "w-full border-2 rounded-md mb-4 p-2 text-black", onChange: m => r(m.target.value), placeholder: "* * * * * *", required: !0 }), s ? w.jsx(j2, { className: "absolute top-4 right-5", onClick: () => a(!s) }) : w.jsx(BM, { className: "absolute top-4 right-5", onClick: () => a(!s) })] }), w.jsx("button", { type: "submit", className: "bg-blue-500 text-white p-2 rounded-md mb-4", children: l ? "LOGIN" : "SIGNUP" }), w.jsx("div", { className: "text-center", children: w.jsx("span", { className: "text-blue-500 cursor-pointer", onClick: () => u(!l), children: l ? "Don't have an account? Signup" : "Already have an account? Login" }) })] }) }) } function KH() { const [e, t] = S.useState(""), [n, r] = S.useState(""), [i, o] = S.useState(""), [s, a] = S.useState(!1); S.useState(""); const { signup: l } = np(), u = ts(), c = async d => { d.preventDefault(), (!e || n || !i) && console.log("something is missing"), (await l({ fullName: e, email: n, password: i })).success && u("/publish") }; return w.jsx("div", { className: "w-full h-[calc(100vh-112px)]  flex justify-center items-center", children: w.jsxs("form", { className: "flex flex-col bg-white p-4 w-[350px] h-[300px] rounded-md", children: [w.jsx("h4", { className: "text-center text-2xl mb-4", children: "SIGNUP" }), w.jsx("input", { type: "text", value: e, className: "border-2 rounded-md mb-4 p-2", onChange: d => t(d.target.value), placeholder: "John Doe" }), w.jsx("input", { type: "email", value: n, className: "border-2 rounded-md mb-4 p-2", onChange: d => r(d.target.value), placeholder: "example@gmail.com" }), w.jsxs("div", { className: "w-full relative ", children: [w.jsx("input", { type: s ? "text" : "password", value: i, className: "w-full border-2 rounded-md mb-4 p-2", onChange: d => o(d.target.value), placeholder: "* * * * * * *" }), s ? w.jsx(j2, { className: " absolute top-4 right-5", onClick: () => a(!s) }) : w.jsx(BM, { className: "absolute top-4 right-5", onClick: () => a(!s) })] }), w.jsx("button", { onClick: c, className: "bg-blue-500 text-white p-2 rounded-md", children: "SIGNUP" })] }) }) } const qH = () => { const [e, t] = S.useState({ title: "", content: "" }), [n, r] = S.useState("No file selected"), [i, o] = S.useState(null), [s, a] = S.useState(!1), l = ts(), { logout: u, publishStory: c } = np(), d = async m => { if (m.preventDefault(), !e.title || !e.content) { alert("Please fill in all fields before submitting."); return } try { const v = { imageUrl: i, title: e.title, content: e.content }; await c(v), a(!0) } catch (v) { console.error("Error submitting story:", v), alert("Failed to submit the story. Please try again.") } }, f = async () => { try { const m = await u(); m.success ? (console.log("message:", m.message), l("/login")) : (console.log("message:", m.message), alert(m.message)) } catch (m) { console.error("Error during logout:", m) } }, p = async m => { const v = m.target.files[0]; if (!v) { r("No file selected"); return } r(v.name); const x = new FileReader; x.readAsDataURL(v), x.onload = () => { o(x.result) }, x.onerror = () => { alert("Failed to upload image. Please try again.") } }; return w.jsx("div", { className: "bg-black min-h-screen flex items-center justify-center pb-[50rem] pt-[2rem]", children: w.jsxs("div", { className: "min-h-full bg-white p-8 rounded-lg shadow-lg w-[80rem] sm:w-[90%] xs:w-[95%] max-w-[100%]", children: [w.jsx("h2", { className: "text-2xl font-bold mb-4 flex items-center text-black", children: "Publish a New Story" }), s ? w.jsx("p", { className: "text-green-600 text-lg", children: "Story submitted for review!" }) : w.jsxs("form", { onSubmit: d, children: [w.jsx("input", { type: "text", placeholder: "Headline", value: e.title, onChange: m => t({ ...e, title: m.target.value }), className: "w-full mb-4 p-2 border rounded placeholder:border-opacity-60 text-black" }), w.jsx("textarea", { placeholder: "Content", value: e.content, onChange: m => t({ ...e, content: m.target.value }), className: "w-full h-[22rem] mb-4 p-2 border rounded placeholder:border-opacity-60 text-black" }), w.jsx("div", { className: "w-[100px]", children: i ? w.jsx("img", { src: i, className: "h-full object-cover", alt: "Preview" }) : w.jsx("p", { className: "text-gray-900 text-sm", children: "No image selected" }) }), w.jsxs("div", { className: "flex items-center gap-4 my-2", children: [w.jsx("input", { type: "file", id: "file-input", style: { display: "none" }, onChange: p }), w.jsx("label", { htmlFor: "file-input", style: { cursor: "pointer", padding: "10px", background: "lightblue", borderRadius: "5px" }, children: "Upload File" }), w.jsx("p", { className: "text-black", children: n }), " "] }), w.jsxs("div", { className: "flex gap-4", children: [w.jsx("button", { type: "submit", className: "bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-500 w-44", children: "Publish" }), w.jsx("button", { type: "button", className: "bg-red-600 text-white px-4 py-2 rounded hover:bg-red-500 w-44", onClick: f, children: "LOGOUT" })] })] })] }) }) }, YH = () => { const e = es(), { story: t } = e.state || {}; return t ? w.jsx("div", { className: "bg-black min-h-screen p-8", children: w.jsxs("div", { className: "bg-white max-w-2xl mx-auto p-6 rounded-lg shadow-lg", children: [w.jsx("h1", { className: "text-4xl font-bold mb-4 text-black", children: t.title }), w.jsx("img", { src: t.imageUrl, alt: "Story", className: "w-[40rem] h-[23rem] object-cover mb-6" }), w.jsx("p", { className: "text-lg text-black", children: t.content })] }) }) : w.jsx("div", { className: "text-white text-center", children: "Story not found." }) }, QH = v7([{ path: "/", element: w.jsx(O7, {}), children: [{ path: "/", element: w.jsx(jH, {}) }, { path: "/episodes", element: w.jsx(UB, {}) }, { path: "/blogs", element: w.jsx(tB, {}) }, { path: "/reviews", element: w.jsx(FH, {}) }, { path: "/contact-us", element: w.jsx(iB, {}) }, { path: "/blogs/:id", element: w.jsx(YV, {}) }, { path: "/stories", element: w.jsx(WH, {}) }, { path: "/story-detail", element: w.jsx(YH, {}) }, { path: "/login", element: w.jsx(GH, {}) }, { path: "/publish", element: w.jsx(qH, {}) }, { path: "/signup", element: w.jsx(KH, {}) }, { path: "/storycards", element: w.jsx(VM, {}) }] }, { path: "/*", element: w.jsx(l7, { to: "/" }) }]), XH = new g2({ defaultOptions: { queries: { refetchOnWindowFocus: !1 } } }); Rh.createRoot(document.getElementById("root")).render(w.jsx(S.StrictMode, { children: w.jsx(s4, { children: w.jsx(v2, { client: XH, children: w.jsx(s7, { router: QH }) }) }) })); export { aW as C, D3 as a, ZH as b, JI as c, CS as d, pI as g };
